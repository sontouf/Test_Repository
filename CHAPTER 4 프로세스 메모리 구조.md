#PART 2 메모리

# CHAPTER 4 프로세스 메모리 구조

4장에서는 프로세스 내부의 메모리 및 메모리 구조를 다룬다. C 언어 개발자에게 메모리 관리는 언제나 중요하며, 가장 좋은 방식을 적용하려면 메모리 구조에 관한 기초 지식이 필요하다. 이는 사실 C 언어에만 국한되지는 않는다. C++이나 자바와 같은 여러 프로그래밍 언어도 메모리 및 메모리 작동방식을 근본적으로 이해해야 한다. 이해하지 못하면 문제를 쉽게 추적하거나 수정하기 어려운 문제와 마주하게 된다.

C언어에서 메모리는 완전히 수동으로 관리된다. 메모리 영역을 할당하거나 또는 더 이상 필요하지 않게 된 메모리를 해제하는 일은 개발자만이 담당한다.

자바나 C#과 같은 고수준 프로그래밍 언어의 경우 C 와는 메모리 관리 방식이 다르다. 일부는 개발자가, 일부는 기본 언어 플랫폼이 메모리를 관리한다. 자바를 사용한다면 __자바 가상 머신(JVM)__ 이 기본 언어 플랫폼에 해당한다. 이러한 언어에서 메모리를 할당할 수 있는 건 개발자뿐이지만, 메모리 해제가 반드시 개발자에게 달려 있는 것은 아니다. 가비지 컬렉터라는 컴포넌트가 기존의 할당된 메모리를 자동을 해제한다.

C와 C++에는 이러한 가비지 컬렉터가 없으므로, 메모리 관리의 개념 및 문제를 다루는 장이 필요하다. 그러므로 이번 4장과 다음 5장에서 메모리 개념을 집중적으로 살펴볼 것이며, 이를 통해 C/C++의 메모리 작동 방식을 기초부터 이해해보자.

4장에서는 다음 내용을 배운다.

- 프로세스의 일반적인 메모리 구조를 살펴보자. 프로세스의 구조 및 메모리와 프로세스의 상호작용 방식을 알아보는 데 도움이 될 것이다.
- 정적 메모리 레이아웃과 동적 메모리 레이아웃을 다룬다.
- 앞서 언급한 메모리 레이아웃에 나온 세그먼트를 소개한다. 실행 가능한 목적 파일에 탑재된 세그먼트와 프로세스가 로딩되는 동안 만들어지는 세그먼트를 살펴본다.
- 메모리 조사 도구 및 명령어를 소개한다. 이는 세그먼트를 감지하고 세그먼트의 내용을 볼 수 있게 도와준다 메모리 조사 도구와 명령어는 목적  파일과 실행 중인 프로세스 내부에 있다.

이번 장에서는 __스택__ 과 __힙__ 세그먼트를 소개한다. 스택과 힙은 프로세스의 동적 메모리 레이아웃에 속하며, 모든 메모리 할당과 해제는 이 세그먼트에서 일어난다. 스택과 힙은 다음 장에서 더 상세하기 다룬다. 실제로 개발자가 스택과 힙을 가장 많이 다루기 때문이다.

__프로세스 메모리 레이아웃__ 부터 시작해보자. 실행 중인 프로세스의 메모리가 세그먼트로 분할되는 방식과 각 세그먼트의 용도를 전반적으로 보자



## 4. 1 프로세스 메모리 레이아웃

실행 파일을 열 때마다 운영체제는 새 프로세스를 만든다. 프로세스는 실행중인 프로그램이며 이 프로그램은 메모리에 로딩된다. 그리고 고유의 __프로세스 식별자(PID)__ 를 가진다. 운영체제는 새 프로세스의 스폰과 로딩을 담당하는 유일한 개체이다.

프로세스는 정상적으로 종료될 때까지, 또는 SIGTERM, SIGINT, SIGKILL과 같은 종료 신호가 주어질 때까지 계속 실행된다. SIGTERM와 SIGINT 신호는 무시될 수 있지만, SIGKILL은 프로세스를 강제로 즉시 종료하도록 한다.

```
- SIGTERM : 종료신호이다. 프로세스를 청소하도록 한다.
- SIGINT : 인터럽트 신호이다. ctrl+c 를 눌러 포그라운드 프로세스로 전달한다.
- SIGKILL : 킬 신호이다. 프로세스를 청소하지 않고 강제로 종료한다.
```

프로세스를 생성할 때 운영체제는 프로세스를 위한 메모리를 가장 먼저 할당한 다음, 미리 정의된 메모리 레이아웃을 적용한다. 이렇게 미리 정의된 메모리 레이아웃은 특히 유닉스 계열의 다른 운영체제에서도 거의 같다.

일반적인 프로세스의 메모리 레이아웃은 여러부분으로 분할된다. 각 부분은 __세그먼트__ 라고 한다. 각 세그먼트는 정해진 작업을 수행하며 특정 자료형을 저장하는 메모리 영역이다. 다음은 실행 중인 프로세스의 메모리 레이아웃에 포함되는 목록이다.

- 초기화되지 않은 데이터 세그먼트 또는 BSS(block started by symbol) 세그먼트
- 데이터 세그먼트
- 텍스트 세그먼트 또는 코드 세그먼트
- 스택 세그먼트
- 힙 세그먼트



## 4.2 메모리 구조 알아보기

	유닉스 계열 운영체제는 프로세스의 메모리 세그먼트를 검사하는 일련의 도구를 제공한다. 이번 절에서는 어떤 세그먼트는 실행 가능한 목적 파일 내에 존재하며, 다른 세그먼트는 프로세스가 스폰되었을 때 프로그램이 런타임 동안 동적으로 생성된다는 점을 학습한다.

앞서 두 개 장에서 살펴본 대로, 실행 가능한 목적 파일과 프로세스는 같은 것이 아니다. 그러므로 각각을 검사하려면 서로 다른 도구가 필요하다.

실행 가능한 목적 파일은 기계명령어를 포함하며 컴파일러에 의해 생성된다고 학습했다. 하지만 프로세스는 실행 중인 프로그램이며 실행 가능한 목적 파일에 의해 스폰된 것이다. 프로세스는 메인 메모리 영역을 소비한다. CPU는 계속 메모리의 명령어를 가져와서 실행한다.

프로세스는 운영체제 내에서 실행 중인 개체이다. 반면, 실행 가능한 목적 파일은 그저 파일에 불과하다. 이 파일은 향후 프로세스를 스폰하는 토대가 되는, 미리 만들어진 초기 레이아웃 작업을 포함한다. 실행 중인 프로세스의 메모리 레이아웃에서, 몇몇 세그먼트는 토대가 되는 실행 가능한 목적 파일에서 직접 만든다. 다른 세그먼트는 프로세스가 로딩될 때, 프로그램이 실행되는 동안 동적으로 생성된다. 전자는 __정적 메모리 레이아웃__ 이며 후자는 __동적 메모리 레이아웃__ 이라고 한다.

정적 메모리 레이아웃과 동적 메모리 레이아웃은 사전에 정의된 세그먼트의 집합이다. 정적 메모리 레이아웃의 내용은 소스 코드를 컴파일 할 때 컴파일러가 실행 가능한 목적 파일에 미리 작성한다. 반면 동적 메모리 레이아웃의 내용은 프로그램의 명령어에 따라 작성된다. 프로그램 명령어는 변수와 배열에 메모리를 할당하며, 프로그램의 로직에 따라 변수와 배열을 수정한다.

소스코드나 컴파일된 목적 파일만 봐도 정적 메모리 레이아웃의 내용을 추측할 수 있다. 그러나 동적 메모리 레이아웃의 내용은 프로그램을 실행하지 않으면 결정 되지 않으므로 쉽게 달라진다. 게다가 같은 실행 파일이라도 실행할 때마다 동적 메모리 레이아웃의 내용이 달라진다. 즉, 프로세스의 동적 내용은 해당 프로세스마다 다르므로 프로세스가 실행되는 동안 검사가 이루어져야 한다.



## 4.3 정적 메모리 레이아웃 검사하기

정적 메모리 레이아웃을 검사하는 도구는 목적 파일에서 주로 작동한다.

```c
int main(int argc, char** argv)
{
    return 0;
}
```

```shell
$ gcc main.c -o exe.out
```

컴파일에 성공한 뒤 최종 실행 이진 파일이 링크 되면 exe.out 이라는 실행 가능한 목적 파일이 만들어진다. 이 파일은 리눅스 운영체제 전용으로 미리 정의된 정적 메모리 레이아웃을 포함한다. 향후 이 실행 파일에 기반해 스폰되는 모든 프로세스에 이 정적 메모리 레이아웃이 존재할 것이다.

첫번 째로 소개할 도구는 size 명령어이다. 실행 가능한 목적 파일의 정적 메모리 레이아웃을 출력할 때 사용한다.

```shell
$ size exe.out
	text	data	bss		dec 	hex		filename
	1099	 544	  8	   1651 	673		exe.out
$
```

텍스트, 데이터, BSS 세그먼ㅌ는 정적 레이아웃에 속한다. 표시된 크기는 바이트 단위이다.



```shell
$ clang main.c -o exe.out
$
```

macOS는 리눅스처럼 POSIX를 준수하는 운영체제며 size 명령어는 POSIX 유틸리티 프로그램에 속하므로 macOS에도 size 명령어가 있다. 따라서 exe.out의 정적 메모리 세그먼트를 보기 위해 같은 명령어를 사용할 수 있다.



```shell
$ size exe.out
__TEXT  __DATA __OBJC  others	     dec		   hex
4096	0	   0 	   4294971392	 4294975488    10002000
$ size -m exe.out
Segment __PAGEZERO: 4294967296
Segment __TEXT: 4096
	Section __text: 22
	Section __unwind_info: 72
	total 94
Segment __LINKDIT: 4096
Total 4294975488
$
```

size 명령어를 두 번 실행했다. 두 번째 실행을 보면 탐색한 메모리 세그먼트의 자세한 내용을 알 수 있다. 리눅스처럼 macOS에서도 텍스트와 데이터 세그먼트가 있지만 BSS 세그먼트는 없다.  macOS에도 BSS 세그먼트는 존재하지만 size 출력으로는 보이지 않다는 점에 유의하자. BSS 세그먼트는 초기화되지 않은 전역 변수를 포함하므로 목적 파일에서 바이트를 할당할 필요는 없으며, 전역 변수를 저장하는데 필요한 바이트가 얼마인지를 아는 것만으로 충분하다.

앞의 셸 박스에서 주목한 흥미로운 점이 있다. 텍스트 세그먼트의 크기는 리눅스에서 1099바이트이지만, macOS에서는 4KB라는 점이다. 가장 작은 C 프로그램에 대한 데이터 세그먼트는 리눅스에서 0이 아닌 크기로 나타나지만 macOS에서는 크기가 0이다. 저수준 메모리의 세부사항은 플랫폼마다 확실히 다르다.

리눅스와 macOS 간의 이러한 작은 차이에도 불구하고, 두 플랫폼은 모두 정적 레이아웃에 텍스트, 데이터, BSS 세그먼트가 있다.



### 4.3.1 BSS 세그먼트

__BSS__ 는 __심벌로 시작되는 블록 block started by symbol__ 을 뜻한다. 역사적으로 이 이름은 초기화되지 않은 워드를 위해 예약된 영역을 나타내고자 사용되었다. 기본적으로는 초기화되지 않은 전역 변수나 0으로 설정된 전역 변수에 BSS 세그먼트를  사용한다.

아까의 예제에서 몇 개의 초기화되지 않은 전역변수를 더해 확장해보자

```c
// 초기화되지 않았거나 0으로 설정된 전역 변수 몇 개를 갖는 간단한 c 프로그램
int global_var1;
int global_var2;
int global_var3 = 0;

int main(int argc, char** argv)
{
	return 0;
}
```

global_var 1,2,3는 초기화되지 않은 전역 변수이다. 변화를 살펴보고자 size 명령어를 써보자

```shell
$ gcc main.c -o exe.out
$ size exe.out
	text	data	bss		dec 	hex		filename
	1099	 544	 16	   1659 	67b		exe.out
$
```

앞선 예제와 비교해서 bss 세그먼트의 크기가 바뀌었음을 알 수 있다. 즉 초기화되지 않았거나 0으로 설정된 전역 변수를 선언하면 BSS 세그먼트에 추가된다. 이러한 특별한 전역 변수는 정적 레이아웃에 속하며, 프로세스가 로딩될 때 미리 할당된다. 그리고 프로세스가 살아 있는 한 절대로 할당이 해제되지 않는다. 즉, 정적인 수명을 가진다고 할 수 있다.



```shell
$ clang main.c -o exe.out
$ size exe.out
__TEXT  __DATA __OBJC  others	     dec		   hex
4096	4096	   0   4294971392	 4294979584    10003000
$ size -m exe.out
Segment __PAGEZERO: 4294967296
Segment __TEXT: 4096
	Section __text: 22
	Section __unwind_info: 72
	total 94
Segment __DATA: 4096
	Section __common: 12
	total 12
Segment __LINKDIT: 4096
Total 4294979584
$
```

리눅스에서는 전역 변수가 없을 때 BSS 세그먼트에 8바이트를 미리 할당했다. 예제에서는 초기화되지 않은 새 전역 변수 3개를 추가했고 이들 크기를 모두 합쳐 12바이트였다. 그리고 리눅스 C 컴파일러는 BSS 세그먼트를 8바이트만큼 더 확장했다. 하지만 macOS의 경우 size 출력결과에는 여전히 BSS 세그먼트가 없지만 컴파일러는 데이터 세그먼트를 0바이트에서 4KB로 늘렸으며, 그 크기는 macOS의 기본 페이즈 크기에 해당한다. 즉, clang이 레이아웃 내에서 데이터 세그먼트에 대한 새로운 메모리 페이지를 할당했음을 의미한다. 이는 곧 다양한 플랫폼에서 메모리 레이아웃의 세부 사항이 얼마나 다른지를 간단히 보여준다고 할 수 있다.

위 셸 박스에서는 `__DATA` 세그먼트 안에 12 바이트인 `__common` 이라는 섹션이 있다. 이는 사실상 size에 대한 출력에서 BSS 로 표시되지 않은 BSS 세그먼트에 해당한다. 이 섹션은 초기화되지 않은 전역 변수 3개 또는 12바이트를 나타낸다. 초기화되지 않은 전역 변수는 기본적으로 0으로 설정된다.



### 4.3.2 데이터 세그먼트

데이트 세그먼트에 저장되는 변수의 종류를 알아보고자 전역 변수를 더 선언해보자. 하지만 이번에는 0이 아닌 값으로 초기화한다.

```c
// 초기화되지 않았거나 0으로 설정된 전역 변수 몇 개를 갖는 간단한 c 프로그램
int global_var1;
int global_var2;
int global_var3 = 0;

double global_var4 = 4.5;
char global_var5 = 'A';

int main(int argc, char** argv)
{
	return 0;
}
```

```shell
$ gcc main.c -o exe.out
$ size exe.out
	text	data	bss		dec 	hex		filename
	1099	 553	 20	   1672 	688		exe.out
$
```

우리는 데이터 세그먼트가 0이 아닌 값으로 설정되어 초기화된 전역변수를 저장하기 위해 사용된다는 점을 알고 있다. 앞선 예제와 size 출력결과를 비교해보면, 데이터 세그먼트가 9바이트(double - 8, char - 1) 증가했음을 쉽게 알아볼 수 있다.

macOS에서의 변화를 보자.

```shell
$ clang main.c -o exe.out
$ size exe.out
__TEXT  __DATA __OBJC  others	     dec		   hex
4096	4096	   0   4294971392	 4294979584    10003000
$ size -m exe.out
Segment __PAGEZERO: 4294967296
Segment __TEXT: 4096
	Section __text: 22
	Section __unwind_info: 72
	total 94
Segment __DATA: 4096
	Section __data: 9
	Section __common: 12
	total 21
Segment __LINKDIT: 4096
Total 4294979584
$
```

첫번째 실행에서는 변화가 없다. 전역 변수의 크기의 합이 여전히 4KB보다 작기 때문이다. 하지만 두 번째 실행에서는 `_DATA` 세그먼트에 속하는 새로운 섹션이 보인다. `_data` 섹션이다. 이 섹션에 할당된 메모리는 9바이트이며, 이는 새로 추가한 초기화된 전역 변수의 크기에 해당한다. 하지만 macOS 에서는 초기화되지 않은 변수에 대해 12바이트를 갖는다.

참고할 사항은 size 명령어는 세그먼트의 크기만을 보여줄 뿐 내용을 보여주지는 않는다는 것이다. 각 운영체제마다 목적 파일에 있는 세그먼트의 내용을 검사할 때 사용할 수 있는 다른 명령어가 있다. 예를 들어 리눅스에서는 ELF 파일의 내용을 보는 readelf와 objdump 명령어가 있다. 이러한 도구는 목적 파일 내부의 정적 메모리 레이아웃을 검사할 때 사용할 수도 있다.

전역변수 외에도 함수 내부에서 선언된 정적 변수가 있다. 이 변수는 같은 함수가 여러번 호출되는 동안 그 값을 유지한다. 정적 변수는 플랫폼 및 초기화 여부에 따라 데이터 세그먼트 또는 BSS 세그먼트에 저장될 수 있다.

```c
void func() {
    static int i;
    static int j = 1;
}
```

i 와 j 는 정적 변수이다. 변수 i 는 초기화되지 않았고 j 는 1로 초기화되었다. func 함수에 들어갔다 나오는 횟수와는 무관하며, 두 변수는 최신 값을 유지한다.

어떻게 이러한 일이 일어나는지를 더 자세히 살펴보면, 런타임 시에 func 함수는 데이터 세그먼트 또는 BSS 세그먼트에 위치한 두 변수로 접근한다. 이를 기본적으로 __정적__ 변수라고 한다. 변수 j는 데이터 세그먼트에 위치하는데 초깃값을 갖기 때문이다. 변수 i는 초기화되지 않았으므로 BSS 세그먼트 내에 있어야 한다.

이제 BSS 세그먼트의 내용을 검사하는 두 번째 명령어를 소개하겟다. 리눅스에서는 목적 파일에 있는 메모리 세그먼트의 내용을 출력하기 위해 objdump 명령어를 사용할 수 있다. macOS에는 해당 명령어로 gobjdump가 있으며 사용하기 전에 먼저 설치해야 한다.

```c
int x = 33;			// 0x0000021
int y = 0x12153467;
char z[6] = "ABCDE";

int main(int argc, char** argv)
{
    return 0;
}
```

초깃값이 있는 전역 변수 3개가 선언되어있다. 컴파일한 다음에는 작성된 값을 찾기 위해 데이터 세그먼트의 내용을 덤프해야 한다.

```shell
$ gcc main.c -o exe.out
$ objdump -s -j .data exe.out

exe.out: file format elf64-x86-64

Contents of section .data:
	601020 0000000 00000000 00000000 0000000 ...............
	601030 2100000 67341512 41424344 4500    !....4..ABCDE.
```

앞의 출력에서 특히 .data 섹션의 내용을 읽는 법을 설명하겠다. 왼쪽 첫 번째 열은 주소 열이다. 다음 4개의 열은 그 내용이며, 각각은 4바이트 크기의 데이터를 나타낸다. 따라서 한 행마다 16바이트의 내용이 있다. 오른쪽에 보이는 마지막 열은 중간 열에서 보이는 바이트와 같은 크기의 아스키 표현을 나타낸다. 점 문자는 알파벳이나 나타낼 수 없는 문자를 뜻한다. -s 옵션은 opjdump가 선택된 섹션의 모든 내용을 보여주도록 하며, -j .data 옵션은 .data 섹션의 내용을 모두 표시하도록 명령한다.

첫 번째 줄은 0으로 채워진 16바이트이다. 여기에 저장된 변수는 없으니 특별한 것은 없다. 두 번째 줄은 주소 0x601030으로 시작하는 데이터 세그먼트의 내용을 나타낸다. 첫 번째 4바이트는 변수 x에 저장된 값이다. 그 다음 4바이트는 변수 y의 값을 포함한다. 마지막 6바이트는 배열 z 내부의 문자이다. z의 내용은 마지막 열에 확실하게 보인다.

여기서 셸 박스를 볼때 16진수로 저장된 값이 역전된 것처럼 보인다. 이는 __엔디언__ 개념 때문이다.

일반적으로 __빅 엔디언__ 과 __리틀 엔디언__ 두 종류의 엔디언이 있다. 0x12153467 은 0x12153467을 나타내는 빅 엔디언이며 가장 큰 바이트인 0x12가 맨 앞에 온다. 하지만 0x67341512는 0x12153467을 나타내는 리틀 엔디언이며, 가장 작은 바이트인 0x67이 맨 앞에 온다.

엔디언이 무엇이든 우리는 C 언어에서 항상 정확한 값을 읽는다. 엔디언 CPU의 속성이며, CPU가 다르면 최종 목적 파일에서 바이트 순서가 달라진다. 이러한 이유로 다른 엔디언이 있는 하드웨어에서는 실행 가능한 목적 파일을 실행할 수 없다.

이 절에서 마지막으로 참고할 사항은 리눅스의 readelf 와 macOS의 dwarfdump와 같은 도구도 목적 파일의 내용을 검사하기 위해 사용할 수 있다는 점이다. 목적 파일의 이진 파일 내용은 hexdump와 같은 도구로도 읽을 수 있다.



### 4.3.3 텍스트 세그먼트

링커는 컴파일 결과로 얻은 기계수준의 명령어를 최종 실행 가능한 목적 파일로 작성한다. 텍스트 세그먼트 또는 코드 세그먼트는 프로그램의 모든 기계 수준 명령어를 포함한다. 이 명령어는 정적 메모리 레이아웃에 속해 실행 가능한 목적 파일에 위치해야 한다. 이 명령어는 프로세서가 가져와서 프로세스가 실행될 때 함께 실행된다.

더 자세히 알아보기 위해 실제 실행 가능한 목적 파일의 텍스트 세그먼트를 살펴보자. 이를 위한 새로운 예제를 소개한다.

```c
int main(int argc, char ** argv)
{
    return 0;
}
```

실행 가능한 목적 파일의 여러 부분을 덤프하기 위해 objdump를 사용할 수 있다. objdump 명령어는 리눅스에서만 사용할 수 있으며, 다른 운영체제는 각각 자체적으로 같은 일을 하는 명령어 집합이 있다는 점을 참고한다.

```shell
$ gcc main.c -o exe.out
$ objdump -S exe.out

exe.out: file format elf64-x86-64
Disassembly of section .init:

00000000400390 <_init>:
... 결과생략
.
.
Disassembly of section .plt:
000000004003b0 <__libc_start_main@plt-0x10>:
... 결과생략

000000004004d6 <main>:
 4004d6: 55
 4004d7: 48 89 e5
 4004da: b8 00 00 00 00
... 생략

```

예제에서 보이듯 기계 수준의 명령어를 포함하는 .text. .init. .plt 와 같은 다양한 섹션이 존재하며 이 섹션 모두는 프로그램이 로드 및 실행될 수 있도록 한다. 이 섹션은 모든 실행 가능한 목적 파일 내부에 있는 정적 메모리 레이아웃에 나타나는 동일한 텍스트 세그먼트에 속한다.

C 프로그램에는 단 하나의 main 만 있다. 하지만 보다시피 최종 실행 가능한 목적 파일에는 다른 여러 함수가 있다.

셀 박스에 나타나는 출력은 main 함수가 C 프로그램에서 호추로디는 첫 번째 함수가 아니라는 점을 보여준다. 그리고 main 함수 전후로 실행되는 로직이 있다. 2장에서 설명했듯, 리눅스에서 이러한 함수는 보통 glibc 라이브러리에서 빌려 오며, 링커가 이들을 모두 합쳐서 최종 실행 가능한 목적 파일을 형성한다.



## 4.4 동적 메모리 레이아웃 검사하기

	동적 메모리 레이아웃은 실제로 프로세스의 런타임 메모리이며 프로세스가 실행되는 동안에 존재한다. 실행 가능한 목적 파일을 실행할 때, __로더__ 가 호출한 프로그램은 실행을 처리한다. 이 프로그램은 프로세스를 스폰하고 초기 메모리 레이아웃을 생성하며 이 는 동적 메모리 레이아웃이 된다. 이 레이아웃을 만들기 위해 정적 레이아우셍 있는 세그먼트는 실행 가능한 목적 파일로 복제된다. 새로운 세그먼트도 2개가 더해진다. 이 과정이 끝나야 프로세스가 처리되고 실행될 수 있다.

죽, 실행 중인 프로세스의 메모리 레이아웃에는 세그먼트가 5개 존재한다고 할 수 있다. 이 중 3개는 실행 가능한 목적 파일에 있는 정적 레이아웃에서 직접 복제된 것이다. 새로 추가된 2개의 세그먼트는 스택과 힙 세그먼트라고 한다. 이들 세그먼트는 동적이며 프로세스가 실행 중일 때만 존재한다. 이는 실행 가능한 목적 파일에서는 이 두 세그먼트에 대한 어떠한 흔적도 찾을 수 없다는 점을 의미한다.

이번 절의 궁극적인 목표는 스택과 힙 세그먼트를 검사하는 것이며, 운영체제 내에서 이 세그먼트의 검사를 위해 사용할 수 있는 도구 및 위치를 소개하겠다. 종종 목적 파일로부터 복제된 다른 3개의 세그먼트를 고려하지 않고서 스택과 힙 세그먼트를 프로세스의 동적 메모리 레이아웃이라고 한다. 하지만 프로세스의 동적 메모리 레이아웃은 5개 세그먼트 모두를 포함해 구성된다는 점을 항상 명심해야 한다.

스택 세그먼트는 변수가 저장되는 기본 메모리 영역이다. 크기가 제한된 영역이며 여기에 큰 객체는 둘 수 없다. 반대로 힙 세그먼트는 더 크고 조정 가능한 메모리 영역이며 큰 객체나 변수를 담을 수 있다. 힙 세그먼트로 작업하려면 앞에서 소개한 고유 API가 필요하다.

동적 메모리 레이아웃은 동적 메모리 할당과는 다르다는 점을 명심하자. 서로 다른 것을 나타내므로 두 개념을 혼동해서는 안된다.

프로세스의 동적 메모리에서 발견되는 5개의 세그먼트는 메인 메모리에 속하는 부분을 참조하는 데 이는 실행 중인 프로세스에 이미 __할당된__ , __전용__ 메모리이다. 문자 그대로 정적이며 변함이 없는 텍스트 세그먼트를 제외한 이들 세그먼트는, 런타임 시에 내용이 항상 변하므로 동적이다. 프로세스가 실행되는 동안 알고리즘에 의해 이들 세그먼트가 계속 수정되기 때문이다.

프로세스의 동적 메모리 레이아웃을 검사하려면 자체적인 절차가 필요하다. 즉, 프로세스의 동적 메모리 레이아웃을 검사하려면 그 전에 프로세스를 실행해야 한다는 의미이다. 그 때문에 동적 메모리를 유지하기 위해 상당히 긴 시간 동안 작동하는 예제를 작성해야 한다. 그래야 동적 메모리 구조를 학습하는 검사 도구를 사용할 수 있다.



### 4.4.1 메모리 매핑

```c
#include <unistd.h> // sleep 함수에 필요한 헤더

int main(int argc, char **argv)
{
    while(1) {
        sleep(1)
    }
    return 0;
}
```

위 예제는 무한히 실행된다. 이렇게 하면 프로세서가 절대 종료되지 않으며, 그동안 우리는 메모리 구조를 검사할 수 있다. 그리고 당연히 검사가 끝날 때마다 프로세스를 종료할 수 있다. 일단 무한 루프로 영원히 실행되니 프로세스의 메모리를 검사할 충분한 시간이 생겼다.



```shell
$ gcc main.c -o exe.out
$
```

예제를 컴파일 한후 다음 명령을 실행한다. 프로세스가 실행되는 동안 추가 명령어를 실행하기 위해 같은 프롬프트를 사용하려면, 프로세스를 백그라운드에서 시작해야한다.

```shell
$ ./exe.out &
[1] 402
$
```

프로세스는 이제 백그라운드에서 실행된다. 출력 결과에 따르면 최근 시작된 프로세스의 PID는 402이고 이 PID를 사용해 나중에 프로세스를 종료할 것이다. PID는 프로그램을 실행할 때마다 다르다. 프로세스를 백그라운드에서 실행할 때마다 셸 프롬프트가 즉시 리턴되어 다음 명령어를 입력할 수 있다.

```shell
프로세스의 PID 가 있다면 kill 명령어를 사용해서 프로세스를 쉽게 종료할 수 있다. PID 가 402라면, 유닉스 계열 운영체제에서는 다음 명령어로 종료할 수 있다.
kill -9 402
```

PID 는 프로세스의 메모리를 검사하기 위해 사용하는 식별자이다. 일반적으로 운영체제는 PID 에 기반해 프로세스의 다양한 속성을 쿼리하는 자체적인 특정 메커니즘을 제공한다. 여기에서는 리눅스 메커니즘을 이용하겠다.

리눅스 머신에서 프로세스에 관한 정보는 /proc 경로에 있는 파일에서 찾을 수 있다. 이 정보는 procfs 라는 특별한 파일 시스템을 사용한다. 이 파일 시스템은 실제로 파일을 저장하는 일반적인 파일 시스템을 사용한다. 이 파일 시스템은 실제로 파일을 저장하는 일반적인 파일 시스템을 의미하지 않는다. 더 계층적인 인터페이스로 개별 프로세스나 시스템 전체의 다양한 속성을 쿼리한다.

프로세스의 메모리는 수많은 메모리 매핑으로 구성된다. 각 메모리 매핑은 프로세스에 속하는 특정 파일이나 세그먼트에 매핑되는 메모리의 전용 영역을 나타낸다. 요약하자면, 스택과 힙 세그먼트 모두 각 프로세스에서 고유한 메모리 매핑을 갖는다는 것을 알 수 있다.

이 프로세스는 PID 402로 실행된다고 알고 있다. ls 명령어로 /proc/402 경로의 내용을 볼 수 있다.

```shell
$ ls -l /proc/402
total of 0
... 생략
```

/proc/402 경로 아래에는 많은 파일과 경로가 존재한다. 이 파일과 경로는 각각 프로세스의 특정 속성에 해당한다. 프로세스의 메모리 매핑을 쿼리하려면 PID 경로 아래에 있는 maps 파일의 내용을 확인해야 한다. cat 명령어로 /proc/402/maps 파일의 내용을 덤프하자.



```shell
$ cat /proc/402/maps
...
/.../		/lib/
...
/.../		[stack]
```

셸 박스에서 결과는 여러 행으로 구성된다. 각 행은 프로세스의 동적 메모리 레이아웃의 특정 파일 및 세그먼트에 할당 및 매핑되는 메모리 주소의 범위를 가리키는 메모리 매핑을 나타낸다. 각 매핑에는 하나 이상의 공백으로 구분된 여러 필드가 있다.

- 주소범위: 매핑된 범위의 시작과 끝 주소이다. 만약 이 영역이 파일에 매핑되어 있다면 주소 앞에서 파일 경로를 볼 수 있다. 여러 프로세스에서 로드한, 같은 공유 목적 파일을 매핑하는 영리한 방식이다.
- 허가: 내용물이 실행 가능한지(x), 읽을 수 있는지 (r), 수정될 수 있는지(w) 를 나타낸다. 이 영역은 또한 다른 프로세서와 공유할 수 있으며 (s) 소유 프로세스 전용 (p) 일 수도 있다.
- 오프셋: 이 영역이 파일과 매핑되면 파일 시작점 부분에서의 오프셋이 된다. 만약 이 영역이 파일과 매핑되어 있지 않다면 일반적으로 0이다.
- 장치: 이 영역이 파일과 매핑된 경우에는 m:n 형태의 장치 수 이다. 이는 매핑된 파일을 포함하는 장치를 가리킨다. 예를 들면 공유 목적 파일을 포함하는 하드 디스크의 장치 수 등이다.
- 아이노드: 해당 영역이 파일과 매핑된 경우, 그 파일은 파일 시스템에 탑재되어 있어야 한다. 그러면 이 필드가 해당 파일 시스템에서 파일의 아이노드 숫자가 된다. 아이노드는 유닉스 계열 운영체제에서 대부분 사용하는 ext4와 같은 파일 시스템 내의 추상적인 개념이다. 각 아이노드는 파일 및 경로를 둘 다 표현할 수 있다. 모든 아이노드는 그 내용에 접근할 때 필요한 숫자를 가진다.
- 경로명 및 설명: 이 영역이 파일과 매핑된 경우, 이 부분은 파일의 경로가 된다. 그렇지 않다면 비어 있거나 이 영역의 목적을 서술할 것이다. 예를 들어 [stack]은 이 영역이 실제로 스택 세그먼트임을 나타낸다.



### 4.4.2 스택 세그먼트

스택은 모든 프로세스의 동적 메모리에서 매우 중요한 부분이다. 그리고 거의 모든 아키텍처에 존재한다. 메모리 매핑에서 [stack]이라고 적힌 부분을 봤을 것이다.

스택과 힙 세그먼트는 둘 다 프로세스가 실행되는 동안 계속 변하는 동적인 내용을 갖는다. 이들 세그먼트의 동적 내용을 보기란 쉬운 일이 아니며, 일반적으로 프로세스가 실행되는 동안 메모리 바이트를 검사하고 읽기 위해 gdb 와 같은 디버거가 필요하다.

앞에서 짚어본 대로 스택 세그먼트는 대체로 크기가 제한되며 큰 객체를 저장하기에 좋은 장소는 아니다. 만약 스택 세그먼트가 가득 찼다면 프로세스는 더 이상 함수 호출을 실행할 수  없다. 함수 호출 메커니즘은 스택 세그먼트의 기능에 매우 의존하기 때문이다.

만약 프로세스의 스택 세그먼트가 가득 찼다면 프로세슨느 운영체제에 의해 종료된다. __스택 오버플로__ 는 스택 세그먼트가 가득 찼을 때 발생하는 유명한 오류이다.



```c
void func()
{
    int a;
}
```

이 함수에서 변수를 선언하는 동안, 변수가 어디에 할당되어야 하는지 컴파일러에 알려준 적이 없다. 따라서 컴파일러는 기본적으로 스택 세그먼트를 사용한다. 스택 세그먼트는 할당이 이루어지는 첫 번째 장소이다.

이름이 뜻하는 대로 이것이 스택이다. 지역 변수를 선언할 경우, 지역 변수는 스택 세그먼트의 가장 윗부분에 할당된다. 만약 선언된 지역 변수의 범위를 떠난다면, 컴파일러는 선언된 지역 변수를 바깥 범위로 꺼내기 위해 가장 앞의 지역 변수를 팝 해야한다.

```
스택은 추상적인 형태이며 선입후출 후입선출 자료구조이다. 구현의 세부사항과 무관하게 모든 엔트리는 스택의 가장 윗부분에 저장되며 다음 엔트리에 몯힌다. 한 엔트리는 그 위의 엔트리가 먼저 제거되지 않으면 꺼낼 수가 없다.
```

건강한 스택 메커니즘을 갖는 것은 프로그램의 작동에 매우 중요하다. 스택의 크기는 제한되므로 그 안에서 작은 변수를 선언하는 편이 제일 좋다. 또한, 무한한 재귀 호출 또는 함수 호출을 지나치게 해서 스택이 너무 많은 스택 프레임으로 가득 차도 안된다.

다른 측면에서 보면, 스택 세그먼트는 여러분의 데이터를 보관하고 알고리즘에서 사용하는 지역 변수를 선언하기 위해 사용하는 장소이다. 그리고 프로그램의 실행자인 운영체제가 프로그램을 성공적으로 실행하는 내부적인 메커니즘에 필요한 데이터를 보관하는 장소이기도 하다.

따라서 스택 세그먼트로 작업할 때는 신중해야 한다. 스택 세그먼트를 잘못 사용하거나 데이터를 오염시키면 실행 프로세스를 방해하거나 심지어 충돌이 발생하기 때문이다. 힙 세그먼트는 오직 개발자만이 관리하는 메모리 세그먼트이다.

정적 메모리 레이아웃을 검사하기 위해 앞서 소개한 도구만을 이용한다면, 외부에서 스택 세그먼트의 내용을 확인하기가 쉽지 않다. 메모리의 스택 부분은 전용 데이터를 포함하며 민감할 수 있다. 또한 스택은 해당 프로세스 전용이므로 다른 프로세스가 이를 읽거나 수정할 수 없다.

따라서 스택 메모리를 알아보려면 프로세스에 무언가를 부착해 해당 프로세스의 눈으로 스택 세그먼트를 확인해야 한다. 이는 디버거 프로그램을 사용해 수행할 수 있다. 디버거는 프로세스에 부착되며 개발자가 대상 프로세스를 제어하고 프로세스의 메모리 내용을 조사할 수 있도록 한다.



### 4.4.3 힙 세그먼트

```c
# include <unistd.h>
# include <stdlib.h>
# include <stdio.h>

int main(int argc, char **argv)
{
    void * ptr = malloc(1024);
    printf("Address: %p\n", ptr);
    fflush(stdout);
    while(1){
        sleep(1);
    }
    return 0;
}
```

앞의 코드에서 malloc 함수를 사용했다. 힙 세그먼트에 추가 메모리를 할당하는 기본 방식이다. 이 함수는 할당되어야하는 바이트의 수를 받아서 제네릭 포인터로 반환한다.

앞의 내용을 다시 떠올려보면, 제네릭 포인터는 메모리 주소를 포함하지만 __역참조__ 될 수 없으며 직접 사용될 수 없다. 사용 전에 특정 포인터 형으로 형변환되어야 한다.

루프에 들어가기 전에 1024바이트를 할당한다. 또한 프로그램은 루프를 시작하기 전 malloc 에서 받은 포인터의 주소를 출력한다.

```shell
$ g++ main.c -o exe.out
$ ./exe.out &
[1] 3451
Address: 0x19790010
$
```

이제 프로세스는 백그라운드에서 실행되며 PID 3451을 갖는다.

```shell
$ cat /proc/3451/maps
...
/.../ [heap]
...
.
.
.
/.../ [stack]
...
```

전과 비교해서 보면 강조 표시된 새로운 매핑을 볼 수 있다. 이는 heap이 라고 되어있다. 이 영역은 malloc 함수를 사용했기에 추가되었다. 이 영역의 크기를 계산한다면 0x21000바이트 또는 132KB에 해당한다. 단 1KB를 할당하기 위해 메모리 영역의 크기는 132KB 가 할당되었다는 의미이다.

이느 주로 malloc 을 나중에 다시 사용할 때 메모리를 추가로 할당하지 않고자 수행된다. 간단히 말하면 힙 세그먼트에서 메모리 할당에 드는 비용은 저렴하지 않은데, 힙 세그먼트가 메모리 및 시간 오버헤드를 갖기 때문이다.

다시 코드로 돌아가보면 ptr 포인터가 가리키는 주소도 흥미롭다. 셸 박스에 보이는 힙의 메모리 매핑은 0x01979000 부터 0x0199a000 까지의 주소로 할당되어 있으며, ptr에 저장된 주소는 0x19790010 이다. 이는 명백히 힙 범위 내에 있으며 16바이트의 오프셋만큼 떨어져 위치한다.

힙 세그먼트는 132KB 보다 훨씬 더 커질 수  잇고, 수십 기가바이트에 달할 수도 있으며, 영구적이고, 전역적인, 배열이나 비트스트림 같은 아주 큰 객체에 사용된다.

앞서 짚어본 대로 힙 세그먼트 내부에서 할당 및 해제는 표준 C가 제공하는 특정함수를 호출하는 프로그램이 필요하다. 스택 세그먼트의 가장 윗부분에는 지역 변수가 있으며 메모리로 직접 상호작용하고 사용할 수 있지만, 힙 메모리는 포인터를 통해서만 접근할 수 있다. 바로 이러한 이우로 모든 C 개발자는 포인터를 알아야하고 사용할 수 잇어야 한다. 힙공간에 접근하기 위해 포인터를 사용하는 예제를 보자.



```c
# include <stdio.h>
# include <stdlib.h>

void fill(char * ptr) {
    ptr[0] = 'H';
    ptr[1] = 'e';
    ptr[2] = 'l';
    ptr[3] = 'l';
  	ptr[4] = 'o';
    ptr[5] = 0;   
}

int main(int argc, char** argv)
{
    void * gptr = malloc(10 * sizeof(char));
    char* ptr = (char*)gptr;
    fill(ptr);
    printf("%s!\n", ptr);
    free(ptr);
    return 0;
}
```

이 프로그램은 malloc 함수를 사용해서 힙 공간에 10바이트를 할당한다. malloc 함수는 할당되어야 하는 바이트의 숫자를 받고, 할당된 메모리 블록의 첫 번째 바이트의 주소를 가리키는 제네릭 포인터를 반환한다.

반환된 포인터를 사용하려면 알맞은 포인터형을 형변환해야 한다. 문자를 저장하기 위해 할당된 메모리를 사용하려 하므로, char 포인터로 형변환하겠다. fill 함수를 호출하기 전에 형변환해야 한다.

지역 포인터 변수인 gptr과 ptr은 스택에 할당되었으니 주의하자. 이들 포인터는 값을 저장할 메모리가 필요하고, 이 메모리는 스택 세그먼트에서 가져온다. 하지만 이 포인터가 가리키는 주소는 힙 세그먼트 내부에 있다. 이것이 힙 세그먼트로 작업할 때의 문제이다. 스택 세그먼트에서 할당받은 지역 포인터를 갖지만, 그 포인터는 실제로 힙 세그먼트에 할당된 지역을 가리킨다.

fill 함수 안에 있는 ptr 포인터도 스택에서 할당되었지만 다른 스코프에 있으며, main 함수에서 선언된 ptr 포인터와는 다르다.

힙 메모리는 프로그램 또는 실제로 개발자가 메모리 할당을 담당한다. 프로그램은 메모리가 더 이상 필요하지 않을 때 해제를 맡기도 한다. 접근 불가능한 힙 메모리를 할당받는 것은 __메모리누수__ 로 간주된다. 접근이 불가능하므로 해당 영역의 주소를 나타내기 위해 사용할 수 있는 포인터가 없다는 의미이다.

메모리 누수가 증가하면 결국 허용된 메모리 공간 전체를 다 써서 프로세스가 종료될 수 있으므로 메모리 누수는 치명적이다. 이러한 이유로 프로그램은 main 함수에서 반환되기 전 free 함수를 호출한다. free 함수를 호출하면 확보했던 힙 메모리 블록을 해제할 것이고, 프로그램은 해당 힙 주소를 더 이상 사용하지 못한다.



## 4.5 마무리

 4장의 목표는 유닉스 계열 운영체제에서 프로세스 메모리 구조의 개요를 제공하는 것이다.

- 실행 프로세스의 동적 메모리 구조뿐만 아니라 실행 가능한 목적 파일의 정적 메모리 구조도 설명했다.
- 새 프로세스가 현재 실행 가능한 목적 파일로부터 스폰될 때 텍스트 세그먼트 또는 코드 세그먼트가 기계 수준의 명령어를 저장하는 수단으로 사용된다는 점을 알아봤다.
- 데이터 세그먼트는 초기화된 전역 변수를 저장하는 데 사용된다고 설명했다.
- size와 objdump 명령어로 목적 파일의 내부를 검사했다. 또한 목적 파일의 내부에서 세그먼트를 찾기 위해 readelf 같은 목적 파일 덤퍼를 사용할 수 있다.
- 프로세스의 동적 메모리 레이아웃을 검사했다. 프로세스의 모든 세그먼트는 정적 메모리 레이아웃에서 동적 메모리로 복제됨을 이해했다. 하지만 동적 메모리 레이아웃에는 새로운 세그먼트가 2가지 존재했다. 스택과 힙 세그먼트이다.
- 스택 세그먼트는 할당에 필요한 기본 메모리 영역이다.
- 지역 변수는 언제나 스택 영역의 맨 위에 할당된다고 설명했다.
- 스택 세그먼트 내의 함수 호출에 대한 비밀과 그 작동 방식을 살펴봤다.
- 힙 메모리 영역을 할당 및 해제하려면 특정 API 또는 함수 집합을 사용해야 한다는 점을 알게 되었다. 이 API는 C 의 표준 라이브러리가 제공된다.
- 메모리 누수를 설명했으며 메모리 누수가 힙 메모리 지역에서 어떻게 발생하는지도 알아봣다.


