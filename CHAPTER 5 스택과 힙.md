# CHAPTER 5 스택과 힙

개발자는 대부분 스택과 힙 세그먼트를 다루기 바쁘다. 데이터 및 BSS 세그먼트는 사용빈도가 낮고, 개발자가 통제할 권한도 적다. 데이터 및 BSS 세그먼트는 컴파일러가 생성하는 데다, 프로세스의 수명동안 프로세스의 전체 메모리에서 차지하는 비율도 낮기 때문이다. 그렇다고 해서 데이터 및 BSS 세그먼트가 중요하지 않다는 의미는 아니다. 이들 세그먼트에 직결되는 이슈도 있다. 하지만 우리는 스택과 힙을 주로 다루기 때문에 메모리 문제의 원인은 대체로 스택과 힙 세그먼트에 있다.

5장에서는 다음 내용을 학습한다.

- 스택 세그먼트를 검사하는 방법과 검사에 필요한 도구
- 스택 세그먼트의 메모리 자동 관리 수행 방법
- 스택 세그먼트의 다양한 특징
- 스택 세그먼트 사용법의 가이드라인과 모범 사례
- 힙 세그먼트를 검사하는 방법
- 힙 메모리 블록을 할당 및 해제하는 방법
- 힙 세그먼트 사용법의 가이드라인과 모범사례
- 메모리가 제한된 환경과 성능이 더 나은 환경에서의 메모리 튜닝



## 5.1 스택

프로세스는 힙 세그먼트 없이 계속 작동할 수 있지만, 스택 세그먼트가 없다면 불가능하다. 스택은 프로세스 수명에서 주요 부분에 해당하며, 스택 없이는 프로세스가 계속 실행할 수 없다. 함수 호출에 관한 메커니즘 때문이다. 스택 세그먼트를 이용해야 함수를 호출할 수 있다. 스택 세그먼트가 없다면 함수는 호출될 수 없으며, 결국 실행도 불가능하다는 의미이다.

그러므로 스택 세그먼트 및 내용물은 프로세스의 정상적인 실행을 위해 세심하게 다뤄야 한다. 그뿐만 아니라 스택의 내용을 건드리면 프로세스의 실행을 방해하고 중단시킬 수 있다. 스택 세그먼트에서 이뤄지는 할당은 빠르며 어떤 특별한 함수 호출도 필요하지 않는다. 또한 메모리 해제 및 모든 메모리 관리도 자동으로 된다.

스택은 조심해서 사용해야 한다. 스택 세그먼트를 사용할 때는 스택 고유의 문제가 발생한다. 스택은 아주 크지는 않으므로 큰 객체를 저장할 수 없다. 그리고 스택의 내용을 잘못 사용하면 실행이 중지되고 충돌이 발생한다.

```c
# include <stdio.h>

int main(int argc, char **argv)
{
    char str[10];
    strcpy(str, "adjfahksjerhjasdkfhkasjhjekwarhkjdfh");
    return 0;
}
```

이 코드를 실행하면 프로그램은 충돌이 발생할 가능성이 크다. strcpy가 스택의 내용을 덮어쓰기 때문이며, 흔히 이를 스택 스매싱이라고 한다. 배열 str 은 10개의 문자열이 있다. 하지만 strcpy는 10개가 넘는 문자를 쓰고 있다. 이는 사실상 이전에 푸시한 변수와 스택 프레임에 덮어 쓰는 것이며, 프로그램은 main 함수에서 반환된 잘못된 명령으로 건너뛴다. 그래서 결국 계속해서 실행할 수 없다.



### 5.1.1 스택 검사하기

스택을 더 알기 전에 스택을 읽고 수저할 수 있어야 한다. 스택 세그먼트는 소유자 프로세스만이 읽고 수정할 권한을 갖는 전용 메모리이다. 스택을 읽거나 변경하려면 스택을 소유하는 프로세스에 속해야 한다.

여기서 새로운 도구인 __디버거__ 가 등장한다. 디버거는 __디버그__ 하려는 다른 프로세스에 붙여서 사용하는 프로그램이다. 보통 디버거가 프로세스를 디버깅하면서 하는 작업 중에는 다양한 메모리 세그먼트를 관찰하고 다루는 일이 있다. 프로세스를 디버깅할 때만 전용 메모리 블록을 읽고 수정할 수 있다. 디버깅 과정에서 할 수 있는 또 다른 작업은 프로그램 명령어의 실행 순서를 제어하는 일이다.

```c
// main.c
# include <stdio.h>

int main(int argc, char** argv)
{
    char arr[4];
    arr[0] = 'A';
    arr[0] = 'B';
    arr[0] = 'C';
    arr[0] = 'D';
    return 0;
}
```

우선 힙에 메모리를 할당하는 malloc 함수를 사용하지 않으므로 배열 arr에 필요한 메모리는 스택에 할당한다. 스택 세그먼트는 변수와 배열이 할당되는 기본 장소라는 점에 유의하자.

힙에 메모리를 할당하려면 malloc 이나 이와 비슷한 calloc 과 같은 함수를 호출해야한다. 그렇지 않으면 메모리는 스택에, 더 정확하게는 스택의 최상단에 할당된다.

프로그램을 디버깅하려면 디버깅 용도의 이진파일이 반드시 빌드되어야 한다. 즉, 컴파일러로 디버그 심벌을 포함하는 이진 파일이 필요하다고 전달해야 한다. 디버그 심벌ㅇ느 실행되는 코드 도는 충돌을 야기하는 코드를 찾아내는 데 사용된다.

```shell
$ gcc -g main.c -o exe_dbg.out
$
```

컴파일러에 -g 옵션을 전달하면 최종 실행 가능한 목적 파일에 디버깅 정보가 삽입된다. 컴파일할 때 소스에 디버그 옵션이 있는지에 따라 이진파일의 크기도 다르다. 그런 다음 실행 가능한 목적 파일 2개의 크기가 다르다는 것을 알 수 있다. 첫 번째 파일은 -g 옵션 없이 빌드된 것이며 두 번째 파일은 -g 옵션으로 빌드한 것이다.

```shell
$ gcc main.c -o exe.out
$ ls -al exe.out
-rwxrwxr -x 1 adsf adsf 8640 jul 24 13:55 exe.out
$ gcc -g main.c -o exe_dbg,out
$ ls -al exe_dbg.out
-rwxrwxr -x 1 adsf adsf 9864 jul 24 13:55 exe_dbg.out
$
```

디버그 심벌을 포함하는 실행 파일이 있으니 이제 프로그램을 실행할 디버거를 사욯할 수 있다.

```shell
$ gdb exe_dbg.out
```

```
gdb 는 보통 리눅스 시스템에서 build-essentials의 일부로 설치된다. macOS 시스템에서는 다음과 brew 패키지 매니저를 사용해 설치할 수 있다.
brew install gdb
```

실행한 뒤 디버거의 결과는 다음과 같다.

```shell
$ gdb exe_dbg.out
GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1
...
Reading symbols from exe_dbg.out...done.
(gdb)

```

이 명령어는 리눅스 머신에서 실행했다. gdb는 디버깅 명령어를 전달하는 커맨드 라인 인터페이스를 갖는다. 디버거에 입력값으로 지정된 실행 가능한 목적 파일을 실행하려면 명령어 r 을 입력하자.

```shell
...
Reading symbols from exe_dbg.out...done.
(gdb) run
Starting program: .../extreme_c/exe_dbg.out
[Inferior 1 (process 9742) eixted normally]
(gdb)
```

run 명령어를 전달한 뒤 앞의 셸 박스에서 gdb 는 프로세스를 시작하고, 프로세스를 추가된 뒤, 프로세스가 명령어를 실행하고 종료하도록 한다. gdb는 프로그램을 방해하지 않았다. __중단점__ 를 설정하지 않았기 때문이다. 중단점은 gdb가 프로그램의 실행을 멈추고 나중의 명령어를 기다리도록 하는 표시이다. 중단점은 원하는 대로 얼마든 쓸 수 있다.

다음으로는 main 함수에 b (또는 break) 명령어를 사용해 중단점을 설정하자. 중단점을 설정하면 gdb는 프로그램이 main 함수에 진입할 때 실행을 중단하다.

```shell
(gdb) break main
Breakpoint 1 at 0x400555: file main.c, line 6.
(gdb)
```

프로그램을 다시 실행하자. 프로그램은 새 프로세스를 만들고 gdb는 새 프로세스에 추가된다.

```shell
(gdb) r
Starting program: .../exe_dbg.out

Breakpoint 1, main (argc=1, argv=0x7ffffffcbd8) at main.c:6
6		int main(int argc, char** argv){
(gdb)
```

이제 디버거에 print arr 명령어를 입력하면 배열 내용이 문자열로 나타난다.

```shell
(gdb) print arr
$1 = "ABCD"
(gdb)
```

주제로 다시 돌아가면 스택 메모리의 내부를 살펴볼 수 있는 gdb를 소개했다. 이제 디버그를 할 수 있다. 스택 세그먼트를 갖는 프로세스가 있고, 프로세스는 정지되었고, 메모리를 탐색할 gdb 커맨드 라인이 있다.

```shell
(gdb) x/4b arr
0x7ffffffffcae0: 0x41	0x42	0x43	0x44
(gdb) x/8b arr
0x7ffffffffcae0: 0x41	0x42	0x43	0x44	0xff	0x7f	0x00	0x00
(gdb)
```

첫 번째 명령어 x/4b는 arr이 가리키는 지역에서 4바이트를 나타냔다. arr는 배열의 첫 번째 원소를 가리키는 포인터라는 점에 주의하자. 그러므로 arr는 메모리를 따라서 움직이도록 사용될 수 있다.

두 번째 명령어 x/8b는 arr 이후의 8바이트를 나타낸다. 예제의 코드에 따라, A, B, C, D 값은 배열 arr에 저장된다. 배열에는 실제 문자열이 아니라 아스키값이 저장된다는 점을 알아야 한다. A의 아스키 값은 10진법으로는 65, 16진수로는 0x41이다. B는 66 또는 0x42이다. 보다시피 gdb에서 프린트된 값은 배열 arr에 저장된 값 그대로이다.

두 번째 명령어의 나머지 4바이트는 뭘까? 이 바이트는 스택에 속한 것으로, main 함수를 호출하는 동안 스택 맨 위에 놓인 최근의  스택 프레임의 데이터를 포함한다. 스택 세그먼트는 다른 세그먼트와 정반대 방식으로 채워진다는 점을 명심하자.

다른 메모리 지역은 작은 주소부터 시작해서 주솟값이 더 커지는 방향으로 채워진다. 하지만 스택 세그먼트는 그렇지 않다. 스택 세그먼트는 큰 주소부터 채워지고 점차 주솟값은 작아진다. 그 원인은 현대 컴퓨터의 발달 역사에도 있고, 스택 세그먼트의 기능이 스택 자료구조와 비슷하게 작동한다는 데도 있다.

여기서 주소가 커지는 방향으로 스택  세그먼트를 읽는다면, 사실상 스택 세그먼트에 이미 푸시된 내용을 읽는 것에 불과하다. 그리고 이 바이트를 변경하려고 한다면 스택을 변경하는 것이고, 좋은 방식이 아니다. 이것이 왜 위험한지 그리고 그 방법은 무엇인지 예를 들어보자.

왜 배열 arr의 크기보다 더 큰 값이 보이는 걸까? gdb는 우리가 요청한 메모리의 바이트 수를 검사하기 때문이다. 명령어 x는 배열의 경계를 신경 쓰지 않는다. 이 명령어로 범위를 출력하려면 단지 시작 주소와 바이트 수만 필요하다.

스택 내부의 값을 변경하려면 명령어 set을 사용해야 한다. 이 명령어는 기존 메모리 셀을 수정할 수 있도록 한다. 이 경우 메모리 셀은 배열 arr에 있는 개별 바이트를 참조한다.

```shell
(gdb) x/4b arr
0x7ffffffffcae0: 0x41	0x42	0x43	0x44
(gdb) set arr[1] = 'F'
(gdb) x/4b arr
0x7ffffffffcae0: 0x41	0x46	0x43	0x44
(gdb) print arr
$2 = "AFCD"
(gdb)
```

set 명령어를 사용해 배열 arr의 두 번째 원소를 F로 두었다. 배열의 경계 바깥에 있는 주소를 변경할 때도 gdb를 이용할 수 있다.

이제 배열 arr 보다 훨씬 더 큰 주소에 위치한 바이트를 수정하려고 한다. 앞서 설명했듯 스택에 이미 푸쉬된 내용을 변경할 것이다.

``` shell
(gdb) x/20x arr
0x7fffffffffffcae0: 0x41	0x42	0x43	0x44	0xff	0x7f	0x00	0x00
0x7fffffffffffcae8: 0x00	0x96	0xea	0x5d	0xf0	0x31	0xea	0x73
0x7fffffffffffcaf0: 0x90	0x05	0x40	0x00
(gdb) set *(0x7ffffffffffcead) = 0xff
(gdb) x/20x arr
0x7fffffffffffcae0: 0x41	0x42	0x43	0x44	0xff	0x7f	0x00	0x00
0x7fffffffffffcae8: 0x00	0x96	0xea	0x5d	0xf0	0x31	0xea	0x73
0x7fffffffffffcaf0: 0x90	0x05	0x40	0x00
```

배열의 경계 바깥에 있는 0x7ffffffffcead 주소에 0xff 값을 썼다. 이 값은 main 함수에 진입하기 전에 푸쉬된 스택 프레임 안에 존재하는 바이트이다.

실행을 계속하다면 어떤 일이 발생할까? 스탹의 중요바이트를 수정했다면 충돌이 일어나거나 어떤 메커니즘에 따라 이 수정이 감지되어 프로그램의 실행이 중단된다. 명령어 c (또는 continue)는 gdb 에서 프로세스를 계속해서 실행할 것이다.

``` shell
(gdb) c
Continuing
*** stack smashing detected ***: .../exe_dbg.out terminated

Program received signal SIGABRT Aborted.
0x00007ffff7a42428 in __GI_raise (sig=sig@entry=6) at ../sysdeps/Unix/sysv/linux/raise.c:54
54	../sysdeps/Unix/sysv/linux/raise.c: No such file or directory.
(gdb)
```

여기서 방금 스택을  스매싱했다. 할당하지 않은 주소에 있는 스택 내용을 수정한다면, 그것이 단 1바이트라고 하더라도 매우 위험할 수  있으며 일반적으로 충돌을 일으키거나 갑자기 종료된다.

앞서 말한 대로 프로그램의 실행에 필수인 절차의 대부분은 스택 메모리에서 수행된다. 그러므로 스택 변수를 작성할 때는 매우 주의를 기울여야 한다. 변수나 배열에 정의된 경계 바깥의 어떠한 값도 쓰지 않아야 한다. 스택 메모리에서 주소는 점점 더 작아지기 때문이다. 그러면 이미 작성된 바이트에 덮어 쓰기 십상이다.

디버그를 마치고 나면 gdb 에서 나갈 준비가 되었으니 간단히 명령어 q ( 또는 quit )을 사용한다.

추가로 참고할 점은 스택의 가장 위에 할당된 __버퍼 buffer__ (바이트 또는 문자열 배열의 다른 이름)에 확인되지 않은 값을 작성하는 일은 취약점으로 간주된다는 것이다. __오버플로__ 공격 때문에 이는 대게 __익스플로잇__이라고 한다.

```c
// 버퍼 오버플로 취약성을 나타내는 프로그램
int main(int argc, char** argv)
{
    char str[10];
    strcpy(str, argv[1]);
    printf("hello %s\n", str);
    return 0;
}
```

앞의 코드는 argv[1] 입력값의 내용과 크기를 검사하지 않고 배열 str에 곧바로 복제한다. 그리고 이 값은 스택의 맨 위에 할당된다.

충돌을 일으키지만 위험한 어떤 경우에는 익스프로잇을 야기할 수 있다.



### 5.1.2 스택 메모리 사용 시 주의점

__스코프__ 라는 개념을 알아보자. 각 스택 변수는 고유의 스코프를 갖고, 이 스코프는 변수의 수명을 결정한다. 이는 스택 변수가 한 스코프 내에서 수명을 시작해서 해당 스코프를 떠나면 죽는다는 것을 의미한다. 즉, 스코프는 스택 변수의 수명을 결정한다.

스택 변수를 메모리에서 자동으로 할당하고 해제할 수는 있지만 오직 스택 변수에만 해당한다. 이러한 자동 메모리 관리는 스택 세그먼트의 고유 특성에서 비롯된다. 스택 변수를 선언할 때마다 이 변수는 스택 세그먼트의 가장 윗부분에 할당된다. 할당은 자동으로 이뤄지며 이는 변수 수명의 시작으로 기록될 수 있다. 이후에 더 많은 다른 변수와 스택 프레임이 스택의 맨 위에 놓인다. 변수가 스택에 존재하고 다른 변수가 그 위에 놓이는 한 그 변수는 계속 살아남는다.

그러나 결국 이 변수는 스택에서 팝아웃된다. 미래의 어느 지점에서 프로그램은 종료될 것이고, 그러면 스택은 그 순간 비워져야 하기 때문이다. 그러므로 변수가 스택에서 팝아웃될 미래의 어느 지점이 존재할 것이다. 따라서 해제 또는 팝아웃은 자동으로 이뤄지고, 이는 변수의 수명의 끝으로 표시될 것이다. 근본적으로는 이러한 이유로 개발자가 제어하지 않는 스택 변수의 메모리 관리가 자동으로 이뤄진다고 할 수 있다.

```c
int main(int argc, char** argv)
{
    int a;
    ...
    return 0;
}
```

이 변수는 main 함수가 반환되기 전까지 스택에 남아있다. 다시 말하면 변수는 변수의 스코드가 유효할 때까지는 존재한다. main 함수는 모든 프로그램이 실행하는 함수이므로, 변수의 수명은 프로그램이 실행되는 내내 선언되는 전역 변수와 거의 같다.

이 변수는 전역 변수 같기는 하지만 정확히 말하자면 아니다. 이 변수는 스택에서 팝아웃되는 때가 있지만, 전역 변수는 main 함수가 종료되고 프로그램이 완료된 때에도 메모리를 갖기 때문이다. main 함수 전후로 실행되는 두 코드가 있으니 주의 깊게 보자. 각각은 프로그램을 시작하고 완료한다. 하나 더 주목할 것은 전역 변수는 데이터나 BSS 같은 다른 세그먼트에 할당되며 이들 세그먼트는 스택 세그먼트처럼 작동하지 않는다는 점이다.

```c
// 스택의 가장 윗부분에서 변수를 선언하기
int* get_integer() {
	int var = 10;
	return &var;
}

int main(int argc, char** argv) {
    int *ptr = get_integer();
    *ptr = 5;
    return 0;
}
```

get_integer 함수는 지역 변수 var 의 주소를 반환하며, var는 get_integer 함수의 스코프에서 선언된 것이다. get_integer 함수는 지역 변수의 주소를 반환한다. 그러고 나서  main 함수는 받은 포인터를 역참조해 주소가 가리키는 메모리 지역에 접근하려고 한다.

```shell
$ gcc main.c -o exe.out
main.c: In function 'get_integer':
main.c:3:11: warning: funcion returns address of local variable [-Wreturn-local-addr]
	return &var;
		   ^~~~~
$
```

셸 박스처럼 경고 메시지를 받는다. 지역 변수의 주소를 반환하는 일은 흔한 실수인만큼, 컴파일러는 이미 이 실수를 알고 있으며 다음과 같은 명확한 경고 메시지를 나타낸다.

- warning : function returns address of a local variable

그리고 다음은 프로그램을 실행하면 발생하는 세그멘테이션 오류이다.

```shell
$ ./exe,out
Segmentation fault (core dumped)
$
```

이는 충돌이라고 해석할 수 있다. 일반적으로 이전에 할당되었으나 현재는 해제된 메모리 영역에 유효하지 않은 접근을 했기 때문이다.

```
어떤 경고는 오류로 다뤄야 한다. 예를 들어, 앞의 경고는 일반적으로 충돌을 일으키는 만큼 오류가 되어야 한다. 모든 경고를 오류로 처리하려면 -Werror 옵션을 gcc 컴파일러에 전달한다. 가령 앞의 경고처럼 하나의 특정한 경고만 오류로 처리하려면 -Werror=return-local-addr 옵션을 전달하면 된다.
```

gdb로 프로그램을 실행하면 충돌에 관한 더 자세한 내용이 나타난다. 하지만 컴파일시 (최종 실행 가능한 목적파일에) 디버그 정보를 삽입하는 -g 옵션을 사용해야 gdb 가 도움이 된다.

gdb 또는 valgrind 같은 다른 디버그 도구를 사용해 프로그램을 디버그하려면 반드시 -g 옵션을 써서 소스 파일을 컴파일해야 한다.



```shell

$ gcc -g main.c -o exe_dbg.out
main.c: In function 'get_integer':
main.c:3:11: warning: funcion returns address of local variable [-Wreturn-local-addr]
	return &var;
		   ^~~~~
$ gdb exe_dbg.out
GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1
...
Reading symbols from exe_dbg.out...done.
(gdb) run
Starting program: .../exe_dbg.out
Program received signal SIGSEGV, Segmentation fault
0x00005555555546c4 in main (argc=1 argv=0x7fffffffdf88)
	at main.c:8
8	 *ptr = 5;
(gdb) quit
$
```











































