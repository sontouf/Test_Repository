# CHAPTER 5 스택과 힙

개발자는 대부분 스택과 힙 세그먼트를 다루기 바쁘다. 데이터 및 BSS 세그먼트는 사용빈도가 낮고, 개발자가 통제할 권한도 적다. 데이터 및 BSS 세그먼트는 컴파일러가 생성하는 데다, 프로세스의 수명동안 프로세스의 전체 메모리에서 차지하는 비율도 낮기 때문이다. 그렇다고 해서 데이터 및 BSS 세그먼트가 중요하지 않다는 의미는 아니다. 이들 세그먼트에 직결되는 이슈도 있다. 하지만 우리는 스택과 힙을 주로 다루기 때문에 메모리 문제의 원인은 대체로 스택과 힙 세그먼트에 있다.

5장에서는 다음 내용을 학습한다.

- 스택 세그먼트를 검사하는 방법과 검사에 필요한 도구
- 스택 세그먼트의 메모리 자동 관리 수행 방법
- 스택 세그먼트의 다양한 특징
- 스택 세그먼트 사용법의 가이드라인과 모범 사례
- 힙 세그먼트를 검사하는 방법
- 힙 메모리 블록을 할당 및 해제하는 방법
- 힙 세그먼트 사용법의 가이드라인과 모범사례
- 메모리가 제한된 환경과 성능이 더 나은 환경에서의 메모리 튜닝



## 5.1 스택

프로세스는 힙 세그먼트 없이 계속 작동할 수 있지만, 스택 세그먼트가 없다면 불가능하다. 스택은 프로세스 수명에서 주요 부분에 해당하며, 스택 없이는 프로세스가 계속 실행할 수 없다. 함수 호출에 관한 메커니즘 때문이다. 스택 세그먼트를 이용해야 함수를 호출할 수 있다. 스택 세그먼트가 없다면 함수는 호출될 수 없으며, 결국 실행도 불가능하다는 의미이다.

그러므로 스택 세그먼트 및 내용물은 프로세스의 정상적인 실행을 위해 세심하게 다뤄야 한다. 그뿐만 아니라 스택의 내용을 건드리면 프로세스의 실행을 방해하고 중단시킬 수 있다. 스택 세그먼트에서 이뤄지는 할당은 빠르며 어떤 특별한 함수 호출도 필요하지 않는다. 또한 메모리 해제 및 모든 메모리 관리도 자동으로 된다.

스택은 조심해서 사용해야 한다. 스택 세그먼트를 사용할 때는 스택 고유의 문제가 발생한다. 스택은 아주 크지는 않으므로 큰 객체를 저장할 수 없다. 그리고 스택의 내용을 잘못 사용하면 실행이 중지되고 충돌이 발생한다.

```c
# include <stdio.h>

int main(int argc, char **argv)
{
    char str[10];
    strcpy(str, "adjfahksjerhjasdkfhkasjhjekwarhkjdfh");
    return 0;
}
```

이 코드를 실행하면 프로그램은 충돌이 발생할 가능성이 크다. strcpy가 스택의 내용을 덮어쓰기 때문이며, 흔히 이를 스택 스매싱이라고 한다. 배열 str 은 10개의 문자열이 있다. 하지만 strcpy는 10개가 넘는 문자를 쓰고 있다. 이는 사실상 이전에 푸시한 변수와 스택 프레임에 덮어 쓰는 것이며, 프로그램은 main 함수에서 반환된 잘못된 명령으로 건너뛴다. 그래서 결국 계속해서 실행할 수 없다.



### 5.1.1 스택 검사하기

스택을 더 알기 전에 스택을 읽고 수저할 수 있어야 한다. 스택 세그먼트는 소유자 프로세스만이 읽고 수정할 권한을 갖는 전용 메모리이다. 스택을 읽거나 변경하려면 스택을 소유하는 프로세스에 속해야 한다.

여기서 새로운 도구인 __디버거__ 가 등장한다. 디버거는 __디버그__ 하려는 다른 프로세스에 붙여서 사용하는 프로그램이다. 보통 디버거가 프로세스를 디버깅하면서 하는 작업 중에는 다양한 메모리 세그먼트를 관찰하고 다루는 일이 있다. 프로세스를 디버깅할 때만 전용 메모리 블록을 읽고 수정할 수 있다. 디버깅 과정에서 할 수 있는 또 다른 작업은 프로그램 명령어의 실행 순서를 제어하는 일이다.

```c
// main.c
# include <stdio.h>

int main(int argc, char** argv)
{
    char arr[4];
    arr[0] = 'A';
    arr[0] = 'B';
    arr[0] = 'C';
    arr[0] = 'D';
    return 0;
}
```

우선 힙에 메모리를 할당하는 malloc 함수를 사용하지 않으므로 배열 arr에 필요한 메모리는 스택에 할당한다. 스택 세그먼트는 변수와 배열이 할당되는 기본 장소라는 점에 유의하자.

힙에 메모리를 할당하려면 malloc 이나 이와 비슷한 calloc 과 같은 함수를 호출해야한다. 그렇지 않으면 메모리는 스택에, 더 정확하게는 스택의 최상단에 할당된다.

프로그램을 디버깅하려면 디버깅 용도의 이진파일이 반드시 빌드되어야 한다. 즉, 컴파일러로 디버그 심벌을 포함하는 이진 파일이 필요하다고 전달해야 한다. 디버그 심벌ㅇ느 실행되는 코드 도는 충돌을 야기하는 코드를 찾아내는 데 사용된다.

```shell
$ gcc -g main.c -o exe_dbg.out
$
```

컴파일러에 -g 옵션을 전달하면 최종 실행 가능한 목적 파일에 디버깅 정보가 삽입된다. 컴파일할 때 소스에 디버그 옵션이 있는지에 따라 이진파일의 크기도 다르다. 그런 다음 실행 가능한 목적 파일 2개의 크기가 다르다는 것을 알 수 있다. 첫 번째 파일은 -g 옵션 없이 빌드된 것이며 두 번째 파일은 -g 옵션으로 빌드한 것이다.

```shell
$ gcc main.c -o exe.out
$ ls -al exe.out
-rwxrwxr -x 1 adsf adsf 8640 jul 24 13:55 exe.out
$ gcc -g main.c -o exe_dbg,out
$ ls -al exe_dbg.out
-rwxrwxr -x 1 adsf adsf 9864 jul 24 13:55 exe_dbg.out
$
```

디버그 심벌을 포함하는 실행 파일이 있으니 이제 프로그램을 실행할 디버거를 사욯할 수 있다.

```shell
$ gdb exe_dbg.out
```

```
gdb 는 보통 리눅스 시스템에서 build-essentials의 일부로 설치된다. macOS 시스템에서는 다음과 brew 패키지 매니저를 사용해 설치할 수 있다.
brew install gdb
```

실행한 뒤 디버거의 결과는 다음과 같다.

```shell
$ gdb exe_dbg.out
GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1
...
Reading symbols from exe_dbg.out...done.
(gdb)

```

이 명령어는 리눅스 머신에서 실행했다. gdb는 디버깅 명령어를 전달하는 커맨드 라인 인터페이스를 갖는다. 디버거에 입력값으로 지정된 실행 가능한 목적 파일을 실행하려면 명령어 r 을 입력하자.

```shell
...
Reading symbols from exe_dbg.out...done.
(gdb) run
Starting program: .../extreme_c/exe_dbg.out
[Inferior 1 (process 9742) eixted normally]
(gdb)
```

run 명령어를 전달한 뒤 앞의 셸 박스에서 gdb 는 프로세스를 시작하고, 프로세스를 추가된 뒤, 프로세스가 명령어를 실행하고 종료하도록 한다. gdb는 프로그램을 방해하지 않았다. __중단점__ 를 설정하지 않았기 때문이다. 중단점은 gdb가 프로그램의 실행을 멈추고 나중의 명령어를 기다리도록 하는 표시이다. 중단점은 원하는 대로 얼마든 쓸 수 있다.

다음으로는 main 함수에 b (또는 break) 명령어를 사용해 중단점을 설정하자. 중단점을 설정하면 gdb는 프로그램이 main 함수에 진입할 때 실행을 중단하다.

```shell
(gdb) break main
Breakpoint 1 at 0x400555: file main.c, line 6.
(gdb)
```

프로그램을 다시 실행하자. 프로그램은 새 프로세스를 만들고 gdb는 새 프로세스에 추가된다.

```shell
(gdb) r
Starting program: .../exe_dbg.out

Breakpoint 1, main (argc=1, argv=0x7ffffffcbd8) at main.c:6
6		int main(int argc, char** argv){
(gdb)
```

이제 디버거에 print arr 명령어를 입력하면 배열 내용이 문자열로 나타난다.

```shell
(gdb) print arr
$1 = "ABCD"
(gdb)
```

주제로 다시 돌아가면 스택 메모리의 내부를 살펴볼 수 있는 gdb를 소개했다. 이제 디버그를 할 수 있다. 스택 세그먼트를 갖는 프로세스가 있고, 프로세스는 정지되었고, 메모리를 탐색할 gdb 커맨드 라인이 있다.

```shell
(gdb) x/4b arr
0x7ffffffffcae0: 0x41	0x42	0x43	0x44
(gdb) x/8b arr
0x7ffffffffcae0: 0x41	0x42	0x43	0x44	0xff	0x7f	0x00	0x00
(gdb)
```

첫 번째 명령어 x/4b는 arr이 가리키는 지역에서 4바이트를 나타냔다. arr는 배열의 첫 번째 원소를 가리키는 포인터라는 점에 주의하자. 그러므로 arr는 메모리를 따라서 움직이도록 사용될 수 있다.

두 번째 명령어 x/8b는 arr 이후의 8바이트를 나타낸다. 예제의 코드에 따라, A, B, C, D 값은 배열 arr에 저장된다. 배열에는 실제 문자열이 아니라 아스키값이 저장된다는 점을 알아야 한다. A의 아스키 값은 10진법으로는 65, 16진수로는 0x41이다. B는 66 또는 0x42이다. 보다시피 gdb에서 프린트된 값은 배열 arr에 저장된 값 그대로이다.

두 번째 명령어의 나머지 4바이트는 뭘까? 이 바이트는 스택에 속한 것으로, main 함수를 호출하는 동안 스택 맨 위에 놓인 최근의  스택 프레임의 데이터를 포함한다. 스택 세그먼트는 다른 세그먼트와 정반대 방식으로 채워진다는 점을 명심하자.

다른 메모리 지역은 작은 주소부터 시작해서 주솟값이 더 커지는 방향으로 채워진다. 하지만 스택 세그먼트는 그렇지 않다. 스택 세그먼트는 큰 주소부터 채워지고 점차 주솟값은 작아진다. 그 원인은 현대 컴퓨터의 발달 역사에도 있고, 스택 세그먼트의 기능이 스택 자료구조와 비슷하게 작동한다는 데도 있다.

여기서 주소가 커지는 방향으로 스택  세그먼트를 읽는다면, 사실상 스택 세그먼트에 이미 푸시된 내용을 읽는 것에 불과하다. 그리고 이 바이트를 변경하려고 한다면 스택을 변경하는 것이고, 좋은 방식이 아니다. 이것이 왜 위험한지 그리고 그 방법은 무엇인지 예를 들어보자.

왜 배열 arr의 크기보다 더 큰 값이 보이는 걸까? gdb는 우리가 요청한 메모리의 바이트 수를 검사하기 때문이다. 명령어 x는 배열의 경계를 신경 쓰지 않는다. 이 명령어로 범위를 출력하려면 단지 시작 주소와 바이트 수만 필요하다.

스택 내부의 값을 변경하려면 명령어 set을 사용해야 한다. 이 명령어는 기존 메모리 셀을 수정할 수 있도록 한다. 이 경우 메모리 셀은 배열 arr에 있는 개별 바이트를 참조한다.

```shell
(gdb) x/4b arr
0x7ffffffffcae0: 0x41	0x42	0x43	0x44
(gdb) set arr[1] = 'F'
(gdb) x/4b arr
0x7ffffffffcae0: 0x41	0x46	0x43	0x44
(gdb) print arr
$2 = "AFCD"
(gdb)
```

set 명령어를 사용해 배열 arr의 두 번째 원소를 F로 두었다. 배열의 경계 바깥에 있는 주소를 변경할 때도 gdb를 이용할 수 있다.

이제 배열 arr 보다 훨씬 더 큰 주소에 위치한 바이트를 수정하려고 한다. 앞서 설명했듯 스택에 이미 푸쉬된 내용을 변경할 것이다.

``` shell
(gdb) x/20x arr
0x7fffffffffffcae0: 0x41	0x42	0x43	0x44	0xff	0x7f	0x00	0x00
0x7fffffffffffcae8: 0x00	0x96	0xea	0x5d	0xf0	0x31	0xea	0x73
0x7fffffffffffcaf0: 0x90	0x05	0x40	0x00
(gdb) set *(0x7ffffffffffcead) = 0xff
(gdb) x/20x arr
0x7fffffffffffcae0: 0x41	0x42	0x43	0x44	0xff	0x7f	0x00	0x00
0x7fffffffffffcae8: 0x00	0x96	0xea	0x5d	0xf0	0x31	0xea	0x73
0x7fffffffffffcaf0: 0x90	0x05	0x40	0x00
```

배열의 경계 바깥에 있는 0x7ffffffffcead 주소에 0xff 값을 썼다. 이 값은 main 함수에 진입하기 전에 푸쉬된 스택 프레임 안에 존재하는 바이트이다.

실행을 계속하다면 어떤 일이 발생할까? 스탹의 중요바이트를 수정했다면 충돌이 일어나거나 어떤 메커니즘에 따라 이 수정이 감지되어 프로그램의 실행이 중단된다. 명령어 c (또는 continue)는 gdb 에서 프로세스를 계속해서 실행할 것이다.

``` shell
(gdb) c
Continuing
*** stack smashing detected ***: .../exe_dbg.out terminated

Program received signal SIGABRT Aborted.
0x00007ffff7a42428 in __GI_raise (sig=sig@entry=6) at ../sysdeps/Unix/sysv/linux/raise.c:54
54	../sysdeps/Unix/sysv/linux/raise.c: No such file or directory.
(gdb)
```

여기서 방금 스택을  스매싱했다. 할당하지 않은 주소에 있는 스택 내용을 수정한다면, 그것이 단 1바이트라고 하더라도 매우 위험할 수  있으며 일반적으로 충돌을 일으키거나 갑자기 종료된다.

앞서 말한 대로 프로그램의 실행에 필수인 절차의 대부분은 스택 메모리에서 수행된다. 그러므로 스택 변수를 작성할 때는 매우 주의를 기울여야 한다. 변수나 배열에 정의된 경계 바깥의 어떠한 값도 쓰지 않아야 한다. 스택 메모리에서 주소는 점점 더 작아지기 때문이다. 그러면 이미 작성된 바이트에 덮어 쓰기 십상이다.

디버그를 마치고 나면 gdb 에서 나갈 준비가 되었으니 간단히 명령어 q ( 또는 quit )을 사용한다.

추가로 참고할 점은 스택의 가장 위에 할당된 __버퍼 buffer__ (바이트 또는 문자열 배열의 다른 이름)에 확인되지 않은 값을 작성하는 일은 취약점으로 간주된다는 것이다. __오버플로__ 공격 때문에 이는 대게 __익스플로잇__이라고 한다.

```c
// 버퍼 오버플로 취약성을 나타내는 프로그램
int main(int argc, char** argv)
{
    char str[10];
    strcpy(str, argv[1]);
    printf("hello %s\n", str);
    return 0;
}
```

앞의 코드는 argv[1] 입력값의 내용과 크기를 검사하지 않고 배열 str에 곧바로 복제한다. 그리고 이 값은 스택의 맨 위에 할당된다.

충돌을 일으키지만 위험한 어떤 경우에는 익스프로잇을 야기할 수 있다.



### 5.1.2 스택 메모리 사용 시 주의점

__스코프__ 라는 개념을 알아보자. 각 스택 변수는 고유의 스코프를 갖고, 이 스코프는 변수의 수명을 결정한다. 이는 스택 변수가 한 스코프 내에서 수명을 시작해서 해당 스코프를 떠나면 죽는다는 것을 의미한다. 즉, 스코프는 스택 변수의 수명을 결정한다.

스택 변수를 메모리에서 자동으로 할당하고 해제할 수는 있지만 오직 스택 변수에만 해당한다. 이러한 자동 메모리 관리는 스택 세그먼트의 고유 특성에서 비롯된다. 스택 변수를 선언할 때마다 이 변수는 스택 세그먼트의 가장 윗부분에 할당된다. 할당은 자동으로 이뤄지며 이는 변수 수명의 시작으로 기록될 수 있다. 이후에 더 많은 다른 변수와 스택 프레임이 스택의 맨 위에 놓인다. 변수가 스택에 존재하고 다른 변수가 그 위에 놓이는 한 그 변수는 계속 살아남는다.

그러나 결국 이 변수는 스택에서 팝아웃된다. 미래의 어느 지점에서 프로그램은 종료될 것이고, 그러면 스택은 그 순간 비워져야 하기 때문이다. 그러므로 변수가 스택에서 팝아웃될 미래의 어느 지점이 존재할 것이다. 따라서 해제 또는 팝아웃은 자동으로 이뤄지고, 이는 변수의 수명의 끝으로 표시될 것이다. 근본적으로는 이러한 이유로 개발자가 제어하지 않는 스택 변수의 메모리 관리가 자동으로 이뤄진다고 할 수 있다.

```c
int main(int argc, char** argv)
{
    int a;
    ...
    return 0;
}
```

이 변수는 main 함수가 반환되기 전까지 스택에 남아있다. 다시 말하면 변수는 변수의 스코드가 유효할 때까지는 존재한다. main 함수는 모든 프로그램이 실행하는 함수이므로, 변수의 수명은 프로그램이 실행되는 내내 선언되는 전역 변수와 거의 같다.

이 변수는 전역 변수 같기는 하지만 정확히 말하자면 아니다. 이 변수는 스택에서 팝아웃되는 때가 있지만, 전역 변수는 main 함수가 종료되고 프로그램이 완료된 때에도 메모리를 갖기 때문이다. main 함수 전후로 실행되는 두 코드가 있으니 주의 깊게 보자. 각각은 프로그램을 시작하고 완료한다. 하나 더 주목할 것은 전역 변수는 데이터나 BSS 같은 다른 세그먼트에 할당되며 이들 세그먼트는 스택 세그먼트처럼 작동하지 않는다는 점이다.

```c
// 스택의 가장 윗부분에서 변수를 선언하기
int* get_integer() {
	int var = 10;
	return &var;
}

int main(int argc, char** argv) {
    int *ptr = get_integer();
    *ptr = 5;
    return 0;
}
```

get_integer 함수는 지역 변수 var 의 주소를 반환하며, var는 get_integer 함수의 스코프에서 선언된 것이다. get_integer 함수는 지역 변수의 주소를 반환한다. 그러고 나서  main 함수는 받은 포인터를 역참조해 주소가 가리키는 메모리 지역에 접근하려고 한다.

```shell
$ gcc main.c -o exe.out
main.c: In function 'get_integer':
main.c:3:11: warning: funcion returns address of local variable [-Wreturn-local-addr]
	return &var;
		   ^~~~~
$
```

셸 박스처럼 경고 메시지를 받는다. 지역 변수의 주소를 반환하는 일은 흔한 실수인만큼, 컴파일러는 이미 이 실수를 알고 있으며 다음과 같은 명확한 경고 메시지를 나타낸다.

- warning : function returns address of a local variable

그리고 다음은 프로그램을 실행하면 발생하는 세그멘테이션 오류이다.

```shell
$ ./exe,out
Segmentation fault (core dumped)
$
```

이는 충돌이라고 해석할 수 있다. 일반적으로 이전에 할당되었으나 현재는 해제된 메모리 영역에 유효하지 않은 접근을 했기 때문이다.

```
어떤 경고는 오류로 다뤄야 한다. 예를 들어, 앞의 경고는 일반적으로 충돌을 일으키는 만큼 오류가 되어야 한다. 모든 경고를 오류로 처리하려면 -Werror 옵션을 gcc 컴파일러에 전달한다. 가령 앞의 경고처럼 하나의 특정한 경고만 오류로 처리하려면 -Werror=return-local-addr 옵션을 전달하면 된다.
```

gdb로 프로그램을 실행하면 충돌에 관한 더 자세한 내용이 나타난다. 하지만 컴파일시 (최종 실행 가능한 목적파일에) 디버그 정보를 삽입하는 -g 옵션을 사용해야 gdb 가 도움이 된다.

gdb 또는 valgrind 같은 다른 디버그 도구를 사용해 프로그램을 디버그하려면 반드시 -g 옵션을 써서 소스 파일을 컴파일해야 한다.



```shell
$ gcc -g main.c -o exe_dbg.out
main.c: In function 'get_integer':
main.c:3:11: warning: funcion returns address of local variable [-Wreturn-local-addr]
	return &var;
		   ^~~~~
$ gdb exe_dbg.out
GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1
...
Reading symbols from exe_dbg.out...done.
(gdb) run
Starting program: .../exe_dbg.out
Program received signal SIGSEGV, Segmentation fault
0x00005555555546c4 in main (argc=1 argv=0x7fffffffdf88)
	at main.c:8
8	 *ptr = 5;
(gdb) quit
$
```

gdb의 출력 내용에 명확하게 나타나듯, 충돌의 원인은 main 함수 내의 8번 행에 있다. 이 지점은 프로그램이 반환된 포인터를 역참조해서 반환된 주소를 작성하려는 곳이다. 하지만 변수 var 는 get_integer 함수의 지역 변수이며, 이 변수는 더 이상 존재하지 않는다. 8번 행에서 get_integer 함수 및 해당 스코프에서 이미 반환되었으므로 사라졌다. 따라서 반환된 포인터는 __허상 포인터__ 이다.

현재 스코프에 있는 변수의 주소를 가리키는 포인터를 다른 함수로 전달하는 것이 일반적이며, 반대로는 전달하지 않는다. 현재 스코프가 유효한 이상, 변수는 현재의 스코프에 있기 때문이다. 함수를 추가로 호출하면 스택 세그먼트의 위에 무언가를 더 놓을 뿐, 현재 스코프는 새로 놓인 것보다 먼저 종료되지 않는다.

- 스택 메모리는 크기가 제한적이다. 그러므로 큰 객체를 저장하기에 좋은 장소가 아니다.
- 스택 세그먼트의 주소는 작아진다. 그러므로 스택 메모리를 오름차순으로 읽으면 이미 푸쉬된 바이트를 읽는 것과 같다.
- 스택은 자동으로 메모리가 관리된다. 할당 및 해제 모두 해당한다.
- 모든 스택 변수는 스코프를 가지며 스코프는 변수의 수명을 결정한다.
- 포인터는 계속 스코프 내에 존재하는 스택 변수만을 가리켜야한다.
- 스택 변수의 메모리 해제는 자동으로 수행된다. 스코프가 종료되어 더 이상 개발자가 통제할 수 없을 때 자동으로 해재된다.
- 현재 스코프에 존재하는 변수에 대한 포인터는 다른 함수에 인자로 전달될 수 있다. 단, 호출된 함수에 있는 코드가 포인터를 사용하려고 할 때 현재 스코프가 여전히 그 장소에 있다고 확인한 경우에만 가능하다. 이 조건은 동시성 로직이 있는 상황에서는 깨진다.



## 5.2 힙

어떤 프로그래밍 언어로 작성했든 간에 대부분의 코드에서 어떤 방식으로든 힙 메모리를 사용한다. 힙은 스택을 사용해서는 얻을 수 없는  고유의 장점이 있다.

반면 힙은 단점도 있다. 예를 들면 스택 메모리의 비슷한 영역보다 힙 메모리 영역에 할당하는 것이 더 느리다.

__1. 힙은 자동으로 할당되는 메모리 블록을 갖지 않는다. __  대신 개발자가 malloc 또는 그와 유사한 함수를 사용해서 힙 메모리 블록을 하나씩 얻어야 한다. 자동할당이 되지 않는다는 힙의 이러한 약점은 스택 메모리에서는 해결된다. 스택 메모리는 스택 프레임을 포함하고, 스택 프레임은 개발자가 할당하거나 푸쉬하지 않으며, 함수를 호출한 결과로 자동으로 할당 및 푸시된다.

__2. 힙은 메모리 크기가 크다. __ 스택의 크기는 제한되므로 큰 객체를 저장하려면 좋은 선택지가 아닌 반면, 힙은 수십 기가바이트에 달하는 매우 큰 객체를 저장할 수 있다. 힙 크기가 커질수록 할당자는 운영체제에서 힙 페이지를 더 많이 요청해야 한다. 그리고 힙 메모리 블록은 이 페이지를 따라 더 전파된다. 스택 세그먼트와 달리, 힙 메모리에서 할당되는 주솟값은 점차 더 커진다.

__3. 힙 메모리 내에서 메모리의 할당과 해제는 개발자가 관리한다. __ 이는 개발자가 메모리를 할당하고 또한 더 이상 메모리가 필요 없을 때 해제하는 일을 맡은 유일한 개체라는 의미이다. 많은 현대의 프로그래밍 언어에서 할당된 힙 블록을 비우는 일은 __가비지 컬렉터 __ 라는 병행 컴포넌트가 자동으로 수행한다. 하지만 C 와 C++에서는 이런 개념이 없으며, 힙 블록은 수동으로 비워야 한다. 이는 위험요소이며 C/C++ 개발자는 힙 메모리를 다룰 때 매우 조심해야 한다. 할당된 힙 블록을 비우는 데에 실패하면 대개 __메모리 누수__ 가 발생하고, 대부분의 경우 치명적일 수 있다.

4. 스택의 변수와는 달리 __힙에 할당된 변수는 스코프를 전혀 갖지 않는다. __
5. 이는 메모리 관리를 더 어렵게 만드는 위험 요인이다. 변수를 언제 해제해야 할지도 모르며 효율적으로 메모리를 관리하려면 메모리 블록의 스코프와 소유자를 위한 새로운 정의를 생각해야 한다.

__6. 힙 메모리 블록의 주소를 지정하려면 포인터만 사용할 수 있다. __ 즉, 힙 변수와 같은 개념은 존재하지 않는다. 힙 지역은 포인터를 통해 주소가 지정된다.

__7. 힙 세그먼트는 소유자 프로세스의 전용이므로 검사하려면 디버거를 사용해야 한다. __ 다행히 C 포인터는 힙 메모리 블록에서 스택 메모리 블록과 정확히 동일한 방식으로 작동한다. C 는 이러한 추상화를 매우 잘 수행하며 덕분에 같은 포인터를 사용해 힙과 스택 메모리의 주소를 지정할 수 있다.



### 5.2.1 힙 메모리의 할당과 해제

힙 메모리는 수동으로 얻고 비워야 한다. 이는 힙의 메모리 블록을 할당하거나 비우기 위해 개발자가 일련의 함수나 API  를 사용해야 한다는 뜻이다.

이러한 함수는 헤더파일인 stdlib.h 에 정의된다. 힙 메모리 블록을 얻는데 사용되는 함수는 malloc, calloc, realloc 이다. 그리고 힙 메모리 블록을 해제하는 데 사용되는 유일한 함수는 free 이다.

힙 할당 함수와 관련해 이름에서 알 수 있듯 calloc 은 __청소 및 할당 clear and allocate __ 을, 그리고 malloc 은 __메모리 할당 memory allocate __ 을 의미한다. 따라서 calloc은 할당 이후 메모리 블록을 청소하지만 malloc 은 프로그램이 필요에 따라 스스로 해제할 때까지 메모리 블록을 초기화되지 않은 상태로 남겨둔다.

```
C++에서 new와 delete 키워드는 각각 malloc 과 free 와 같은 역할을 한다. 추가로 새로운 연산자가 피연산자의 자료형에 할당된 메모리의 크기를 나타내며, 이 연산자는 반환된 포인터를 자동으로 피연산자의 자료형으로 변환한다.
```

malloc 이 할당한 메모리 블록은 0이 아닌 값을 갖지만 calloc 이 할당한 메모리 블록은 모두 0임을 알 수 있다. 크로스 플랫폼 프로그램을 작성하려면 언제나 C언어의 명세를 따라야 한다. 명세에 따르면 malloc 은 할당된 메모리 블록을 초기화하지 않는다.

다른 운영체제가 아니라 오직 리눅스를 위한 프로그램을 작성할 때도 나중에 컴파일러가 다르게 작동할 수 있다는 점을 알고 잇어야 한다. 그러므로 C 언어의 명세에 따라서 malloc 이 할당한 메몸리 블록은 초기화되지 않으며, 필요하다면 수동으로 초기화해야 한다는 것을 꼭 이해해야 한다.

malloc 이 할당된 메모리를 초기화하지 않으므로 calloc 보다 빠르다는 점을 알아두자 구현에 따라 malloc은 메모리 블록에 접근할 때까지 실제로 메모리 블록을 할당하지 않으며 할당을 지연한다. 이러한 방식으로 메모리 할당이 더 빠르게 일어난다.

malloc 이후에 메모리를 초기화하려면 memset 함수를 사용할 수 있다.

```c
# include <stdlib.h>
# include <string.h>

int main(int argc, char** argv)
{
    cahr * ptr = (char *)malloc(16 * sizeof(char));
    memset(ptr, 0, 16 * sizeof(char));
    memset(ptr, 0xff, 16 * sizeof(char));
    ...
    free(ptr);
    return 0;
}
```

relloc 함수는 힙 할당 함수에 속한다고 소개했던 도 다른 함수이다. 이 함수는 이미 할당된 메모리 블록의 크기를 조정해 메모리를 재할당한다.

```c
int main(int argc, char** argv)
{
    char * ptr = (char*)malloc(16 * sizeof(char));
    ...
    ptr = (char *)malloc(32 * sizeof(char));
    ...
    free(ptr);
    return 0;
}
```

realloc 함수는 이전의 블록에 있는 데이터를 변경하지 않으며 이미 할당된 블록을 새로운 블록으로 확장한다. __단편화__ 때문에 현재 할당된 블록을 확장할 수 없을 때는 다른 충분히 큰 블록을 찾은 뒤 이전 블록에서 새 블록으로 데이터를 복제한다. 이때도 이전의 블록을 해제한다. 보다시피 재할당은 많은 단계를 수반하므로 때에 따라서는 쉬운 방식이 아니다. 따라서 신중하게 사용해야 한다.

free 함수는 포인터를 넘겨서 이미 할당된 힙 메모리 블록의 주소를 전달해 이 메모리 블록을 해제한다. 앞서 말한 대로 할당된 모든 힙블록은 더 이상 필요하지 않을 때 해제되어야 한다. 해제에 실패하면 __메모리 누수__ 가 발생한다.

```c
# include <stdlib.h>

int main(int argc, char** argv)
{
    char* ptr = (char*)malloc(16 * sizeof(char));
    return 0;
}
```

이 프로그램은 끝날 때 힙 메모리에 할당되고 나서 해제되지 않은 16바이트를 가지므로 메모리 누수가 존재한다. 소스코드가 더 커지고 더 많은 요소가 포함된다면 사람의 눈으로 메모리 누수를 감지하기 어렵거나 심지어 불가능할 수도 있다.

메모리 프로파일러는 실행 중인 프로세스에서 메모리 문제를 감지할 수 있는 유용한 프로그램이다. valgrind는 이중 가장 유명한 도구이다.

valgrind를 사용하려면 우선 디버그 옵션 -g를 이용해 예제를 빌드해야 한다 그다음 valgrind 로 실행해야 한다. 주어진 실행 가능한 목적 파일을 실행하는 동안 valgrind 는 모든 메모리 할당 및 해제를 기록한다. 마지막으로 실행이 종료되거나 충돌이 발생했을 때, valgrind는 할당 및 해제에 대한 요약과 해제되지 않은 메모리양을 출력한다. 이 방식으로 valgrind 는 주어진 프로그램에서 실행할 때 얼마나 메모리 누수가 발생하는 지 알 수 있도록 한다.







