# CHAPTER 5 스택과 힙

개발자는 대부분 스택과 힙 세그먼트를 다루기 바쁘다. 데이터 및 BSS 세그먼트는 사용빈도가 낮고, 개발자가 통제할 권한도 적다. 데이터 및 BSS 세그먼트는 컴파일러가 생성하는 데다, 프로세스의 수명동안 프로세스의 전체 메모리에서 차지하는 비율도 낮기 때문이다. 그렇다고 해서 데이터 및 BSS 세그먼트가 중요하지 않다는 의미는 아니다. 이들 세그먼트에 직결되는 이슈도 있다. 하지만 우리는 스택과 힙을 주로 다루기 때문에 메모리 문제의 원인은 대체로 스택과 힙 세그먼트에 있다.

5장에서는 다음 내용을 학습한다.

- 스택 세그먼트를 검사하는 방법과 검사에 필요한 도구
- 스택 세그먼트의 메모리 자동 관리 수행 방법
- 스택 세그먼트의 다양한 특징
- 스택 세그먼트 사용법의 가이드라인과 모범 사례
- 힙 세그먼트를 검사하는 방법
- 힙 메모리 블록을 할당 및 해제하는 방법
- 힙 세그먼트 사용법의 가이드라인과 모범사례
- 메모리가 제한된 환경과 성능이 더 나은 환경에서의 메모리 튜닝



## 5.1 스택

프로세스는 힙 세그먼트 없이 계속 작동할 수 있지만, 스택 세그먼트가 없다면 불가능하다. 스택은 프로세스 수명에서 주요 부분에 해당하며, 스택 없이는 프로세스가 계속 실행할 수 없다. 함수 호출에 관한 메커니즘 때문이다. 스택 세그먼트를 이용해야 함수를 호출할 수 있다. 스택 세그먼트가 없다면 함수는 호출될 수 없으며, 결국 실행도 불가능하다는 의미이다.

그러므로 스택 세그먼트 및 내용물은 프로세스의 정상적인 실행을 위해 세심하게 다뤄야 한다. 그뿐만 아니라 스택의 내용을 건드리면 프로세스의 실행을 방해하고 중단시킬 수 있다. 스택 세그먼트에서 이뤄지는 할당은 빠르며 어떤 특별한 함수 호출도 필요하지 않는다. 또한 메모리 해제 및 모든 메모리 관리도 자동으로 된다.

스택은 조심해서 사용해야 한다. 스택 세그먼트를 사용할 때는 스택 고유의 문제가 발생한다. 스택은 아주 크지는 않으므로 큰 객체를 저장할 수 없다. 그리고 스택의 내용을 잘못 사용하면 실행이 중지되고 충돌이 발생한다.

```c
# include <stdio.h>

int main(int argc, char **argv)
{
    char str[10];
    strcpy(str, "adjfahksjerhjasdkfhkasjhjekwarhkjdfh");
    return 0;
}
```

이 코드를 실행하면 프로그램은 충돌이 발생할 가능성이 크다. strcpy가 스택의 내용을 덮어쓰기 때문이며, 흔히 이를 스택 스매싱이라고 한다. 배열 str 은 10개의 문자열이 있다. 하지만 strcpy는 10개가 넘는 문자를 쓰고 있다. 이는 사실상 이전에 푸시한 변수와 스택 프레임에 덮어 쓰는 것이며, 프로그램은 main 함수에서 반환된 잘못된 명령으로 건너뛴다. 그래서 결국 계속해서 실행할 수 없다.



### 5.1.1 스택 검사하기

스택을 더 알기 전에 스택을 읽고 수저할 수 있어야 한다. 스택 세그먼트는 소유자 프로세스만이 읽고 수정할 권한을 갖는 전용 메모리이다. 스택을 읽거나 변경하려면 스택을 소유하는 프로세스에 속해야 한다.

여기서 새로운 도구인 __디버거__ 가 등장한다. 디버거는 __디버그__ 하려는 다른 프로세스에 붙여서 사용하는 프로그램이다. 보통 디버거가 프로세스를 디버깅하면서 하는 작업 중에는 다양한 메모리 세그먼트를 관찰하고 다루는 일이 있다. 프로세스를 디버깅할 때만 전용 메모리 블록을 읽고 수정할 수 있다. 디버깅 과정에서 할 수 있는 또 다른 작업은 프로그램 명령어의 실행 순서를 제어하는 일이다.

```c
// main.c
# include <stdio.h>

int main(int argc, char** argv)
{
    char arr[4];
    arr[0] = 'A';
    arr[0] = 'B';
    arr[0] = 'C';
    arr[0] = 'D';
    return 0;
}
```

우선 힙에 메모리를 할당하는 malloc 함수를 사용하지 않으므로 배열 arr에 필요한 메모리는 스택에 할당한다. 스택 세그먼트는 변수와 배열이 할당되는 기본 장소라는 점에 유의하자.

힙에 메모리를 할당하려면 malloc 이나 이와 비슷한 calloc 과 같은 함수를 호출해야한다. 그렇지 않으면 메모리는 스택에, 더 정확하게는 스택의 최상단에 할당된다.

프로그램을 디버깅하려면 디버깅 용도의 이진파일이 반드시 빌드되어야 한다. 즉, 컴파일러로 디버그 심벌을 포함하는 이진 파일이 필요하다고 전달해야 한다. 디버그 심벌ㅇ느 실행되는 코드 도는 충돌을 야기하는 코드를 찾아내는 데 사용된다.

```shell
$ gcc -g main.c -o exe_dbg.out
$
```

컴파일러에 -g 옵션을 전달하면 최종 실행 가능한 목적 파일에 디버깅 정보가 삽입된다. 컴파일할 때 소스에 디버그 옵션이 있는지에 따라 이진파일의 크기도 다르다. 그런 다음 실행 가능한 목적 파일 2개의 크기가 다르다는 것을 알 수 있다. 첫 번째 파일은 -g 옵션 없이 빌드된 것이며 두 번째 파일은 -g 옵션으로 빌드한 것이다.

```shell
$ gcc main.c -o exe.out
$ ls -al exe.out
-rwxrwxr -x 1 adsf adsf 8640 jul 24 13:55 exe.out
$ gcc -g main.c -o exe_dbg,out
$ ls -al exe_dbg.out
-rwxrwxr -x 1 adsf adsf 9864 jul 24 13:55 exe_dbg.out
$
```

디버그 심벌을 포함하는 실행 파일이 있으니 이제 프로그램을 실행할 디버거를 사욯할 수 있다.

```shell
$ gdb exe_dbg.out
```

```
gdb 는 보통 리눅스 시스템에서 build-essentials의 일부로 설치된다. macOS 시스템에서는 다음과 brew 패키지 매니저를 사용해 설치할 수 있다.
brew install gdb
```

실행한 뒤 디버거의 결과는 다음과 같다.

```shell
$ gdb exe_dbg.out
GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1
...
Reading symbols from exe_dbg.out...done.
(gdb)

```

이 명령어는 리눅스 머신에서 실행했다. gdb는 디버깅 명령어를 전달하는 커맨드 라인 인터페이스를 갖는다. 디버거에 입력값으로 지정된 실행 가능한 목적 파일을 실행하려면 명령어 r 을 입력하자.

```shell
...
Reading symbols from exe_dbg.out...done.
(gdb) run
Starting program: .../extreme_c/exe_dbg.out
[Inferior 1 (process 9742) eixted normally]
(gdb)
```

run 명령어를 전달한 뒤 앞의 셸 박스에서 gdb 는 프로세스를 시작하고, 프로세스를 추가된 뒤, 프로세스가 명령어를 실행하고 종료하도록 한다. gdb는 프로그램을 방해하지 않았다. __중단점__ 를 설정하지 않았기 때문이다. 중단점은 gdb가 프로그램의 실행을 멈추고 나중의 명령어를 기다리도록 하는 표시이다. 중단점은 원하는 대로 얼마든 쓸 수 있다.

다음으로는 main 함수에 b (또는 break) 명령어를 사용해 중단점을 설정하자. 중단점을 설정하면 gdb는 프로그램이 main 함수에 진입할 때 실행을 중단하다.

```shell
(gdb) break main
Breakpoint 1 at 0x400555: file main.c, line 6.
(gdb)
```

프로그램을 다시 실행하자. 프로그램은 새 프로세스를 만들고 gdb는 새 프로세스에 추가된다.

```shell
(gdb) r
Starting program: .../exe_dbg.out

Breakpoint 1, main (argc=1, argv=0x7ffffffcbd8) at main.c:6
6		int main(int argc, char** argv){
(gdb)
```

이제 디버거에 print arr 명령어를 입력하면 배열 내용이 문자열로 나타난다.

```shell
(gdb) print arr
$1 = "ABCD"
(gdb)
```

주제로 다시 돌아가면 스택 메모리의 내부를 살펴볼 수 있는 gdb를 소개했다. 이제 디버그를 할 수 있다. 스택 세그먼트를 갖는 프로세스가 있고, 프로세스는 정지되었고, 메모리를 탐색할 gdb 커맨드 라인이 있다.

```shell
(gdb) x/4b arr
0x7ffffffffcae0: 0x41	0x42	0x43	0x44
(gdb) x/8b arr
0x7ffffffffcae0: 0x41	0x42	0x43	0x44	0xff	0x7f	0x00	0x00
(gdb)
```

첫 번째 명령어 x/4b는 arr이 가리키는 지역에서 4바이트를 나타냔다. arr는 배열의 첫 번째 원소를 가리키는 포인터라는 점에 주의하자. 그러므로 arr는 메모리를 따라서 움직이도록 사용될 수 있다.

두 번째 명령어 x/8b는 arr 이후의 8바이트를 나타낸다. 예제의 코드에 따라, A, B, C, D 값은 배열 arr에 저장된다. 배열에는 실제 문자열이 아니라 아스키값이 저장된다는 점을 알아야 한다. A의 아스키 값은 10진법으로는 65, 16진수로는 0x41이다. B는 66 또는 0x42이다. 보다시피 gdb에서 프린트된 값은 배열 arr에 저장된 값 그대로이다.

두 번째 명령어의 나머지 4바이트는 뭘까? 이 바이트는 스택에 속한 것으로, main 함수를 호출하는 동안 스택 맨 위에 놓인 최근의  스택 프레임의 데이터를 포함한다. 스택 세그먼트는 다른 세그먼트와 정반대 방식으로 채워진다는 점을 명심하자.

다른 메모리 지역은 작은 주소부터 시작해서 주솟값이 더 커지는 방향으로 채워진다. 하지만 스택 세그먼트는 그렇지 않다. 스택 세그먼트는 큰 주소부터 채워지고 점차 주솟값은 작아진다. 그 원인은 현대 컴퓨터의 발달 역사에도 있고, 스택 세그먼트의 기능이 스택 자료구조와 비슷하게 작동한다는 데도 있다.

여기서 주소가 커지는 방향으로 스택  세그먼트를 읽는다면, 사실상 스택 세그먼트에 이미 푸시된 내용을 읽는 것에 불과하다. 그리고 이 바이트를 변경하려고 한다면 스택을 변경하는 것이고, 좋은 방식이 아니다. 이것이 왜 위험한지 그리고 그 방법은 무엇인지 예를 들어보자.

왜 배열 arr의 크기보다 더 큰 값이 보이는 걸까? gdb는 우리가 요청한 메모리의 바이트 수를 검사하기 때문이다. 명령어 x는 배열의 경계를 신경 쓰지 않는다. 이 명령어로 범위를 출력하려면 단지 시작 주소와 바이트 수만 필요하다.

스택 내부의 값을 변경하려면 명령어 set을 사용해야 한다. 이 명령어는 기존 메모리 셀을 수정할 수 있도록 한다. 이 경우 메모리 셀은 배열 arr에 있는 개별 바이트를 참조한다.

```shell
(gdb) x/4b arr
0x7ffffffffcae0: 0x41	0x42	0x43	0x44
(gdb) set arr[1] = 'F'
(gdb) x/4b arr
0x7ffffffffcae0: 0x41	0x46	0x43	0x44
(gdb) print arr
$2 = "AFCD"
(gdb)
```

set 명령어를 사용해 배열 arr의 두 번째 원소를 F로 두었다. 배열의 경계 바깥에 있는 주소를 변경할 때도 gdb를 이용할 수 있다.

이제 배열 arr 보다 훨씬 더 큰 주소에 위치한 바이트를 수정하려고 한다. 앞서 설명했듯 스택에 이미 푸쉬된 내용을 변경할 것이다.

``` shell
(gdb) x/20x arr
0x7fffffffffffcae0: 0x41	0x42	0x43	0x44	0xff	0x7f	0x00	0x00
0x7fffffffffffcae8: 0x00	0x96	0xea	0x5d	0xf0	0x31	0xea	0x73
0x7fffffffffffcaf0: 0x90	0x05	0x40	0x00
(gdb) set *(0x7ffffffffffcead) = 0xff
(gdb) x/20x arr
0x7fffffffffffcae0: 0x41	0x42	0x43	0x44	0xff	0x7f	0x00	0x00
0x7fffffffffffcae8: 0x00	0x96	0xea	0x5d	0xf0	0x31	0xea	0x73
0x7fffffffffffcaf0: 0x90	0x05	0x40	0x00
```

배열의 경계 바깥에 있는 0x7ffffffffcead 주소에 0xff 값을 썼다. 이 값은 main 함수에 진입하기 전에 푸쉬된 스택 프레임 안에 존재하는 바이트이다.

실행을 계속하다면 어떤 일이 발생할까? 스탹의 중요바이트를 수정했다면 충돌이 일어나거나 어떤 메커니즘에 따라 이 수정이 감지되어 프로그램의 실행이 중단된다. 명령어 c (또는 continue)는 gdb 에서 프로세스를 계속해서 실행할 것이다.

``` shell
(gdb) c
Continuing
*** stack smashing detected ***: .../exe_dbg.out terminated

Program received signal SIGABRT Aborted.
0x00007ffff7a42428 in __GI_raise (sig=sig@entry=6) at ../sysdeps/Unix/sysv/linux/raise.c:54
54	../sysdeps/Unix/sysv/linux/raise.c: No such file or directory.
(gdb)
```

여기서 방금 스택을  스매싱했다. 할당하지 않은 주소에 있는 스택 내용을 수정한다면, 그것이 단 1바이트라고 하더라도 매우 위험할 수  있으며 일반적으로 충돌을 일으키거나 갑자기 종료된다.

앞서 말한 대로 프로그램의 실행에 필수인 절차의 대부분은 스택 메모리에서 수행된다. 그러므로 스택 변수를 작성할 때는 매우 주의를 기울여야 한다. 변수나 배열에 정의된 경계 바깥의 어떠한 값도 쓰지 않아야 한다. 스택 메모리에서 주소는 점점 더 작아지기 때문이다. 그러면 이미 작성된 바이트에 덮어 쓰기 십상이다.

디버그를 마치고 나면 gdb 에서 나갈 준비가 되었으니 간단히 명령어 q ( 또는 quit )을 사용한다.

추가로 참고할 점은 스택의 가장 위에 할당된 __버퍼 buffer__ (바이트 또는 문자열 배열의 다른 이름)에 확인되지 않은 값을 작성하는 일은 취약점으로 간주된다는 것이다. __오버플로__ 공격 때문에 이는 대게 __익스플로잇__ 이라고 한다.

```c
// 버퍼 오버플로 취약성을 나타내는 프로그램
int main(int argc, char** argv)
{
    char str[10];
    strcpy(str, argv[1]);
    printf("hello %s\n", str);
    return 0;
}
```

앞의 코드는 argv[1] 입력값의 내용과 크기를 검사하지 않고 배열 str에 곧바로 복제한다. 그리고 이 값은 스택의 맨 위에 할당된다.

충돌을 일으키지만 위험한 어떤 경우에는 익스프로잇을 야기할 수 있다.



### 5.1.2 스택 메모리 사용 시 주의점

__스코프__ 라는 개념을 알아보자. 각 스택 변수는 고유의 스코프를 갖고, 이 스코프는 변수의 수명을 결정한다. 이는 스택 변수가 한 스코프 내에서 수명을 시작해서 해당 스코프를 떠나면 죽는다는 것을 의미한다. 즉, 스코프는 스택 변수의 수명을 결정한다.

스택 변수를 메모리에서 자동으로 할당하고 해제할 수는 있지만 오직 스택 변수에만 해당한다. 이러한 자동 메모리 관리는 스택 세그먼트의 고유 특성에서 비롯된다. 스택 변수를 선언할 때마다 이 변수는 스택 세그먼트의 가장 윗부분에 할당된다. 할당은 자동으로 이뤄지며 이는 변수 수명의 시작으로 기록될 수 있다. 이후에 더 많은 다른 변수와 스택 프레임이 스택의 맨 위에 놓인다. 변수가 스택에 존재하고 다른 변수가 그 위에 놓이는 한 그 변수는 계속 살아남는다.

그러나 결국 이 변수는 스택에서 팝아웃된다. 미래의 어느 지점에서 프로그램은 종료될 것이고, 그러면 스택은 그 순간 비워져야 하기 때문이다. 그러므로 변수가 스택에서 팝아웃될 미래의 어느 지점이 존재할 것이다. 따라서 해제 또는 팝아웃은 자동으로 이뤄지고, 이는 변수의 수명의 끝으로 표시될 것이다. 근본적으로는 이러한 이유로 개발자가 제어하지 않는 스택 변수의 메모리 관리가 자동으로 이뤄진다고 할 수 있다.

```c
int main(int argc, char** argv)
{
    int a;
    ...
    return 0;
}
```

이 변수는 main 함수가 반환되기 전까지 스택에 남아있다. 다시 말하면 변수는 변수의 스코드가 유효할 때까지는 존재한다. main 함수는 모든 프로그램이 실행하는 함수이므로, 변수의 수명은 프로그램이 실행되는 내내 선언되는 전역 변수와 거의 같다.

이 변수는 전역 변수 같기는 하지만 정확히 말하자면 아니다. 이 변수는 스택에서 팝아웃되는 때가 있지만, 전역 변수는 main 함수가 종료되고 프로그램이 완료된 때에도 메모리를 갖기 때문이다. main 함수 전후로 실행되는 두 코드가 있으니 주의 깊게 보자. 각각은 프로그램을 시작하고 완료한다. 하나 더 주목할 것은 전역 변수는 데이터나 BSS 같은 다른 세그먼트에 할당되며 이들 세그먼트는 스택 세그먼트처럼 작동하지 않는다는 점이다.

```c
// 스택의 가장 윗부분에서 변수를 선언하기
int* get_integer() {
	int var = 10;
	return &var;
}

int main(int argc, char** argv) {
    int *ptr = get_integer();
    *ptr = 5;
    return 0;
}
```

get_integer 함수는 지역 변수 var 의 주소를 반환하며, var는 get_integer 함수의 스코프에서 선언된 것이다. get_integer 함수는 지역 변수의 주소를 반환한다. 그러고 나서  main 함수는 받은 포인터를 역참조해 주소가 가리키는 메모리 지역에 접근하려고 한다.

```shell
$ gcc main.c -o exe.out
main.c: In function 'get_integer':
main.c:3:11: warning: funcion returns address of local variable [-Wreturn-local-addr]
	return &var;
		   ^~~~~
$
```

셸 박스처럼 경고 메시지를 받는다. 지역 변수의 주소를 반환하는 일은 흔한 실수인만큼, 컴파일러는 이미 이 실수를 알고 있으며 다음과 같은 명확한 경고 메시지를 나타낸다.

- warning : function returns address of a local variable

그리고 다음은 프로그램을 실행하면 발생하는 세그멘테이션 오류이다.

```shell
$ ./exe,out
Segmentation fault (core dumped)
$
```

이는 충돌이라고 해석할 수 있다. 일반적으로 이전에 할당되었으나 현재는 해제된 메모리 영역에 유효하지 않은 접근을 했기 때문이다.

```
어떤 경고는 오류로 다뤄야 한다. 예를 들어, 앞의 경고는 일반적으로 충돌을 일으키는 만큼 오류가 되어야 한다. 모든 경고를 오류로 처리하려면 -Werror 옵션을 gcc 컴파일러에 전달한다. 가령 앞의 경고처럼 하나의 특정한 경고만 오류로 처리하려면 -Werror=return-local-addr 옵션을 전달하면 된다.
```

gdb로 프로그램을 실행하면 충돌에 관한 더 자세한 내용이 나타난다. 하지만 컴파일시 (최종 실행 가능한 목적파일에) 디버그 정보를 삽입하는 -g 옵션을 사용해야 gdb 가 도움이 된다.

gdb 또는 valgrind 같은 다른 디버그 도구를 사용해 프로그램을 디버그하려면 반드시 -g 옵션을 써서 소스 파일을 컴파일해야 한다.



```shell
$ gcc -g main.c -o exe_dbg.out
main.c: In function 'get_integer':
main.c:3:11: warning: funcion returns address of local variable [-Wreturn-local-addr]
	return &var;
		   ^~~~~
$ gdb exe_dbg.out
GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1
...
Reading symbols from exe_dbg.out...done.
(gdb) run
Starting program: .../exe_dbg.out
Program received signal SIGSEGV, Segmentation fault
0x00005555555546c4 in main (argc=1 argv=0x7fffffffdf88)
	at main.c:8
8	 *ptr = 5;
(gdb) quit
$
```

gdb의 출력 내용에 명확하게 나타나듯, 충돌의 원인은 main 함수 내의 8번 행에 있다. 이 지점은 프로그램이 반환된 포인터를 역참조해서 반환된 주소를 작성하려는 곳이다. 하지만 변수 var 는 get_integer 함수의 지역 변수이며, 이 변수는 더 이상 존재하지 않는다. 8번 행에서 get_integer 함수 및 해당 스코프에서 이미 반환되었으므로 사라졌다. 따라서 반환된 포인터는 __허상 포인터__ 이다.

현재 스코프에 있는 변수의 주소를 가리키는 포인터를 다른 함수로 전달하는 것이 일반적이며, 반대로는 전달하지 않는다. 현재 스코프가 유효한 이상, 변수는 현재의 스코프에 있기 때문이다. 함수를 추가로 호출하면 스택 세그먼트의 위에 무언가를 더 놓을 뿐, 현재 스코프는 새로 놓인 것보다 먼저 종료되지 않는다.

- 스택 메모리는 크기가 제한적이다. 그러므로 큰 객체를 저장하기에 좋은 장소가 아니다.
- 스택 세그먼트의 주소는 작아진다. 그러므로 스택 메모리를 오름차순으로 읽으면 이미 푸쉬된 바이트를 읽는 것과 같다.
- 스택은 자동으로 메모리가 관리된다. 할당 및 해제 모두 해당한다.
- 모든 스택 변수는 스코프를 가지며 스코프는 변수의 수명을 결정한다.
- 포인터는 계속 스코프 내에 존재하는 스택 변수만을 가리켜야한다.
- 스택 변수의 메모리 해제는 자동으로 수행된다. 스코프가 종료되어 더 이상 개발자가 통제할 수 없을 때 자동으로 해재된다.
- 현재 스코프에 존재하는 변수에 대한 포인터는 다른 함수에 인자로 전달될 수 있다. 단, 호출된 함수에 있는 코드가 포인터를 사용하려고 할 때 현재 스코프가 여전히 그 장소에 있다고 확인한 경우에만 가능하다. 이 조건은 동시성 로직이 있는 상황에서는 깨진다.



## 5.2 힙

어떤 프로그래밍 언어로 작성했든 간에 대부분의 코드에서 어떤 방식으로든 힙 메모리를 사용한다. 힙은 스택을 사용해서는 얻을 수 없는  고유의 장점이 있다.

반면 힙은 단점도 있다. 예를 들면 스택 메모리의 비슷한 영역보다 힙 메모리 영역에 할당하는 것이 더 느리다.

__1. 힙은 자동으로 할당되는 메모리 블록을 갖지 않는다.__  대신 개발자가 malloc 또는 그와 유사한 함수를 사용해서 힙 메모리 블록을 하나씩 얻어야 한다. 자동할당이 되지 않는다는 힙의 이러한 약점은 스택 메모리에서는 해결된다. 스택 메모리는 스택 프레임을 포함하고, 스택 프레임은 개발자가 할당하거나 푸쉬하지 않으며, 함수를 호출한 결과로 자동으로 할당 및 푸시된다.

__2. 힙은 메모리 크기가 크다.__ 스택의 크기는 제한되므로 큰 객체를 저장하려면 좋은 선택지가 아닌 반면, 힙은 수십 기가바이트에 달하는 매우 큰 객체를 저장할 수 있다. 힙 크기가 커질수록 할당자는 운영체제에서 힙 페이지를 더 많이 요청해야 한다. 그리고 힙 메모리 블록은 이 페이지를 따라 더 전파된다. 스택 세그먼트와 달리, 힙 메모리에서 할당되는 주솟값은 점차 더 커진다.

__3. 힙 메모리 내에서 메모리의 할당과 해제는 개발자가 관리한다.__ 이는 개발자가 메모리를 할당하고 또한 더 이상 메모리가 필요 없을 때 해제하는 일을 맡은 유일한 개체라는 의미이다. 많은 현대의 프로그래밍 언어에서 할당된 힙 블록을 비우는 일은 __가비지 컬렉터__ 라는 병행 컴포넌트가 자동으로 수행한다. 하지만 C 와 C++에서는 이런 개념이 없으며, 힙 블록은 수동으로 비워야 한다. 이는 위험요소이며 C/C++ 개발자는 힙 메모리를 다룰 때 매우 조심해야 한다. 할당된 힙 블록을 비우는 데에 실패하면 대개 __메모리 누수__ 가 발생하고, 대부분의 경우 치명적일 수 있다.

4. 스택의 변수와는 달리 __힙에 할당된 변수는 스코프를 전혀 갖지 않는다. __
5. 이는 메모리 관리를 더 어렵게 만드는 위험 요인이다. 변수를 언제 해제해야 할지도 모르며 효율적으로 메모리를 관리하려면 메모리 블록의 스코프와 소유자를 위한 새로운 정의를 생각해야 한다.

__6. 힙 메모리 블록의 주소를 지정하려면 포인터만 사용할 수 있다.__ 즉, 힙 변수와 같은 개념은 존재하지 않는다. 힙 지역은 포인터를 통해 주소가 지정된다.

__7. 힙 세그먼트는 소유자 프로세스의 전용이므로 검사하려면 디버거를 사용해야 한다.__ 다행히 C 포인터는 힙 메모리 블록에서 스택 메모리 블록과 정확히 동일한 방식으로 작동한다. C 는 이러한 추상화를 매우 잘 수행하며 덕분에 같은 포인터를 사용해 힙과 스택 메모리의 주소를 지정할 수 있다.



### 5.2.1 힙 메모리의 할당과 해제

힙 메모리는 수동으로 얻고 비워야 한다. 이는 힙의 메모리 블록을 할당하거나 비우기 위해 개발자가 일련의 함수나 API  를 사용해야 한다는 뜻이다.

이러한 함수는 헤더파일인 stdlib.h 에 정의된다. 힙 메모리 블록을 얻는데 사용되는 함수는 malloc, calloc, realloc 이다. 그리고 힙 메모리 블록을 해제하는 데 사용되는 유일한 함수는 free 이다.

힙 할당 함수와 관련해 이름에서 알 수 있듯 calloc 은 __청소 및 할당 clear and allocate__ 을, 그리고 malloc 은 __메모리 할당 memory allocate__ 을 의미한다. 따라서 calloc은 할당 이후 메모리 블록을 청소하지만 malloc 은 프로그램이 필요에 따라 스스로 해제할 때까지 메모리 블록을 초기화되지 않은 상태로 남겨둔다.

```
C++에서 new와 delete 키워드는 각각 malloc 과 free 와 같은 역할을 한다. 추가로 새로운 연산자가 피연산자의 자료형에 할당된 메모리의 크기를 나타내며, 이 연산자는 반환된 포인터를 자동으로 피연산자의 자료형으로 변환한다.
```

malloc 이 할당한 메모리 블록은 0이 아닌 값을 갖지만 calloc 이 할당한 메모리 블록은 모두 0임을 알 수 있다. 크로스 플랫폼 프로그램을 작성하려면 언제나 C언어의 명세를 따라야 한다. 명세에 따르면 malloc 은 할당된 메모리 블록을 초기화하지 않는다.

다른 운영체제가 아니라 오직 리눅스를 위한 프로그램을 작성할 때도 나중에 컴파일러가 다르게 작동할 수 있다는 점을 알고 잇어야 한다. 그러므로 C 언어의 명세에 따라서 malloc 이 할당한 메몸리 블록은 초기화되지 않으며, 필요하다면 수동으로 초기화해야 한다는 것을 꼭 이해해야 한다.

malloc 이 할당된 메모리를 초기화하지 않으므로 calloc 보다 빠르다는 점을 알아두자 구현에 따라 malloc은 메모리 블록에 접근할 때까지 실제로 메모리 블록을 할당하지 않으며 할당을 지연한다. 이러한 방식으로 메모리 할당이 더 빠르게 일어난다.

malloc 이후에 메모리를 초기화하려면 memset 함수를 사용할 수 있다.

```c
# include <stdlib.h>
# include <string.h>

int main(int argc, char** argv)
{
    cahr * ptr = (char *)malloc(16 * sizeof(char));
    memset(ptr, 0, 16 * sizeof(char));
    memset(ptr, 0xff, 16 * sizeof(char));
    ...
    free(ptr);
    return 0;
}
```

relloc 함수는 힙 할당 함수에 속한다고 소개했던 도 다른 함수이다. 이 함수는 이미 할당된 메모리 블록의 크기를 조정해 메모리를 재할당한다.

```c
int main(int argc, char** argv)
{
    char * ptr = (char*)malloc(16 * sizeof(char));
    ...
    ptr = (char *)malloc(32 * sizeof(char));
    ...
    free(ptr);
    return 0;
}
```

realloc 함수는 이전의 블록에 있는 데이터를 변경하지 않으며 이미 할당된 블록을 새로운 블록으로 확장한다. __단편화__ 때문에 현재 할당된 블록을 확장할 수 없을 때는 다른 충분히 큰 블록을 찾은 뒤 이전 블록에서 새 블록으로 데이터를 복제한다. 이때도 이전의 블록을 해제한다. 보다시피 재할당은 많은 단계를 수반하므로 때에 따라서는 쉬운 방식이 아니다. 따라서 신중하게 사용해야 한다.

free 함수는 포인터를 넘겨서 이미 할당된 힙 메모리 블록의 주소를 전달해 이 메모리 블록을 해제한다. 앞서 말한 대로 할당된 모든 힙블록은 더 이상 필요하지 않을 때 해제되어야 한다. 해제에 실패하면 __메모리 누수__ 가 발생한다.

```c
# include <stdlib.h>

int main(int argc, char** argv)
{
    char* ptr = (char*)malloc(16 * sizeof(char));
    return 0;
}
```

이 프로그램은 끝날 때 힙 메모리에 할당되고 나서 해제되지 않은 16바이트를 가지므로 메모리 누수가 존재한다. 소스코드가 더 커지고 더 많은 요소가 포함된다면 사람의 눈으로 메모리 누수를 감지하기 어렵거나 심지어 불가능할 수도 있다.

메모리 프로파일러는 실행 중인 프로세스에서 메모리 문제를 감지할 수 있는 유용한 프로그램이다. valgrind는 이중 가장 유명한 도구이다.

valgrind를 사용하려면 우선 디버그 옵션 -g를 이용해 예제를 빌드해야 한다 그다음 valgrind 로 실행해야 한다. 주어진 실행 가능한 목적 파일을 실행하는 동안 valgrind 는 모든 메모리 할당 및 해제를 기록한다. 마지막으로 실행이 종료되거나 충돌이 발생했을 때, valgrind는 할당 및 해제에 대한 요약과 해제되지 않은 메모리양을 출력한다. 이 방식으로 valgrind 는 주어진 프로그램에서 실행할 때 얼마나 메모리 누수가 발생하는 지 알 수 있도록 한다.



```shell
// 메모리 누수 체크하는 valgrind 예제
$ gcc -g main.c -o exe.out
$ valgrind ./exe.out
==12022== Memcheck. a memory error detector
...
==12022== Command: ./exe.out
==12022==
==12022==
==12022== HEAP SUMMARY:
==12022== 	in use at exit: 16bytes in 1 blocks
==12022== 	total heap usage: 1 allocs, 0 frees, 16 bytes allocated
==12022==
==12022== LEAK SUMMARY:
==12022==	definitely lost: 16 bytes in 1 blocks
==12022==	indirectly lost: 0  bytes in 1 blocks
==12022==	  possibly lost: 0  bytes in 1 blocks
==12022==	still reachable: 0  bytes in 1 blocks
==12022==	     suppressed: 0  bytes in 1 blocks
==12022== Rerun with --leak-check=full to see details if leaked memory
==12022==
==12022== For counts of detected and suppressed errors, rerun with: -v
==12022== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
$
```

위에서 HEAP SUMMARY 섹션을 보면 할당은 1, 해제는 0이고 종료할 때 16 바이트가 할당된 채로 남아 있다. 조금 더 아래로 내려가서 LEAK SUMMARY 섹션을 보면 16바이트가 명백히 손실되었으며 이는 메모리 누수를 의미한다.

메모리 누수가 언급된 블록이 어느 행에 할당되었는지 정확히 알고 싶다면, 이를 위해 만든 특수 옵션을 더해 valgrind 를 사용할 수 있다. 다음에서 할당에 실제로 관여하는 행을 찾을 때 valgrind 를 사용하는 방법을 살펴보자.

```shell
// 메모리 누수 체크하는 valgrind 예제
$ gcc -g main.c -o exe.out
$ valgrind --leak-check=full ./exe.out
==12022== Memcheck. a memory error detector
...
==12022== Command: ./exe.out
==12022==
==12022==
==12022== HEAP SUMMARY:
==12022== 	in use at exit: 16bytes in 1 blocks
==12022== 	total heap usage: 1 allocs, 0 frees, 16 bytes allocated
==12022==
==12022== 16 bytes in 1 blocks are definitely lost in loss record 1 of 1
==12022==	at 0x4C2FB0F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==12022==	by 0x108662: main (main.c:7)
==12022==
==12022== LEAK SUMMARY:
==12022==	definitely lost: 16 bytes in 1 blocks
==12022==	indirectly lost: 0  bytes in 0 blocks
==12022==	  possibly lost: 0  bytes in 0 blocks
==12022==	still reachable: 0  bytes in 0 blocks
==12022==	     suppressed: 0  bytes in 0 blocks
==12022==
==12022== For counts of detected and suppressed errors, rerun with: -v
==12022== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)
$
```

-leak-check=full 옵션을 valgrind 에 전달했고, 이제 힙 메모리의 누수에 관련된 코드가 나타난다. malloc 함수를 호출하는 4번째 행이 바로 누수되는 힙 블록이 할당되는 지점이라는 것을 나타낸다. 이는 언급된 누수 블록을 해제할 정확한 위치를 추적하고 찾도록 돕는다.

```c
# include <stdlib.h>

int main(int argc, char** argv)
{
    char* ptr = (char*)malloc(16 * sizeof(char));
    free(ptr);
    return 0;
}
```

코드에 변경해서 유일하게 할당된 힙 블록 하나가 해제되었다 다시 빌드해 valgrind 를 실행해보자

```shell
// 메모리 누수 체크하는 valgrind 예제
$ gcc -g main.c -o exe.out
$ valgrind --leak-check=full ./exe.out
==12022== Memcheck. a memory error detector
...
==12022== Command: ./exe.out
==12022==
==12022==
==12022== HEAP SUMMARY:
==12022== 	in use at exit: 16bytes in 1 blocks
==12022== 	total heap usage: 1 allocs, 0 frees, 16 bytes allocated
==12022==
==12022== All heap blocks were freed -- no leaks are possible
==12022==
==12022== For counts of detected and suppressed errors, rerun with: -v
==12022== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)
$
```

valgrind는 모든 힙 블록이 해제되었다고 하며, 이는 프로그램에서 사실상 더이상의 메모리 누수가 없다는 의미이다. valgrind 로 실행하는 프로그램은 10~50배 정도로 눈에 띄게 느려지지만, 이렇게 해서 메모리 문제를 매우 쉽게 발견할 수 있도록한다. 작성한 프로그램을 메모리 프로파일러 내에서 실행해 가능한 한 빨리 메모리 누수를 잡아내는 것이 좋다.

메모리 누수는 설계가 올바르지 않아서 누수를 야기하는 경우 __기술 부채__ 로 간주되며, 누수가 존재하지만 심화되고 나서 무슨 일이 발생할지 알지 못하는 경우에는 또한 __위험 요인__ 이라고도 본다. 하지만 필자는 이 두 가지를 모두 __버그__ 로 처리해야 한다고 본다. 그렇지 않으면 다시  보는 데 시간이 걸린다.



### 5.2.2 힙 메모리 원칙

스택의 모든 메모리 블록은 스코프를 갖는다. 따라서 이 스코프에 따라 메모리 블록의 수명을 정의하기는 쉬운 일이다. 스코프를 벗어날 때마다 스코프 내의 모든 변수는 사라진다. 하지만 힙 메모리에서는 차이가 있으며 훨씬 더 복잡하다.

힙 메모리 블록은 아무 스코프도 갖지 않는다. 따라서 수명이 불분명하므로 다시 정의되어야 한다. 이를 메모리를 수동으로 해제하거나 자바 같은 현대 언어는 __세대별 가비지 컬렉션__ 을 사용한다. 힙의 수명은 프로그램 자체에서 정의되거나 사용된 C 라이브러리로는 정의될 수 없다. 개발자만이 힙 메모리 블록의 수명을 결정할 수 있는 유일한 존재이다.

힙 수명의 복잡성을 극복하기 위해 고안된 전략 중 가장 좋은 것은, 당연히 완벽한 해법은 아니지만 메모리 블록을 아우르는 스코프를 갖느 대신 메모리 블록의 __소유자__를 정의하는 방법이다.

소유자는 힙 메모리 블록의 수명을 관리하는 유일한 개체이며, 먼저 블록을 할당하고 더 이상 필요하지 않을 때는 해제하는 역할을 한다.  예제를 보자

```c
# include <stdio.h>
# include <stdlib.h>

# define QUEUE_MAX_SIZE 100

typedef struct {
    int front;
    int rear;
    double * arr;
} queue_t;

void init(queue_t * q) {
    q->front = q->rear = 0;
    q->arr = (double*)malloc(QUEUE_MAX_SIZE) * sizeof(double));
}

void destroy(queue_t * q) {
    free(q->arr);
}

int size(queue_t * q) {
    return q->rear - q->front;
}

void enqueue(queue_t* q, double item) {
    q->arr[q->rear] = item;
    q->rear++;
}

double dequeue(queue_t* q) {
    double item = q->arr[q->front];
    return item;
}

int main(int argc, char **argv){
    queue_t* q = (queue_t *)malloc(sizeof(queue_t));
    init(q);
    
    enqueue(q, 6.5);
    enqueue(q, 1.3);
    enqueue(q, 2.4);
    
    printf("%f\n", dequeue(q));
    printf("%f\n", dequeue(q));
    printf("%f\n", dequeue(q));
    
    destroy(q); // 큐 객체 파괴는 획독했던 리소스를 해제한다.
    free(q); // main함수가 획득한 큐 객체에 대해 할당된 메모리를 해제한다.
    return 0;
}


```

이 코드는 각각 특정 객체를 소유하는 서로 다른 2개의 소유권을 포함한다. 첫 번째 소유권은 포인터 arr 가 주소를 지정하는 힙 메모리 블록에 관한 것으로, 포인터는 큐 객체가 소유하는 queue_t 구조체에 있다. 큐 객체가 존재하는 한, 이 메모리 블록은 할당된 채로 남아 있어야만 한다.

두 번째 소유권은 main 함수가 가지는 힙 메모리 블록을 큐 객체인 q의 자리 표시자로 간주하며, 이 큐 객체는 main 함수 자신이 소유하는 것이다. 큐 객체와 main함수가 소유하는 힙 메모리 블록을 구분하는 일은 매우 중요하다. 이 블록 중 하나를 해제하더라도 다른 블록은 해제되지 않기 때문이다.

앞의 코드에서 메모리 누수가 어떻게 발생하는 지 설명하기 위해, 큐 객체에 destroy 함수를 호출하는 것을 깜빡 잊었다고 가정해보자. 그러면 반드시 메모리 누수가 발생한다. init 함수 내부에 잇는 힙 메모리 블록이 할당된 채로 남아 해제되지 않앗기 때문이다.

어던 객체가 힙 메모리 블록을 소유한다면 주석으로 표기한다는 점을 명심하자 블록을 소유하지 않는다면 어느것도 힙 메모리 블록을 해제해서는 안된다.

같은 힙 메모리 블록을 여러번 해제하면 __이중 해제(더블프리)__  가 발생한다는 점을 명심하자. 더블 프리상황은 메모리 손상 문제에 해당하며, 다른 메모리 손상 문제와 마찬가지로 감지 직후에 처리 및 해결되어야 한다.

힙 블록의 수명을 관리하는 다른 기술은 __RAII__ 객체를 사용하는 것이다. RAII 는 __리소스 획득은 초기화 Resource Acquisition Is Initialization__ 라는 의미이다. 메모리 블록에 할당된 힙과 같은 리소스의 수명을 어떤 객체의 수명과 연결할 수 있다는 뜻이다. 즉, 어떤 객체를 사용하는 상황에서 객체를 생성하면 리소스를 초기화하고, 파괴하면 리소스가 해제된다는 뜻이다. 유감스럽게도 C에서는 이 기술을 사용할 수 없다. 객체가 파괴되었다는 정보를 전달받을 수 없기 때문이다. 하지만 C++ 소멸자를 이용해 이 기술을 효과적으로 사용한다. RAII 객체에서 리소스는 생성자에서 초기화되고, 리소스의 초기화를 취소하는 데 필요한 코드는 소멸자로 들어간다. C++에서 소멸자는 객체가 스코프를 벗어나거나 삭제될 때 자동으로 호출된다.

결론적으로 힙 메모리를 다룰 때는 꼭 가이드 라인을 따라야한다,

- 힙메모리 할당에는 치러야 할 나름의 비용이 있다. 모든 메모리 할당함수가 같은 비용을 치르는 것은 아니지만 malloc 은 대체로 그 비용이 가장 덜 드는 함수이다.
- 힙 공간에 할당된 모든 메모리 블록은 더 이상 필요하지 않을 때나 프로그램을 종료하기 직전에 반드시 해제되어야 한다.
- 힙 메모리 블록은 스코프를 갖지 않으므로, 가능한 모든 누수를 피하려면 프로그램이 반드시 메모리를 관리할 수 있어야 한다.
- 각각의 힙 메모리 블록에 대한 메모리 관리 전략을 고수해야 한다.
- 선택한 전략과 전략에 관한 가정은 블록에 접근할 때마다 코드에 기록되어야 한다. 그래야 향후에 이 코드를 볼 개발자가 전략을 알 수 있다.
- C++ 같은 특정 프로그래밍 언어에서는 RAII 객체를 사용해 힙 메모리 블록과 같은 리소스를 관리할 수 있다.



지금까지는 큰 객체를 저장하기에도 충분하고 어떤 프로그램을 실행하기에도 충분한 메모리를 가졌다고 가정했다. 하지만 다음절에서는 사용 가능한 메모리에 제한을 둘것이며, 메모리가 부족하거나 메모리 저장소를 추가하는 데 드는 비용이 큰 환경에 관해 다루겠다. 이럴 때는 가장 효율적인 방식으로 가용 메모리를 써야한다.



## 5.3 제한된 환경에서의 메모리 관리

메모리가 귀한 자원이자 제한적인 환경이 있다. 또한 성능이 핵심 요소여서 메모리가 얼마나 있든지 프로그램이 빨라야만 하는 환경도 있다. 메모리 관리 측면에서 각 환경은 메모리 부족과 성능 저하를 극복하는 특정 기술이 필요하다. 우선 제한된 환경이 무엇인지 알아야 한다.

제한된 환경이란 반드시 메모리 용량이 작은 경우는 아니다. 일반적으로는 프로그램의 메모리 사용을 제한하는 몇 가지 __제약 조건__ 이 존재한다. 이러한 제약 조건은 이용자의 메모리 사용에 대한 하드리밋 때문일 수도 있고, 또는 저용량의 메모리를 제공하는 하드웨어 때문일 수도 있고, 더 큰 메모리를 지원하지 않는 운영체\ㅔ제 때문일 수도 잇다.

제한 조건이나 하드웨어의 한계가 없더라도, 개발자로서 우리는 가능한 한 최선을 다해 메모리를 최소한으로 또한 최적의 방식으로 사용하고 싶다. 메모리 사용은 프로젝트에서 중요한 __비기능 요구 사항__ 의 하나이며, 주의 깊게 모니터링하고 튜닝해야 한다.



### 5.3.1 메모리가 제한된 환경

메모리가 제한된 환경에서 메모리 관리의 몇 가지 팁이 존재하지만, 그 중 어느것도 잘 튜닝된 알고리즘만큼의 효과는 없다. 이 경우에는 일반적으로 메모리 복잡도 낮은 알고리즘이 사용된다. 이 알고리즘은 보통 __시간 복잡도__ 가 높은데, 이는 낮은 메모리 사용과 타협해야 하는 관계, 즉 트레이드오프 관계이다.

더 자세히 설명하자면, 모든 알고리즘은 특정한 __시간 복잡도__ 와 __메모리 복잡도__ 를 갖는다. 시간 복잡도는 입력값의 크기와 알고리즘이 완료될 때까지 걸리는 시간 사이의 관계를 설명한다. 이와 비슷하게 메모리 복잡도는 입력값의 크기와 알고리즘이 작업을 완료하는 데 사용하는 메모리 사이의 관계를 설명한다. 두 복잡도는 일반적으로 __Big_O 함수__ 로 나타낸다.

이상적인 알고리즘은 시간 복잡도 및 메모리 복잡도가 낮아야 한다. 다시 말하면 적은 양의 메모리를 소비하면서도 빠른 알고리즘이 매우 바람직하다. 하지만 양쪽의 장점을 모두 갖추는 상황은 흔하지 않다.

대부분 메모리와 시간을 나타내는 속도 사이에서 타협한다. 예를 들면 다른 알고리즘보다 빠른 분류 알고리즘은, 다른 알고리즘과 같은 일을 하는데도 메모리를 더 많이 사용한다.

특히 프로그램을 작성할 때는 최종 프로덕션 환경에 충분한 메모리가 있다 하더라도, 메모리가 제한적인 환경을 위해서 코드를 작성한다고 가정하는 편이 좋으면서도 보수적인 방법이다. 메모리를 너무 많이 사용할 위험을 줄이고자 이렇게 가정한다.

메모리를 남용할 위험을 줄이려면 최종 설치시 평균 메모리 가용 크기를 더 정확하게 추산해서 제어 및 조정해야 한다. 메모리가 제한적인 환경을 위해 설계된 알고리즘은 본질적으로 더 느리며, 이런 함정에는 반드시 주의를 기울여야 한다.



#### 패킹된 구조체

메모리를 적게 사용하는 가장 쉬운 방법으로 패킹된 구조체를 사용하는 방식이 있다. 패킹된 구조체는 메모리 정렬을 폐기하고 필드를 저장하는 더 작은 메모리 레이아웃을 갖는다. 패킹된 구조체를 사용하는 것은 사실 절충안이다. 메모리 정렬을 폐기하기 때문에 메모리를 덜 사용하므로, 결국 구조체 변수를 로드하는 동안 메모리를 읽는 시간이 더 든다. 그 결과 프로그램이 더 느려진다.

이 방법은 간단하지만 모든 프로그램에 권장하지는 않는다.



#### 압축

 압축은 특히 메모리 내부에 자장할 텍스트 데이터가 많은 프로그램에서 효과적인 기법이다. 텍스트 데이터는 이진 파일 데이터에 비해 __압축률__이 높다. 이 기법은 프로그램이 메모리 반환값이 큰 실제 텍스트 데이터 대신 압축된 형태를 저장하도록 한다.

하지만 메모리를 절약하는 작업에는 비용이 따른다. 압축 알고리즘은 __CPU 바운드__ 이자 계산 집약처이므로, 프로그램은 결국 성능이 저하된다. 이 방법은 자주 필요하지 않은 텍스트 데이터를 갖는 프로그램에게 이상적이다. 그렇지 않으면 압축과 압축 해제 작업이 많이 필요해서 결국 프로그램을 거의 사용하지 못하게 된다.



### 5.3.2 성능이 더 나은 환경

앞서 알고리즘의 시간 및 메모리 복잡도에 관해 설명한 대로, 더 빠른 알고리즘을 원할 때 일반적으로 메모리를 더 사용할 것이라고 에상한다. 그러므로 이번 절에서는 성능 향상을 위해 메모리를 더 사용할 것이라고 간주한다.

성능을 향상하기 위해 캐시를 사용하는 것이 그  직관적인 예시에 해당한다. 데이터를 캐싱하는 것은 더 많은 메모리를 소비한다는 의미이지만, 캐시가 적절히 사용한다면 더 나은 성능을 기대할 수 있다. 하지만 메모리를 추가하는 것이 성능을 향상하는 최선의 방법은 아니다. 직간접적으로 메모리에 관련된, 알고리즘의 성능에 상당한 영향을 미칠 수 있는 다른 방법이 있다. 이 방식을 설명하기에 앞서 먼저 캐싱을 설명해보자.

#### 캐싱

캐싱이란 두 데이터 저장소가 서로 읽기/쓰기 속도가 다를 때 컴퓨터 시스템의 많은 부분에서 사용되는 모든 비슷한 기법을 가리키는 일반적인 용어이다. 예를 들면 CPU 는 수많은 내부 레지스터가 있고 이 레지스터는 읽기 쓰기 작업을 빠르게 수행한다. 게다가 CPU는 메인 메모리로부터 데이터를 가져와야만 하는데, 이 작업은 레지스터보다 훨신 더 느리다. 이때 캐싱 메커니즘이 필요하다. 캐싱을 사용하지 않는다면 메인 메모리의 더 느린 속도가 우세해질것이고, CPU 의 빠른 연산 속도를 가릴 것이다.

데이터베이스 파일을 다루는 경우도 도 다른 사례에 해당한다. 데이터베이스 파일은 보통 외장 하드 디스크에 저장되는데, 하드 디스크는 메인 메모리보다 훨씬 더 느리며 파일은 크기 순서대로 외장 디스크에 저장된다. 여기에 캐싱 메커니즘이 꼭 필요하다. 캐싱을 사용하지 않는다면, 가장 느린 속도가 우세해져서 전체 시스템의 속도가 느린 족에 맞춰진다.

 많은 항목을 포함하는 느린 저장소가 있다고 가정해보자. 그리고 다른 저장소는 더 빠르지만 제한된 수의 항목만 가질 수 있다고 해보자. 바로 이것이 트레이드오프에 해당한다. 더 빠르지만 더 작은 저장소는 __캐시__ 라고 할 수 있다. 빠른 저장소보다는 더 느린 저장소에서 항목을 가져오고, 더 빠른 저장소에서 해당 항목을 처리하는 편이 더 합리적일 것이다. 단지 그게 더 빠르기 때문이다.

때로는 더 많은 항목을 가져오기 위해 더 느린 저장소로 가야한다. 이때 느린 저장소에서 항목을 단 하나만 가져오지는 않을 것이 확실하다. 너무 비효율적이기 때문이다. 그보다는 항목의 버킹을 더 빠른 저장소에서 가져오는 편이 낫다. 일반적으로 항목은 더 빠른 저장소에 캐시된다.

느린 저장에서 다른 항목을 로드해야 하는 어떤 한 항목을 처리한다고 가정해보자. 우선 떠오르는 것은 지금 캐시 내부에 있을, 최근에 가져온 여러 버킹 중에서 필요한 항목을 검색하는 일이다.

만약 캐시에서 항목을 찾았다면 더 이상 느린 저장소에서 항목을 가져올 필요가 없으며 이를 __hit__ 라고 한다. 만약 캐시 저장소에 항목이 없다면 느린 저장소로 가야 하고,캐시 메모리 내에서 다른 항목들에 대한 버킹을 읽어야 한다. 이는 __miss__ 이라고 한다. 캐시가 더 적중할 때마다 성능은 더 좋아진다는 것이 명백하다.

앞의 설명은 CPU 캐시와 메인 메모리에 적용할 수 있다. CPU 캐시는 메인 메모리로부터 최근의 명령어와 데이터를 저장하는 데, 메인 메모리는 CPU 캐시 메모리에 비해 느리다.



#### 캐시 친화적 코드

CPU가 명령어를 실행할 때는 우선 필요한 데이터를 모두 가져온다. 데이터는 메인 메모리의 특정 주소에 저장되며 이 주소는 명령어에 의해 결정된다.

연산하기 전에 데이터는 CPU 레지스터로 전송되어야 한다. 하지만 보통 CPU는 가져와야 한다고 예상하는 것보다 더 많은 블록을 가져와서 캐시에 넣는다.

그다음으로 어떤 값에서 이전의 주소에 대한 __근접성__ 이 필요하다면, 이 값은 캐시 내에 존재해야만 하고, 그러면 CPU는 메인 메모리 대신 캐시를 사용할 수 있다. 이 방식은 메인 메모리로부터 값을 읽는 것보다 훨씬 더 빠르다. 앞 절에서 설명한 대로 이것이 __캐시 적중__ 이다. 만약 CPU 캐시에서 주소를 찾을 수 없다면 __캐시 실패__ 에 해당한다. 이때 CPU는 대상 주소를 읽고자 메인 메모리에 접근해서 필요한 데이터를 가져와야 하며 이 방식은 상당히 느리다. 일반적으로 캐시 적중률이 높으면 실행이 더 빠르다.

하지만 CPU는 왜 이웃 주소를 가져와야 할까? 이는 __지역성의 원리 the princple of locality__ 때문이다. 컴퓨터 시스템에서는 보통 같은 이웃에 위치한 데이터가 더 자주 접근된다고 관찰된다. 그래서 CPU는 이 원리에 따라 지역 참조로부터 데이터를 더 많이 가져온다. 만약 알고리즘이 이를 잘 활용한다면, CPU가 알고리즘을 더 빨리 실행할 수 있다. 이러한 이유로 이런 알고리즘을 __캐시 친화적 알고리즘__ 이라고 일컫는다.



```c
// 캐시 친화적 코드와 비 캐시 친화적 코드의 성능
# include <stdio.h>
# include <stdlib.h>
# include <string.h>

void fill(int * matrix, int rows, int columns) {
    int couter = 1;
    for (int i = 0; i < rows; i++){
        for (int j = 0; j < columns; ) {
            *(matrix + i * columns + j) = counter;
        }
        counter++;
    }
}

void print_matrix(int *matrix, int rows, int columns) {
    int counter = 1;
    for (int i = 0; i < rows; i++){
        for (int j = 0; j < columns; ) {
            printf("%d ", *(matrix + i * columns + j));
        }
        printf("\n");
    }
}

void print_flat(int* matrix, int rows, int columns) {
    printf("Flat matrix: ");
    for (int i = 0; i < (rows * columns); i++){
        printf("%d ", *(matrix + i));
        }
        printf("\n");
    }
}

int friendly_sum(int *matrix, int rows, int columns) {
    int sum = 0;
    for (int i = 0; i < rows; i++){
        for (int j = 0; j < columns; ) {
            sum += *(matrix + i * columns + j);
        }
    }
    return sum;
}

int not_friendly_sum(int *matrix, int rows, int columns) {
    int sum = 0;
    for (int j = 0; j < column; j++){
        for (int i = 0; i < rows; i++) {
            sum += *(matrix + i * columns + j);
        }
    }
    return sum;
}

int main(int argc, char** argv){
    if (argc < 4) {
        printf("Usage: %s [print|fiendly-sum|not-friendly-sum] ");
        printf("[number-of-rows] [number-of-columns]\n", argv[0]);
        exit(1);
    }
    char * operation = argv[1];
    int rows = atol(argv[2]);
    int columns = atol(argv[3]);
    
    int *matrix = (int*)malloc(rows * columns * sizeof(int));
    fill(matrix, rows, columns);
    
    if (strcmp(operation, "print") == 0) {
        print_matrix(matrix, rows, columns);
        print_flaat(matrix, rows, columns);
    }
    else if (strcmp(operation, "friendly-sum") == 0) {
        int sum = friendly_sum(matrix, rows, columns);
        printf("Friendly sum: %d\n", sum);
    }
    else if (strcmp(operation, "not_friendly-sum") == 0) {
        int sum = not_friendly_sum(matrix, rows, columns);
        printf("Not Friendly sum: %d\n", sum);
    }
    else {
        printf("FATAL: Not supported operation!\n");
        exit(1);
    }
    free(matrix);
    return 0;
}
```

이 프로그램은 행렬의 모든 원소의 합을 계산하고 출력한다. 하지만 그 이상의 일도 수행한다. 사용자는 프로그램에 옵션을 전달해 행동을 변경할 수 있다. fill 함수에 쓰인 알고리즘으로 초기화된 2행 3열의 행렬을 출력하려 한다고 가정해보자. 사용자는 필요한 행과 열의 숫자와 print 옵션을 입력해야 한다.

```shell
$ gcc main.c -o exe.out
$ ./exe.out print 2 3
Matrix:
1 1 1
2 2 2
Flat matrix: 1 1 1 2 2 2
$
```

출력 결과는 행렬의 두 가지 다른 프린트로 구성된다. 첫 번째 행렬을 2차원으로 표현한 것이고 두 번째는 같은 행렬을 한 행으로 표현했다. 보다시피 행렬은 메모리에 __행-우선순위__ 로 저장되었다. 이는 행렬이 한 행씩 저장된다는 의미이다. 그래서 만약 CPU 가 어떤 행에서 뭔가를 가져오려고 한다면, 그 행의 모든 원소 또한 가져와야 한다. 따라서 __열-우선__ 이라 아니라 행-우선순위에서 이 코드의 합계 연산이 더 잘 수행된다.

다음으로 20000개의 행과 20000개의 열을 갖는 행렬의 합계를 수행하는 데 걸리는 시간을 비교해볼 수 있다. 보다시피 차이가 명확합니다.

```shell
$ time ./exe.out frinedly-sum 20000 20000
Friendly sum: 158447424

real 0m5.192s
user 0m3.142s
sys 0m1.765s

$ time ./exe.out not-friendly-sum 20000 20000
Not friendlt sum: 158447424
real 0m15.375s
user 0m14.031s
sys 0m0.791s
$
```

측정된 시간 사이의 차이는 약 10초이다. 프로그램은 clang 컴파일러를 사용해 macOS 머신에서 컴파일 되었다. 이 차이는 같은 로직과 같은 양의 메모리를 사용하더라도, 행렬의 원소에 접근하는 순서를 다르게 선택하면 시간이 훨씬 더 오래 걸릴 수 있다는 뜻이다. 이 예제는 캐시 친화적 코드의 효과를 명확히 나타낸다.

```
time 유틸리티는 모든 유닉스 계열 운영체제에서 사용할 수 있다. 프로그램이 종료될 떄까지 걸리는 시간을 측정할 떄 사용할 수 있다.
```



#### 할당 및 해제 비용

여기서 힙 메모리의 할당과 해제의 비용을 구체적으로 이야기하겠다. 힙 메모리 해제와 할당작업은 시간과 메모리를 소비하며 대체로 비용이 더 필요하다. 특히 초당 여러 번 힙 메모리 블록을 할당하고 해제할 필요가 있다면 그렇다. 상대적으로 더 빠르며 할당 자체에 메모리가 더 필요하지 않은 스택 할당과는 달리, 힙 할당은 충분한 크기의 비어 있는 메모리 블록을 찾아야 하며 이는 비용이 드는 일이다.

메모리 할당과 해제를 위해 많은 알고리즘이 있으며, 할당과 해제 작업 사이에서는 언제나 타협해야 한다. 빠르게  할당하고 싶다면 할당 알고르짐에서 메모리를 더 많이 사용해야 한다. 반대도 마찬가지이다. 만약 메모리를 덜 사용하고 싶다면 시간이 더 드는 느린 할당을 선택해야 한다.



겉으로는 별 문제 없어 보이지만 실제로 치명적일 수 있는 이 문제의 해결책은 무엇일까? 답은 간단하다 할당과 해제를 최소화하는 것이다. 이는 힙 할당을 빠른 속도로 해야 하는 몇몇 프로그램에서는 불가능한 것처럼 보인다. 이러한 프로그램은 대체로 힙 메모리의 큰 블록을 할당하며 스스로 관리하려고 한다. 이것은 마치 커다란 힙 메모리 블록 위에 놓은 할당과 해제의 로직에 대한 추가 레이어를 갖는 것과도 같다.



#### 메모리 풀

앞에서 설명한 대로 메모리 할당과 해제는 비용이 든다. 미리 할당되어 고정된 크기의 힙 메모리 블록의 풀을 사용하는 방법은 할당의 횟수를 줄이고 성능을 약간 향상한다. 풀의 각 블록은 일반적으로 식별자를 가지며, 이 식별자는 풀 관리를 위해 설계된 API를 통해 얻을 수 있다. 또한 필요가 없어지면 이 블록은 나중에 해제될 수 있다. 할당된 메모리 양이 고정된 채 남으므로, 메모리가 제한적인 환경에서 알고리즘이 결정돈적인 행위를 하려고 할 때 탁월한 선택이다.



## 5.4 마무리

5장에서는 주로 스택과 힙 세그먼트를 다뤘으며 이들 세그먼트가 사용되는 방식을 살펴봤다.

이어사 메모리 제한적인 환경에 관해 논의했으며 캐싱과 메모리 풀 같은 기법이 성능을 향상하는 방식을 알아봤다.

- 스택 및 힙 세그먼트 모두를 검사할 때 사용되는 도구와 기법을 설명했다.
- 디버거를 소개했으며, 메모리와 관련된 문제를 고치는 메인 디버거로 dbg를 사용했다.
- 메모리 프로파일러를 설명했고, 실행할 때 발생하는 누수나 허상 포인터와 같은 문제를 발견하기 위해 valgrind를 사용했다.
- 스택 변수와 힙 블록의 수명을 비교했으며 그러한 메모리 블록의 수명을 판단하는 법을 설명했다.
- 스택 변수의 경우 메모리 관리가 자동이지만 힙 블록에서는 전적으로 수동이라는 점을 알아봤다.
- 스택 변수를 다룰 때 저지르는 흔한 실수를 살펴봤다.
- 제한된 환경을 논의했으며 이러한 환경에서 메모리를 어떻게 튜닝할 수 있는지 알아봤다.
- 성능이 더 나은 환경과 성능을 얻고자 할 떄 사용할 수 있는 기법은 무엇이 잇는지 설명했다.



다음 4개 장은 C 언어의 객체지향을 다룬다. 객체지향과 C가 무관한 듯 보일 수 있지만, 사실 C 에서도 객체지향적인 코드를 작성할 수 있다. 이들 장에서는 객체지향 방식에서 문제를 설계하고 해결하는 알맞은 방식을 소개한다. 그리고 읽을 수 잇으면서도 올바른 C 코드를 작성할 수 잇는 가이드도 제공한다.







