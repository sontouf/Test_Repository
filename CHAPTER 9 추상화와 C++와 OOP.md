# CHAPTER 9 추상화와 C++와 OOP

9장은 C의 OOP에 관한 마지막 장이다. 이번 장에서는 남은 주제를 다루며 새로운 패러다임을 소개한다. 또한 C++을 살펴보며 C++ 내부에서 객체지향을 구현하는 방식을 살펴보자.

- 먼저 추상화를 다룬다. 추상화는 상속과 다형성의 설명에서 이어지는 내용이며 C의 OOP에 관한 마지막 주제이다. 다양한 컴포넌트 간의 최대 확장성 과 최소 의존성을 갖는 객체 모델을 설계할 때 추상화가 어떤 도움이 되는지 보여준다.
- 유명한 C++ 컴파이리러 중 g++ 에서 객체지향 개념이 구현된 방식을 설명한다. 이를 통해 여기서 지금까지  설명한 접근법이 g++ 가 객체지향 개념을 제공하기 위해 취한 접근법과 얼마나 밀접하게 부합하는 지 알 수 있다.



## 9.1 추상화

추상화는 과학 및 공학의 다양한 분야에서 아주 일반적인 의미를 갖는다. 하지만 프로그래밍, 특히 OOP에서 추상화란 본질적으로 __추상 자료형 abstract data type__ 을 다루는 것이다. 클래스 기반의 객체지향에서 추상 자료형은 __추상 클래스__ 와 같다. 추상 클래스는 객체로 만들 수 없는 특별한 클래스이다. 추상 클래스는 객체를 생성할 때 사용하기에는 아직 준비되지도 완료되지도 않은 상태이다. 그러면 왜 이러한 클래스나 자료형이 필요한  것일까? 추상 자료형 및 일반 자료형으로 코드의 여러 부분 간에 강한 의존성이 생기지 않기 때문이다.

예를 들면 인간 과 사과 클래스 간에는 다음과 같은 관계가 성립할 수 있다.

- 인간 클래스의 객체는 사과 클래스의 객체를 먹는다.
- 인간 클래스의 객체는 오렌지 클래스의 객체를 먹는다

인간 클래스의 객체가 먹을 수 있는 객체가 사과나 오렌지 이외에도 더 많아진다면, 인간 클래스에 관계를 추가해야 한다. 하지만 그 대신 사과와 오렌지 클래스 모두 과일이라는 부모 추상 클래스를 만들고, 인간과 과일 간의 관계만 설정할 수 있다. 그러므로 앞의 두 문장은 다음과 같은 한 문장으로 만들 수 있다.

- 인간 클래스의 객체는 과일 클래스의 서브타입에 있는 객체를 먹는다.

과일 클래스는 모양, 맛, 냄새, 색상 그리고 특정 과일에 대한 더 많은 여러 속성 정보가 부족하므로 추상적이다. 사과나 오렌지 클래스가 있을 때만 다른 속성의 정확한 값을 알 수 있다. 이러한 사과와 오렌지 클래스를 __구상 자료형__ 이라고 한다.

더 추상적으로 만들 수도 있다. 인간 클래스는 샐러드나 초콜릿도 먹을 수 있다. 따라서 다음과 같이 말할 수 있다.

- 인간 유형의 객체는 먹을 수 있는 것 클래스의 서브타입 객체를 먹는다.

먹을 수 있는 것 클래스(Eatable) 의 추상화 수준은 과일(Fruit) 클래스보다 훨씬 더 높다. 추상화는 구상 자료형에 대한 의존성이 최소인 객체 모델을 설계하는 가장 좋은 방식이다. 그리고 시스템에 구상 자료형을 더 많이 도입할 떄 추상화는 객체 모델의 미래 확장성을 최대화한다.

앞의 예와 관련해 인간(Human)이 먹는 자(Eater) 라는 사실을 이용해서 추상화를 더 추가할 수 있다. 그러면 문장을 더 추상적으로 만들 수 있다.

- 먹는 자 클래스의 서브타입인 객체는 먹을 수 있는것 클래스의 서브타입인 객체를 먹는다.

객체 모델의 모든 것을 계속해서 추상화할 수 있으며, 문제를 해결하는 데 필요한 수준보다 더 추상적인 추상 자료형을 찾아낼 수 있습니다. 이는 일반적으로 __과도한 추상화__ 이라고 한다. 현재 또는 미래에 필요한 사항에 실제로 적용되지 않는 추상 자료형을 생성하려고 할 때마다 과도한 추상화가 발생한다. 과도한 추상화는 아무리 이득이 있다고 해도 문제를 일으킬 수 있으므로 반드시 피해야 한다.

필요한 추상화의 정도에 대한 일반적인 가이드는 __추상화 원칙__ 에서 찾을 수 있다. 인용된 부분에서는 다음과 같이 간단히 서술한다.

```
프로그램의 중요한 각 기능은 소스코드의 오직 한 부분에서만 구현되어야 한다. 비슷한 기능을 별개의 코드에서 수행할 때는 일반적으로 다양한 부분을 추상화해 하나로 결합하는 편이 좋다.
```

언뜻 보기에는 이 문장에서 객체지향이나 상속에 관한 티가 잘 안 날지도 모른다. 하지만 조금 더 생각해보면 이 원리에 따라 상속했음을 알 수 있다. 따라서 일반적으로 특정 로직이 변한다고 예상하지 않은 경우에는 추상화를 도입할 필요가 없다.



다형성 역시 중요한 역할을 한다. 추상 자료형에는 해당 추상화 수준에서 기본 구현을 __갖지 못하는__ 행위가 있다. 예를 들면 먹을 수 있는 것 클래스에서 eatable_get_taste 와 같은 행위 함수를 사용해 구현된 속성으로서의 맛은 먹을 수 있는 것 객체를 다룰 때 정확한 값을 가질 수 없다. 다시 말해서 eatable_get_taste 행위 함수를 정의하는 법을 모른다면 Eatable 클래스로부터 직접 객체를 생성할 수 없다.

이 함수는 자식 클래스가 충분히 구체적일 때만 정의할 수 있다. 예를 들어 사과 객체는 맛에 대해 단맛을 반환해야 한다는 점을 알고 있다. (여기서 모든 사과는 달다고 가정했다.) 다형성은 바로 이 지점에서 도움이 된다. 다형성은 자식 클래스가 부모 행위를 오버라이딩할 수 있게 하며, 예를 들면 적절한 맛 같은 것을 반환하도록 한다.

이전 장에서는 자식 클래스가 오버라이딩할 수 있는 행위 함수를 __가상 함수__ 이라고 불렀다. 참고로 가상 함수는 정의가 아예 없을 수도 있다. 물론 이러한 가상 함수는 소유자 클래스를 추상화한다.

특정 수준에서 더욱 추상화해서, 속성과 기본 정의를 갖지 않는 가상 함수만을 포함하는 클래스까지 도달했다. 이러한 클래스를 __인터페이스__ 라고 한다. 즉, 인터페이스는 기능은 노출하지만 구현은 전혀 노출하지 않으며, 일반적으로 소프트웨어 프로젝트에서 다양한 컴포넌트 사이의 의존성을 만드는 데 사용한다. 앞의 예에서는 먹는 자와 먹을 수 있는 것 클래스가 인터페이스이다.

참고로 추상 자료형과 마찬가지로 인터페이스로는 객체를 생성할 수 없다. 다음은 C 코드에서 이것이 불가능한 이유를 나타낸다. 다음은 상속과 다형성을 구현하고자 8장에서 소개한 기법을 이용해 C에서 먹을 수 잇는 것 인터페이스를 작성한 코드이다.

```c
// C 로 작성한 먹을 수 있는 것(Eatable) 인터페이스

typedef enum {SWEET, SOUR} taste_t;

// 함수 포인터 자료형
typedef taste_t (*get_taste_func_t)(void*);

typedef struct {
    // 가상 함수에 대한 정의를 가리키는 포인터
    get_taste_func_t get_taste_func;
} eatable_t;

eatable_t* eatable_new() {...};
void eatable_ctor(eatable_t* eatable) {
    // 가상 함수에 대한 기본 정의는 없다.
    eatable->get_taste_func = NULL:
}

// 가상 행위 함수
taste_t eatable_get_taste(eatable_t* eatable) {
    return eatable->get_taste_func(eatable);
}
```

생성자 함수에서 get_taste_func 포인터를 NULL 로 두었다. 그러므로 eatable_get_taste 가상 함수를 호출하면 세그멘테이션 오류가 발생한다. 인터페이스에 대한 정의와 설계관점에서 이해할 수 있는 이유 외에는 기본적으로 먹을 수 있는 것 인터페이스에서 객체를 생성해서는 안된다.

다음은 먹을 수 있는 것 인터페이스에서 객체를 생성하는 것이 C의 관점에서는 가능하지만 충돌이 발생하며, 절대 해서는 안되는 일이라는 점을 보여준다.

```c
// 먹을 수 있는 것 인터페이스로 객체를 생성하고 순수 가상 함수를 호출하면 세그멘테이션 오류 발생
eatable_t *eatable = eatable_new();
eatable_ctor(eatable);
taste_t taste = eatable_get_taste(eatable); // 세그멘테이션 오류
free(eatable);
```

추상 자료형으로 객체를 생성하지 않으려면 클래스의 공용 인터페이스에서 __할당자 함수__ 를 제거한다. C에서 상속을 구현하기 위해 8장에서 택한 접근법을 기억한다면, 할당자 함수를 제거함으로써 오직 자식 클래스만이 부모의 속성 구조체로부터 객체를 생성할 수 있다.

그러면 외부 코드가 더 이상 부모의 속성 구조체로부터 객체를 생성할 수 없다. 예를 들어, 앞의 예제에서 어떠한 외부 코드도 구조체 eatable_t 로부터 객체를 생성하지 못하게 하려고 한다. 그러려면 속성 구조체를 선언 앞에 두어 불완전 자료형으로 만들어야 한다. 그런 다음 공용 메모리 할당자인 eatable_new 를 클래스에서 제거해야 한다.

C에서 추상 클래스를 갖기 위해 필요한 사항을 요약하면, 해당 추상화 수준에서 기본 정의를 갖도록 한 가상 함수 포인터를 NULL  로 만들어야 한다. 매우 높은 추상화 수준에서는 모든 함수 포인터가 NULL인 인터페이스를 갖는다. 추상 자료형으로부터 외부 코드가 객체를 생성하지 못하게 하려면 공용 인터페이스에서 할당자 함수를 제거해야 한다.



## 9.2 C++ 의 객체지향 구성물

먼저 C 에서 객체지향 코드를 작성하는 기법을 다루고, 결론으로 넘어가기 전에 C++에서도 동일한 프로그램을 작성하겠다.



### 9.2.1 캡슐화

C++ 컴파일러를 자세히 들여다보기는 어렵고, 컴파일러가 최종 실행 파일을 만들기 위해서 지금까지 알아본 기법을 어떻게 사용하는지 살펴보는 것도 어렵다. 하지만 이를 확인할 때 사용할 수 있는 영리한 방법이 하나 있다. 서로 비슷한 C 와 C++ 두 프로그램에 대해 생성된 어셈블리 명령어를 비교하는 것이다.

그 과정에서 결국 C++ 컴파일러가 이전 장에서 다룬 OOP 기법을 사용하는 C 프로그램과 동일한 어셈블리 명령어를 생성한다는 점을 보여주고자 한다.

서로 같은 간단한 객체지향 로직을 다루는 C 와 C++ 프로그램을 보여준다. 이 예제에는 Rectangle 클래스가 있는데, 이 클래스는 면적을 계산하는 행위 함수를 갖는다.

```c
// main1.c
#include <stdio.h>

typedef struct {
    int width;
    int length;
} rect_t;

int rect_area(rect_t* rect) {
    return rect->width * rect->length;
}

int main(int argc, char** argv) {
    rect_t r;
    r.width = 10;
    r.length = 25;
    int area = rect_area(&r);
    printf("Area: %d\n", area);
    return 0;
}
```

```c++
// main2.c
#include <iostream>

class Rect {
    public:
    	int Area() {
            return width * length;
        }
    	int width;
    	int length;
}

int main(int argc, char** argv) {
    Rect r;
    r.width = 10;
    r.length = 25;
    int area = r.Area();
    std::cout << "Area: " << area << std::endl;
    return 0;
}
```

```shell
$ gcc main1.c -o exe1_c.s
$ g++ main2.c -o exe2_cpp.s
```

이제 파일을 덤프해 행위 함수의 정의를 살펴보자. exe1_c.s 에서는 rect_area 심벌을 찾아야 하고, exe2_cpp.s 에서는 _ZN4Rect4AreaEv 심벌을 봐야한다. 참고로 C++ 은 심벌 이름을 맹글로 만드는 데, 이 이상한 심벌을 찾기 위해서이다.



```shell
// rect_area 함수에 대해 생성된 어셈블리 코드
$ cat exe1_c.s
...
rect_area:
.LFB0:
	.cfi_startproc
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movq	%rdi, -8(%rbp)
	movq	-8(%rbp), %rax
	movl	(%rax), %edx
	movq	-8(%rbp), %rax
	movl	4(%rax), %eax
	imull	%edx, %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
...
$
```

다음은 Rect::Area 함수에 대해 생성된 어셈블리 명령어이다.

```shell
// Area 함수에 대해 생성된 어셈블리 명령어이다.
$ cat exe2_cpp.s
...
rect_area:
.LFB0:
	.cfi_startproc
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movq	%rdi, -8(%rbp)
	movq	-8(%rbp), %rax
	movl	(%rax), %edx
	movq	-8(%rbp), %rax
	movl	4(%rax), %eax
	imull	%edx, %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
...
$
```

믿을 수  없을 정도로 완전히 똑같다. C++ 코드가 어셈블리 코드로 어떻게 바뀌는지는 잘 모르겠지만, 앞으로 C 함수에 대해 생성된 어셈블리 코드는 매우 높은 정확도로  C++ 함수에 대해 생성된 어셈블리 코드와 거의 같다.

이를 토대로 C++ 컴파일러는 캡슐화를 구현하기 위해 6장에서 암묵적 캡슐화로 소개했던 C의 접근법과 유사한 방식을 사용했다고 결론 지을 수 있다. 암묵적 캡슐화에서 한 것처럼 속성 구조체에 대한 포인터에 첫 번째 인수로 rect_area 함수를 전달했음을 확인할 수 있다.

두 셸 박스에서 어셈블리 명령어를 굵은 폰트로 강ㅇ조한 부분에서 width 와 length 변수는 첫 번째 인수로 전달된 메모리 주소를 추가해 읽는다. 첫 번째 포인터 인수는 호출 규약인 System V ABI 에 따라 %rdi 레지스터에서 찾아볼 수 있다. 그러므로 C++ 가 첫 번쨰 인수로 객체 자신을 가리키는 포인터 인수를 받도록 Area 함수를 변경했다고 추론할 수 있다.

정리하자면, 적어도 이 간단한 예제를 통해 C 와 C++ 가 캡슐화와 관련해 어떻게 밀접하게 연관되는지 살펴봤다. 상속에서도 마찬가지인지 알아보자.



### 9.2.2 상속

상속은 캡슐화보다 알기 쉽다. C++ 에서 자식 클래스의 포인터는 부모 클래스의 포인터로 할당할 수 있다. 또한 자식 클래스는 부모 클래스의 비공개 정의에 접근할 수 있어야 한다.

이러한 두 행위는 C++가 상속을 구현하는 첫 번쨰 접근법을 사용하고 있음을 나타낸다. 이는 8장에서 두 번째 접근법과 함께 다뤘다. 만약 두 접근법을 다시 떠올려봐야 한다면 8장을 참고하자.

하지만 C++ 은 첫 번쨰 접근법에서 지원하지 못하는 다중 상속을 지원하기 때문에 C++ 의 상속은 더 복잡해보인다. 이번 절에서는 예제를 통해 서로 비슷한 두 클래스에서 인스턴스화된 두 객체의 메모리 레이아웃을 점검해본다.



```c
// C의 상속 예 main.c
#include <string.h>

typedef struct {
    char c;
    char d;
} a_t;

typedef struct {
    a_t parent;
    char str[5];
} b_t;

int main(int argc, char** argv) {
    b_t b;
    b.parent.c = 'A';
    b.parent.d = 'B';
    strcpy(b.str, "1234");
    // 메모리 레이아웃을 확인하기 위해 이 행에서 중단점을 설정해야 한다.
    return 0;
}
```

```c
// C++의 상속 예 main.c
#include <string.h>

class A {
    public:
        char c;
        char d;
};

class B {
    public:
    	char str[5];
};

int main(int argc, char** argv) {
    B b;
    b.c = 'A';
    b.d = 'B';
    strcpy(b.str, "1234");
    // 메모리 레이아웃을 확인하기 위해 이 행에서 중단점을 설정해야 한다.
    return 0;
}
```

우선 C 프로그램을 컴파일하고 gdb 로 main 함수의 마지막 행에 중단점을 설정해야 한다. 실행이 중단되면 기존 값뿐만 아니라 메모리 레이아웃도 검사할 수 있다.

``` shell
// gdb 에서 예제의 C 버전 실행하기
$ gcc -g main.c -o exe.out
$ gdb ./exe.out
...
(gdb) b main.c:22
Breakpoint 1 at 0x69e: file main.c, line 22.
(gdb) r
Starting program: .../exe.out

Breakpoint 1, main (argc=1, argv=0x7fffffffe358) at main.c:20
20 return 0;
(gdb) x/7c &b
0x7fffffffe261: 65 'A' 66 'B' 49 '1' 50 '2' 51 '3' 52 '4' 0 '\000'
(gdb) c
[Inferior 1 (process 3759) exited normally]
(gdb) q
$
```









