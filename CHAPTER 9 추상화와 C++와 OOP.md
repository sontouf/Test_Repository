# CHAPTER 9 추상화와 C++와 OOP

9장은 C의 OOP에 관한 마지막 장이다. 이번 장에서는 남은 주제를 다루며 새로운 패러다임을 소개한다. 또한 C++을 살펴보며 C++ 내부에서 객체지향을 구현하는 방식을 살펴보자.

- 먼저 추상화를 다룬다. 추상화는 상속과 다형성의 설명에서 이어지는 내용이며 C의 OOP에 관한 마지막 주제이다. 다양한 컴포넌트 간의 최대 확장성 과 최소 의존성을 갖는 객체 모델을 설계할 때 추상화가 어떤 도움이 되는지 보여준다.
- 유명한 C++ 컴파이리러 중 g++ 에서 객체지향 개념이 구현된 방식을 설명한다. 이를 통해 여기서 지금까지  설명한 접근법이 g++ 가 객체지향 개념을 제공하기 위해 취한 접근법과 얼마나 밀접하게 부합하는 지 알 수 있다.



## 9.1 추상화

추상화는 과학 및 공학의 다양한 분야에서 아주 일반적인 의미를 갖는다. 하지만 프로그래밍, 특히 OOP에서 추상화란 본질적으로 __추상 자료형 abstract data type__ 을 다루는 것이다. 클래스 기반의 객체지향에서 추상 자료형은 __추상 클래스__ 와 같다. 추상 클래스는 객체로 만들 수 없는 특별한 클래스이다. 추상 클래스는 객체를 생성할 때 사용하기에는 아직 준비되지도 완료되지도 않은 상태이다. 그러면 왜 이러한 클래스나 자료형이 필요한  것일까? 추상 자료형 및 일반 자료형으로 코드의 여러 부분 간에 강한 의존성이 생기지 않기 때문이다.

예를 들면 인간 과 사과 클래스 간에는 다음과 같은 관계가 성립할 수 있다.

- 인간 클래스의 객체는 사과 클래스의 객체를 먹는다.
- 인간 클래스의 객체는 오렌지 클래스의 객체를 먹는다

인간 클래스의 객체가 먹을 수 있는 객체가 사과나 오렌지 이외에도 더 많아진다면, 인간 클래스에 관계를 추가해야 한다. 하지만 그 대신 사과와 오렌지 클래스 모두 과일이라는 부모 추상 클래스를 만들고, 인간과 과일 간의 관계만 설정할 수 있다. 그러므로 앞의 두 문장은 다음과 같은 한 문장으로 만들 수 있다.

- 인간 클래스의 객체는 과일 클래스의 서브타입에 있는 객체를 먹는다.

과일 클래스는 모양, 맛, 냄새, 색상 그리고 특정 과일에 대한 더 많은 여러 속성 정보가 부족하므로 추상적이다. 사과나 오렌지 클래스가 있을 때만 다른 속성의 정확한 값을 알 수 있다. 이러한 사과와 오렌지 클래스를 __구상 자료형__ 이라고 한다.

더 추상적으로 만들 수도 있다. 인간 클래스는 샐러드나 초콜릿도 먹을 수 있다. 따라서 다음과 같이 말할 수 있다.

- 인간 유형의 객체는 먹을 수 있는 것 클래스의 서브타입 객체를 먹는다.

먹을 수 있는 것 클래스(Eatable) 의 추상화 수준은 과일(Fruit) 클래스보다 훨씬 더 높다. 추상화는 구상 자료형에 대한 의존성이 최소인 객체 모델을 설계하는 가장 좋은 방식이다. 그리고 시스템에 구상 자료형을 더 많이 도입할 떄 추상화는 객체 모델의 미래 확장성을 최대화한다.

앞의 예와 관련해 인간(Human)이 먹는 자(Eater) 라는 사실을 이용해서 추상화를 더 추가할 수 있다. 그러면 문장을 더 추상적으로 만들 수 있다.

- 먹는 자 클래스의 서브타입인 객체는 먹을 수 있는것 클래스의 서브타입인 객체를 먹는다.

객체 모델의 모든 것을 계속해서 추상화할 수 있으며, 문제를 해결하는 데 필요한 수준보다 더 추상적인 추상 자료형을 찾아낼 수 있습니다. 이는 일반적으로 __과도한 추상화__ 이라고 한다. 현재 또는 미래에 필요한 사항에 실제로 적용되지 않는 추상 자료형을 생성하려고 할 때마다 과도한 추상화가 발생한다. 과도한 추상화는 아무리 이득이 있다고 해도 문제를 일으킬 수 있으므로 반드시 피해야 한다.

필요한 추상화의 정도에 대한 일반적인 가이드는 __추상화 원칙__ 에서 찾을 수 있다. 인용된 부분에서는 다음과 같이 간단히 서술한다.

```
프로그램의 중요한 각 기능은 소스코드의 오직 한 부분에서만 구현되어야 한다. 비슷한 기능을 별개의 코드에서 수행할 때는 일반적으로 다양한 부분을 추상화해 하나로 결합하는 편이 좋다.
```

언뜻 보기에는 이 문장에서 객체지향이나 상속에 관한 티가 잘 안 날지도 모른다. 하지만 조금 더 생각해보면 이 원리에 따라 상속했음을 알 수 있다. 따라서 일반적으로 특정 로직이 변한다고 예상하지 않은 경우에는 추상화를 도입할 필요가 없다.



다형성 역시 중요한 역할을 한다. 추상 자료형에는 해당 추상화 수준에서 기본 구현을 __갖지 못하는__ 행위가 있다. 예를 들면 먹을 수 있는 것 클래스에서 eatable_get_taste 와 같은 행위 함수를 사용해 구현된 속성으로서의 맛은 먹을 수 있는 것 객체를 다룰 때 정확한 값을 가질 수 없다. 다시 말해서 eatable_get_taste 행위 함수를 정의하는 법을 모른다면 Eatable 클래스로부터 직접 객체를 생성할 수 없다.

이 함수는 자식 클래스가 충분히 구체적일 때만 정의할 수 있다. 예를 들어 사과 객체는 맛에 대해 단맛을 반환해야 한다는 점을 알고 있다. (여기서 모든 사과는 달다고 가정했다.) 다형성은 바로 이 지점에서 도움이 된다. 다형성은 자식 클래스가 부모 행위를 오버라이딩할 수 있게 하며, 예를 들면 적절한 맛 같은 것을 반환하도록 한다.

이전 장에서는 자식 클래스가 오버라이딩할 수 있는 행위 함수를 __가상 함수__ 이라고 불렀다. 참고로 가상 함수는 정의가 아예 없을 수도 있다. 물론 이러한 가상 함수는 소유자 클래스를 추상화한다.

특정 수준에서 더욱 추상화해서, 속성과 기본 정의를 갖지 않는 가상 함수만을 포함하는 클래스까지 도달했다. 이러한 클래스를 __인터페이스__ 라고 한다. 즉, 인터페이스는 기능은 노출하지만 구현은 전혀 노출하지 않으며, 일반적으로 소프트웨어 프로젝트에서 다양한 컴포넌트 사이의 의존성을 만드는 데 사용한다. 앞의 예에서는 먹는 자와 먹을 수 있는 것 클래스가 인터페이스이다.

참고로 추상 자료형과 마찬가지로 인터페이스로는 객체를 생성할 수 없다. 다음은 C 코드에서 이것이 불가능한 이유를 나타낸다. 다음은 상속과 다형성을 구현하고자 8장에서 소개한 기법을 이용해 C에서 먹을 수 잇는 것 인터페이스를 작성한 코드이다.

```c
// C 로 작성한 먹을 수 있는 것(Eatable) 인터페이스

typedef enum {SWEET, SOUR} taste_t;

// 함수 포인터 자료형
typedef taste_t (*get_taste_func_t)(void*);

typedef struct {
    // 가상 함수에 대한 정의를 가리키는 포인터
    get_taste_func_t get_taste_func;
} eatable_t;

eatable_t* eatable_new() {...};
void eatable_ctor(eatable_t* eatable) {
    // 가상 함수에 대한 기본 정의는 없다.
    eatable->get_taste_func = NULL:
}

// 가상 행위 함수
taste_t eatable_get_taste(eatable_t* eatable) {
    return eatable->get_taste_func(eatable);
}
```

생성자 함수에서 get_taste_func 포인터를 NULL 로 두었다. 그러므로 eatable_get_taste 가상 함수를 호출하면 세그멘테이션 오류가 발생한다. 인터페이스에 대한 정의와 설계관점에서 이해할 수 있는 이유 외에는 기본적으로 먹을 수 있는 것 인터페이스에서 객체를 생성해서는 안된다.

다음은 먹을 수 있는 것 인터페이스에서 객체를 생성하는 것이 C의 관점에서는 가능하지만 충돌이 발생하며, 절대 해서는 안되는 일이라는 점을 보여준다.

```c
// 먹을 수 있는 것 인터페이스로 객체를 생성하고 순수 가상 함수를 호출하면 세그멘테이션 오류 발생
eatable_t *eatable = eatable_new();
eatable_ctor(eatable);
taste_t taste = eatable_get_taste(eatable); // 세그멘테이션 오류
free(eatable);
```

추상 자료형으로 객체를 생성하지 않으려면 클래스의 공용 인터페이스에서 __할당자 함수__ 를 제거한다. C에서 상속을 구현하기 위해 8장에서 택한 접근법을 기억한다면, 할당자 함수를 제거함으로써 오직 자식 클래스만이 부모의 속성 구조체로부터 객체를 생성할 수 있다.

그러면 외부 코드가 더 이상 부모의 속성 구조체로부터 객체를 생성할 수 없다. 예를 들어, 앞의 예제에서 어떠한 외부 코드도 구조체 eatable_t 로부터 객체를 생성하지 못하게 하려고 한다. 그러려면 속성 구조체를 선언 앞에 두어 불완전 자료형으로 만들어야 한다. 그런 다음 공용 메모리 할당자인 eatable_new 를 클래스에서 제거해야 한다.

C에서 추상 클래스를 갖기 위해 필요한 사항을 요약하면, 해당 추상화 수준에서 기본 정의를 갖도록 한 가상 함수 포인터를 NULL  로 만들어야 한다. 매우 높은 추상화 수준에서는 모든 함수 포인터가 NULL인 인터페이스를 갖는다. 추상 자료형으로부터 외부 코드가 객체를 생성하지 못하게 하려면 공용 인터페이스에서 할당자 함수를 제거해야 한다.



## 9.2 C++ 의 객체지향 구성물

먼저 C 에서 객체지향 코드를 작성하는 기법을 다루고, 결론으로 넘어가기 전에 C++에서도 동일한 프로그램을 작성하겠다.



### 9.2.1 캡슐화

C++ 컴파일러를 자세히 들여다보기는 어렵고, 컴파일러가 최종 실행 파일을 만들기 위해서 지금까지 알아본 기법을 어떻게 사용하는지 살펴보는 것도 어렵다. 하지만 이를 확인할 때 사용할 수 있는 영리한 방법이 하나 있다. 서로 비슷한 C 와 C++ 두 프로그램에 대해 생성된 어셈블리 명령어를 비교하는 것이다.

그 과정에서 결국 C++ 컴파일러가 이전 장에서 다룬 OOP 기법을 사용하는 C 프로그램과 동일한 어셈블리 명령어를 생성한다는 점을 보여주고자 한다.

서로 같은 간단한 객체지향 로직을 다루는 C 와 C++ 프로그램을 보여준다. 이 예제에는 Rectangle 클래스가 있는데, 이 클래스는 면적을 계산하는 행위 함수를 갖는다.

```c
// main1.c
#include <stdio.h>

typedef struct {
    int width;
    int length;
} rect_t;

int rect_area(rect_t* rect) {
    return rect->width * rect->length;
}

int main(int argc, char** argv) {
    rect_t r;
    r.width = 10;
    r.length = 25;
    int area = rect_area(&r);
    printf("Area: %d\n", area);
    return 0;
}
```

```c++
// main2.c
#include <iostream>

class Rect {
    public:
    	int Area() {
            return width * length;
        }
    	int width;
    	int length;
}

int main(int argc, char** argv) {
    Rect r;
    r.width = 10;
    r.length = 25;
    int area = r.Area();
    std::cout << "Area: " << area << std::endl;
    return 0;
}
```

```shell
$ gcc main1.c -o exe1_c.s
$ g++ main2.c -o exe2_cpp.s
```

이제 파일을 덤프해 행위 함수의 정의를 살펴보자. exe1_c.s 에서는 rect_area 심벌을 찾아야 하고, exe2_cpp.s 에서는 _ZN4Rect4AreaEv 심벌을 봐야한다. 참고로 C++ 은 심벌 이름을 맹글로 만드는 데, 이 이상한 심벌을 찾기 위해서이다.



```shell
// rect_area 함수에 대해 생성된 어셈블리 코드
$ cat exe1_c.s
...
rect_area:
.LFB0:
	.cfi_startproc
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movq	%rdi, -8(%rbp)
	movq	-8(%rbp), %rax
	movl	(%rax), %edx
	movq	-8(%rbp), %rax
	movl	4(%rax), %eax
	imull	%edx, %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
...
$
```

다음은 Rect::Area 함수에 대해 생성된 어셈블리 명령어이다.

```shell
// Area 함수에 대해 생성된 어셈블리 명령어이다.
$ cat exe2_cpp.s
...
rect_area:
.LFB0:
	.cfi_startproc
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movq	%rdi, -8(%rbp)
	movq	-8(%rbp), %rax
	movl	(%rax), %edx
	movq	-8(%rbp), %rax
	movl	4(%rax), %eax
	imull	%edx, %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
...
$
```

믿을 수  없을 정도로 완전히 똑같다. C++ 코드가 어셈블리 코드로 어떻게 바뀌는지는 잘 모르겠지만, 앞으로 C 함수에 대해 생성된 어셈블리 코드는 매우 높은 정확도로  C++ 함수에 대해 생성된 어셈블리 코드와 거의 같다.

이를 토대로 C++ 컴파일러는 캡슐화를 구현하기 위해 6장에서 암묵적 캡슐화로 소개했던 C의 접근법과 유사한 방식을 사용했다고 결론 지을 수 있다. 암묵적 캡슐화에서 한 것처럼 속성 구조체에 대한 포인터에 첫 번째 인수로 rect_area 함수를 전달했음을 확인할 수 있다.

두 셸 박스에서 어셈블리 명령어를 굵은 폰트로 강ㅇ조한 부분에서 width 와 length 변수는 첫 번째 인수로 전달된 메모리 주소를 추가해 읽는다. 첫 번째 포인터 인수는 호출 규약인 System V ABI 에 따라 %rdi 레지스터에서 찾아볼 수 있다. 그러므로 C++ 가 첫 번쨰 인수로 객체 자신을 가리키는 포인터 인수를 받도록 Area 함수를 변경했다고 추론할 수 있다.

정리하자면, 적어도 이 간단한 예제를 통해 C 와 C++ 가 캡슐화와 관련해 어떻게 밀접하게 연관되는지 살펴봤다. 상속에서도 마찬가지인지 알아보자.



### 9.2.2 상속

상속은 캡슐화보다 알기 쉽다. C++ 에서 자식 클래스의 포인터는 부모 클래스의 포인터로 할당할 수 있다. 또한 자식 클래스는 부모 클래스의 비공개 정의에 접근할 수 있어야 한다.

이러한 두 행위는 C++가 상속을 구현하는 첫 번쨰 접근법을 사용하고 있음을 나타낸다. 이는 8장에서 두 번째 접근법과 함께 다뤘다. 만약 두 접근법을 다시 떠올려봐야 한다면 8장을 참고하자.

하지만 C++ 은 첫 번쨰 접근법에서 지원하지 못하는 다중 상속을 지원하기 때문에 C++ 의 상속은 더 복잡해보인다. 이번 절에서는 예제를 통해 서로 비슷한 두 클래스에서 인스턴스화된 두 객체의 메모리 레이아웃을 점검해본다.



```c
// C의 상속 예 main.c
#include <string.h>

typedef struct {
    char c;
    char d;
} a_t;

typedef struct {
    a_t parent;
    char str[5];
} b_t;

int main(int argc, char** argv) {
    b_t b;
    b.parent.c = 'A';
    b.parent.d = 'B';
    strcpy(b.str, "1234");
    // 메모리 레이아웃을 확인하기 위해 이 행에서 중단점을 설정해야 한다.
    return 0;
}
```

```c
// C++의 상속 예 main.c
#include <string.h>

class A {
    public:
        char c;
        char d;
};

class B {
    public:
    	char str[5];
};

int main(int argc, char** argv) {
    B b;
    b.c = 'A';
    b.d = 'B';
    strcpy(b.str, "1234");
    // 메모리 레이아웃을 확인하기 위해 이 행에서 중단점을 설정해야 한다.
    return 0;
}
```

우선 C 프로그램을 컴파일하고 gdb 로 main 함수의 마지막 행에 중단점을 설정해야 한다. 실행이 중단되면 기존 값뿐만 아니라 메모리 레이아웃도 검사할 수 있다.

``` shell
// gdb 에서 예제의 C 버전 실행하기
$ gcc -g main.c -o exe.out
$ gdb ./exe.out
...
(gdb) b main.c:22
Breakpoint 1 at 0x69e: file main.c, line 22.
(gdb) r
Starting program: .../exe.out

Breakpoint 1, main (argc=1, argv=0x7fffffffe358) at main.c:20
20 return 0;
(gdb) x/7c &b
0x7fffffffe261: 65 'A' 66 'B' 49 '1' 50 '2' 51 '3' 52 '4' 0 '\000'
(gdb) c
[Inferior 1 (process 3759) exited normally]
(gdb) q
$
```

결과가 문자 7개가 출력된다. 이 문자는 b 객체의 주소부터 시작하며, 이어서 'A', 'B', '1', '2', '3', '4', '\0' 이 나온다. C++ 코드에서도 똑같이 해보자.



``` shell
// gdb 에서 예제의 C++ 버전 실행하기
$ g++ -g main.c -o exe.out
$ gdb ./exe.out
...
(gdb) b main.cpp:23
Breakpoint 1 at 0x69b: file main.cpp, line 23.
(gdb) r
Starting program: .../exe.out

Breakpoint 1, main (argc=1, argv=0x7fffffffe358) at main.cpp:21
21 return 0;
(gdb) x/7c &b
0x7fffffffe251: 65 'A' 66 'B' 49 '1' 50 '2' 51 '3' 52 '4' 0 '\000'
(gdb) c
[Inferior 1 (process 3759) exited normally]
(gdb) q
$
```

보다시피 메모리 레이아웃과 속성에 저장된 값은 두 셸 박스에서 같다. C++ 에서 행위 함수와 속성을 클래스안에 함께 두었다는 이유로 헷갈리면 안 된다. 행위 함수와 속성은 클래스에서 별개로 취급된다. C++ 에서는 클래스 내의 위치와 상관없이 속성은 언제나 특정 객체에 대해 같은 메모리 블록 안에서 수집된다. 그리고 함수는 속성과는 언제나 독립적으로 존재한다.



예제는 __단일 상속__ 을 나타낸다. 그렇다면 __다중 상속__ 이란 무엇일까? 8장에서 C에서 상속을 구현하는 첫 번째 접근법이 다중 상속을 지원할 수 없는 이유를 설명했다. 예제로 다시 한번 보자

```c
// C에서 상속을 구현하는 첫 번째 접근법에서 다중 상속이 되지 않는 이유에 관한 예
typedef struct {...} a_t;
typedef struct {...} b_t;

typedef struct {
    a_t a;
    b_t b;
    ...
} c_t;

c_t c_obj;
a_t* a_ptr = (a_ptr*)&c_obj;
b_t* b_ptr = (b_ptr*)&c_obj;
c_t* c_ptr = &c_obj;
```

이 코드 박스에서 c_t 클래스는 a_t 와 b_t 클래스 모두를 상속하려고 한다. 클래스를 선언한 다음에는 c_obj 객체를 만들었다. 그다음 서로 다른 포인터를 만들었다.

여기서 주목할 중요한 점은 __이러한 포인터는 모두 반드시 같은 주소를 가리켜야 한다__ 는 것이다. a_ptr 과 c_ptr 포인터는 a_t 및 c_t 클래스의 어느 행위 함수와도 안전하게 사용할 수 있다. 하지만 b_ptr 포인터는 a_t 객체에 해당하는 c_t 클래스 내의 필드를 가리키므로 사용하기에 위험하다. b_ptr 을 통해 b_t 안에 있는 필드로 접근하려고 한다면 정의되지 않은 행위로 이어진다.

```c
// 올바른 필드를 가리키도록 캐스팅을 업데이트하는 방법에 관한 예
c_t c_obj;
a_t a_ptr = (a_ptr)&c_obj;
b_t b_ptr = (b_ptr)(&c_obj + sizeof(a_t));
c_t c_ptr = *c_obj;
```

세 번째 행을 보면 c_obj의 주소에 대한 a_T 객체의 크기를 추가했다. 이는 결국 c_t 내부의 b 필드를 가리키는 포인터가 된다. 참고로 C 에서 형변환은 어떤 마법을 부리는 것이 아니다. 형변환은 자료형을 변환하기 위해 존재하며, 앞의 예에서는 메모리 주소에 해당하는 전송값을 수정하지는 않는다. 할당 이후에는 결국 오른쪽의 주소가 왼쪽으로 복사된다.

이제 C++ 에서도 같은 예제를 살펴보자. A, B, C라는 서로 다른 세 개의 클래스를 상속받는 D 클래스가 있다고 가정해보자.

```c++
// main.cpp
#include <string.h>

class A {
    public:
    	char a;
    	char b[4];
};

class B {
    public:
    	char c;
    	char d;
}

class C {
    public:
    	char e;
    	char f;
};

class D : public A, public B, public C {
    public:
    	char str[5];
};

int main(int argc, char** argv) {
    D d;
    d.a = 'A';
    strcpy(d.b, "BBB");
    d.c = 'C';
    d.d = 'D';
    d.e = 'E';
    d.f = 'F';
    strcpy(d.str, "1234");
    A* ap = &d;
    B* bp = &d;
    C* cp = &d;
    D* dp = &d;
    // 이 행에서 중단점을 설정해야 한다.
    return 0;
}
```

```shell
$ g++ -g main.cpp -o exe.out
#gdb ./exe.out
...
(gdb) b main.cpp:43
Breakpoint 1 at 0x100000f78: file main.cpp, line 43.
(gdb) r
Starting program: .../exe.out

Breakpoint 1, main (argc = 1, argv = 0x7ffffffffe358) at main.cpp:41
41 return 0;
(gdb) x/14c &d
0x7fffffffffe25a: 65 'A' 66 'B' 66 'B' 66 'B' 0 '\000' 67 'C' 68 'D' 69 'E'
0x7fffffffffe262: 70 'F' 49 '1' 50 '2' 51 '3' 52 '4' 0 '\000
(gdb)
$
```

보다시피 속성은 서로 인접한 곳에 있다. 이는 부모 클래스에 대한 여러 객체가 d 객체의 메모리 레이아웃과 같은 곳 내부에 있음을 나타낸다. ap. bp, cp, dp 포인터는 어떨까? 코드에 나타나듯 C++ 에서는 자식 포인터를 부모 포인터로 할당할 때 (업캐스팅) 암묵적으로 형변환할 수 있다.

현재의 실행에서 이러한 포인터의 값을 조사해보자.

```shell
(gdb) print ap
$1 = (A *) 0x7fffffffe25a
(gdb) print bp
$2 = (B *) 0x7fffffffe25f
(gdb) print cp
$3 = (C *) 0x7fffffffe261
(gdb) print dp
$4 = (D *) 0x7fffffffe25a
(gdb)
```

셀 박스에서는$4 로 나타나는 d 객체에 대한 시작 주소를 보여준다. 이 주소는 $1 로 나타나는 ap 가 가리키는 주소와 같다. 따라서 C++ 에서 D 클래스의 속성 구조체에 대응하는 첫 번쨰 필드로써 A 자료형에 대한 객체를 둔다는 점이 명확하다. 포인터에 있는 주소와 x 명령어로 얻은 결과를 토대로, B 자료형과 C 자료형의 객체는 객체 d 에 속하는 메모리 레이아웃과 같은 곳에 있다.

추가로 앞의 주소는 C++ 에서의 형변환이 수동 작업이 아니라는 점을 나타낸다. 그리고 자료형을 변환할 때 전송하는 주소에 대한 포인터 연산을 수행할 수 있음을 보여준다. 예를 들어 main 함수에서 bp 포인터를 할당할 때, 5바이트 또는 sizeof(A) 가 d 의주소에 추가된다. 이는 C 에서 다중 상속을 구현하는 과정에서 발견되는 문제를 극복하려는 것이다. 이제 이들 포인터는 산술연산할 필요 없이 모든 행위 함수 내에서 쉽게 사용될 수 있다. C와 C++ 의 형변환이 서로 다르다는 점은 중요하니 꼭 알아두자. C의 형변환처럼 C++ 의 형변환도 수동적일 것이라고 가정한다면, 다른 행위를 보게 될 것이다.



### 9.2.3 다형성

C+ 와 C++ 이 다형성을 갖는 내부 기법을 비교하는 일은 쉽지 않다. 8장에서 C에서 다형적인 행위 함수를 갖는 간단한 방법을 제시했다. 하지만 C++ 은 다형성을 갖기 위해서 훨씬 더 복잡한 메커니즘을 이용한다. 다만 근본적인 기본 아이디어는 서로 같다. C에서 다형성을 구현하는 접근법을 일반화하려는 경우, 다음 코드박스의 의사코드로 해볼 수 있다.

```c
// C 코드에서 가상 함수가 선언 및 정의되는 방식을 보여주는 의사코드

// 함수 포인터 자료형 정의하기
typedef void* (*func_1_t)(void*, ...);
typedef void* (*func_2_t)(void*, ...);
...
typedef void* (*func_n_t)(void*, ...);

// 부모 클래스에 대한 속성 구조체
typedef struct {
    // 속성
    ...
    // 함수에 대한 포인터
    func_1_t func_1;
    func_2_t func_2;
    ...
    func_n_t func_t;
} parent_t;

// 가상 행위 함수에 대한 기본 비공개 정의
void* __default_func_1(void* parent, ...) {
    // 기본정의
}
void* _-default_func_2(void* parent, ...) {
    // 기본정의
}
...
void _-default_func_n(void*, parent, ...) {
    // 기본정의
}

// 생성자
void parent_ctor(parent_t *parent) {
    // 속성 초기화하기
    ...
    // 가상 행위 함수에 대한 기본 정의 설정하기
    parent->func_1 = __default_func_1;
    parent->func_2 = __default_func_2;
    ...
    parent->func_n = _-default_func_n;
}

// 공용인 비가상 행위 함수
void* parent_non_virt_func_1(parent_t* parent, ... ) { // Code }
void* parent_non_virt_func_2(parent_t* parent, ... ) { // Code }
...
void* parent_non_virt_func_m(parent_t* parent, ... ) { // Code }
    
    
// 실제 공용 가상 행위 함수들
void* parent_func_1(parent_t* parent, ...) {
    return parent->func_1(parent, ...);
}
void* parent_func_2(parent_t* parent, ...) {
    return parent->func_1(parent, ...);
}
...
void* parent_func_3(parent_t* parent, ...) {
    return parent->func_1(parent, ...);
}
```

이 의사코드에서 볼 수 있듯, 부모 클래스는 속성 구조체 내부에 함수포인터에 대한 목록을 갖고 있어야 한다. 부모 클래스의 이러한 함수 포인터는 가상 함수에 대한 기본 정의를 가리키며, 그렇지 않으면 NULL 값을 가진다. 코드박스 에서 정의된 의사 클래스는 m이라는 비가상 행위함수와 n 이라는 가상 행위 함수를 갖는다.

```
모든 행위 함수가 다형적인 것은 아니다. 다형적 행위 함수는 가상 행위 함수 또는 간단히 가상함수라고 한다. 자바 같은 언어에서는 가상메서드 라고 한다.
```

비가상 함수는 다형적이지 않는다. 그러므로 비가상함수를 호출해 다양한 행위를 얻을 수는 없다. 즉, 비가상 함수에 대한 호출은 단순한 함수 호출에 지나지 않으며, 정의 내부의 로직만을 수행할 뿐 다른 함수로 호출을 전달하지 않는다. 하지만 가상 함수는 부모 또는 자식 생성자에 의해 설종된 적절한 함수로 호출을 다시 전달해야 한다. 상속된 가상 함수의 일부를 자식 클래스가 다시 정의하려면 가상 함수 포인터를 업데이트해야 한다.

```
출력 변수에 대한 void* 형은 다른 어떤 포인터형으로도 대체될 수 있다. 무언가가 의사코드 내의 함수에서 반환될 수 있음을 보여주고자 제네릭 포인터를 사용했다.
```

```c
// 자식 클래스가 부모 클래스로부터 상속받은 가상 함수를 오버라이딩하는 방법을 보여주는 c에서의 의사코드

// 부모 클래스에 관련된 모든 것을 포함하자.
typedef struct {
    parent_t parent;
    // 자식 속성
    	...
} child_t;

void* __child_func_4(void* parent, ...) {
    // 오버라이딩 정의
}
void* __child_func_7(void* parent, ...) {
    // 오버라이딩 정의
}

void child_ctor(child_t* child) {
    parent_cotr((parent_t*)child);
    // 자식 속성 초기화하기
    ...
    // 함수에 대한 포인터 업데이트하기
    child->parent.func_4 = __child_func_4;
    child->parent.func_7 = __child_func_7;
}

// 자식의 행위 함수
...
```

코드박스에 보이듯 자식 클래스는 부모의 속성 구조체 안에 있는 몇몇 포인터에 대한 업데이트만 필요하다. c++도 비슷한 접근법을 취한다. virtual 키워드를 사용해 행위 함수를 가상으로 선언할 때 C++는 함수 포인터의 배열을 만든다. 이는 이전에 했던 방법과 꽤 비슷하다.

각각의 가상 함수에 대해 함수 포인터 속성 하나를 추가했다. 하지만 C++에는 이러한 포인터를 두는 더 영리한 방식이 있다. __가상 테이블__ 또는 __vtable__ 이라는 배열만 사용한다. 가상 테이블의 객체가 생성되려고 할 때 만들어진다. 이전에 봤던 것과 마찬가지로, 가상 테이블은 기초 클래스에대한 생성자를 호출할 때 처음 추가되며, 그 뒤에 자식 클레스의 생성자의 일부가 된다.

가상 테이블은 생성자에서만 추가되는 만큼, 부모 및 자식 클래스 모두 생성자에서 다형적 메서드를 호출하지 않아야 한다. 포인터가 업데이트되지 않았을 수도 있고, 틀린 정의를 가리킬 수도 있기 때문이다.

C와 C++에서 다양한 객체지향 개념을 가질 때 쓰이는 내부 메커니즘의 마지막 내용으로는 '추상화'를 이야기하겠다.



### 9.2.4 추상 클래스

C++ 에서 추상화는 __순수 가상 함수__ 를 사용할 수 있다. C++에서 멤버 함수를 가상 함수라고 정의하고 이를 0으로 둔다면, 순수 가상 함수를 정의한 것이다.

```c++
enum class Taste { Sweet, Sour };

// 인터페이스
class Eatable {
    public:
    	virtual Taste GetTaste() = 0;
};
```

먹을 수 있는 것 클래스 내부에 0으로 설정한 GetTaste라는 가상 함수가 있다. GetTaste 는 순수 가상함수이며 전체 클래스를 추상화 한다. 먹을 수 있는 것(Eatable) 자료형으로부터 더 이상 객체를 생성할 수 없으며, C++ 가 이를 허용하지 않는다. 게다가 먹을 수 있는 것(Eatable) 인터페이스인데, 이는 먹을 수 있는 것(Eatable) 의 모든 멤버 함수가 순순하게 가상이기 때문이다. 이 함수는 자식 클래스에 의해 오버라이딩될 수 있다.

```c++
enum class Taste { Sweet, Sour };

// 인터페이스
class Eatable {
    public:
    	virtual Taste GetTaste() = 0;
};

class Apple : public Eatable {
    public:
    	Taste GetTaste() override {
            return Taste::Sweet;
        }
};
```

순수 가상 함수는 가상 함수와 상당히 비슷하다. 실제 정의에 대한 주소는 가상함수와 마찬가지 방식으로 가상 테이블 내에 있다. 순수 가상 함수에 대한 포인터의 초깃값은 null이며, 이는 일반적인 가상 함수의 포인터와는 다르다. 일반적인 가상 함수의 포인터는 생성이 진행되는 동안 기본 정의를 가리켜야 한다.

추상 자료형에 대해서 아무것도 알지 못하는 C 컴파일러와는 달리, C++ 컴파일러는 추상 자료형을 알고 있다. 그리고 만약 추상 자료형으로부터 객체를 생성하려고 한다면 컴파일 오류를 만든다.

이번 절에서는 7장부터 9장까지 소개한 기술을 사용해 C의 다양한 객체지향 개념을 비교해봤다. 그리고 C++ 에서는 g++ 컴파일러를 사용해서 이들 개념을 비교했다. 대부분의 경우 이 책에서 취한 접근법은 g++ 같은 컴파일러가 사용하는 기술과 일치한다는 점을 보여줬다.



## 9.3 마무리

9장에서는 추상화부터 시작해 객체지향 개념에 관해 C와 C++ 간의 유사성을 보여주면서 OOP 의 주제에 관한 탐색을 마무리했다.

- 추상 자료형과 인터페이스를 다뤘다. 이를 이용해 인터페이스를 또는 추상적인 클래스를 가질 수 있다. 이 부분적인 추상 클래스는 다형성을 갖는 더 구체적인 자식 클래스 및 다른 행위를 만들 때 사용할 수 있다.
- OOP 기능을 도입하기 위해 C 에서 사용하는 기법에 관한 출력 결과를 g++의 출력 결과와 비교하고, 그 결과가 얼마나 비슷하지 설명했다. 이 책에서 사용한 기법들은 결과물에서 매우 유사할 수 있다고 결론 내렸다.
- 가상 테이블을 상세히 다뤘다.
- 순수 가상 함수(C++ 개념이지만 C에도 이에 해당하는 개념이 있다) 가 기본 정의를 갖지 않는 가상 행위를 선언하기 위해 사용하는 방법을 보여줬다.















