# Chapter 2 소스코드에서 이진 파일로

프로그래밍의 모든 것은 __소스코드__ 에서 시작한다. 소스 코드 안의 각각의 텍스트 파일은 프로그래밍 언어로 쓰인, 텍스트로 된 명령어를 포함한다.

CPU는 텍스트로 된 명령어를 실행할 수 있다.  CPU가 이를 실행하려면 먼저 기계 수준의 명령어로 컴파일 해야 하고 그 결과 프로그램이 실행된다.

__1. 표준 컴파일 파이프라인__ : C의 표준 컴파일과 컴파일 파이프라인의 여러 단계, 그리고 컴파일 파이프라인을 통해 C 언어의 소스 코드로부터 최종 결과물이 만들어지는 방식을 다룹니다.

__2. 전처리기__ : 전처리 단계를 진행하는 전처리기를 더 자세히 알아보자.

__3. 컴파일러__ : 컴파일러를 더 깊이 들여다본다. 컴파일 단계를 거치며 컴파일러가 소스 코드에서 __중간표현__ 을 만드는 방식과 기계어로 이를 번역하는 방식을 설명한다.

__4. 어셈블러__ : 어셈블러를 설명한다. 어셈블러는 컴파일러로부터 받은 어셈블리 명령어를 기계 수준 명령어로 번역하는 중요한 역할을 수행한다. 어셈블러는 어셈블리 단계를 진행한다.

__5. 링커__ : 링크 단계를 진행하는 링커라는 컴포넌트를 상세히 다룬다. 링커는 C 프로젝ㅈ트의 실제 결과물을 마지막으로 만드는 빌드 컴포넌트이다. 링커에 따라 빌드 오류가 발생할 수 있는데 , 링커를 충분히 안다면 이러한 오류를 방지하고 해결할 수 있다. 또한 C  프로젝트의 다양한 최종 결과물도 살펴보고, 목적파일을 역어셈블링하고 그 내용을 읽는 법도 설명한다. 그리고 C++ 네임맹글링 name mangling 이 무엇인지, C++ 코드를 빌드할 때 네임 맹글링이 링크 단계에서 특정 결함을 어떻게 방지하는지도 간단히 다룬다.



## 2.1 표준 컴파일 파이프라인

C 파일을 몇 개 컴파일할 때는 대개 수 초 정도 걸린다. 이 짧은 순간에도 소스 코드는 다음 네 가지 요소로 구성된 파이프라인으로 진입하며, 각 요소는 특정 작업을 수행한다.

- 전처리기
- 컴파일러
- 어셈블리
- 링커

파이프라인 내부의 각 컴포넌트는 이전 요소로부터 특정한 입력값을 받고, 다음 컴포넌트를 위한 특정 결괏값을 생성한다. 이 과정은 마지막 요소에 의해 __최종 결과물__ 이 만들어질때까지 계속된다.

모든 필수 요소를 성공적으로 통과했다면 소스코도는 최종 결과물로 바뀐다. 즉, 컴포넌트 중 어느 작은 한 단계라도 실패한다면 이는 컴파일 실패 또는 링크 실패로 이어지며, 그에 관한 오류 메시지가 등장한다.

__재배치 가능한 목적 파일 relocatable object file__ 과 같은 어떤 중간 결과물은 소스 파일 하나가 앞의 세 가지 요소만 성공적으로 통과해도 충분히 만들어진다. 마지막 컴포넌트인 링커는 더 큰 결과물을 만들 때 사용하는데 , 이러한 큰 결과물을 __실행 가능한 목적파일 executable object file__ 이라고 한다. 실행 가능한 목적 파일은 이미 준비된, 재배치할 수 있는 목적 파일 몇 개를 합쳐서 만든다. 그러므로 C 소스파일의 모음을 빌드하면 하나 또는 여러 개의 목적 파일을 만들 수 있다. 이러한 목적파일종류로는 재배치가능한 파일과 실행가능한 파일, 공유목적파일이 있다.



2장 전반에 C 컴파일러의 기본 플랫폼과 우리가 사용할 C 컴파일러를 이야기하기 전에, __플랫폼__ 이라는 용어를 좀 더 알아보자.

플랫폼은 특정 하드웨어에서 실행되는 운영체제의 결합이다. 플랫폼 CPU의 명령어 집합은 플랫폼에서 가장 중요한 부분이다. 운영체제는 플랫폼의 소프트웨어 컴포넌트고, 아키텍처는 하드웨어 부분을 뜻한다. 예를 들면 ARM 파워 보드에서 작동하는 우분투 또는 AMD 64비트 CPU에서 작동하는 마이크로소프트 윈도우가 있다.

크로스 플랫폼 소프트웨어는 다른 플랫폼에서 실행할 수 있다. 하지만 크로스 플랫폼이라는 말은 이식 가능한 것과는 다르다는 점을 꼭 알아야 한다. 크로스 플랫폼 소프트웨어는 대개 각 플랫폼에 따라 다른 이진 파일과 인스톨러가 있다. 반면에 이식 가능한 소프트웨어는 모든 플랫폼에서 같은 이진 파일과 인스톨러를 사용한다. 예를 들면 gcc 와  clang 같은 C 컴파일러는 크로스 플랫폼으로서, 다른 플랫폼에서도 코드를 생성할 수 있다. 한편 자바의 바이트코드는 이식 가능하다.

만약 C/C++ 코드가 이식 가능하다고 한다면, 이는 소스 코드에 어떠한 변경이나 수정을 거치지 않고 서로 다른 플랫폼에서 컴파일할 수 있다는 말이다. 그러나 최종 목적 파일에 이식성이 있다는 의미는 아니다.



### 2.1.1 프로젝트 빌드하기

#### 헤더파일 vs 소스파일

- 헤더파일: 일반적으로 이름의 확장자가 .h인 파일
- 소스파일: 확장자가 .c인 파일

헤더파일은 주로 열거형(enumeration), 매크로(macro) 그리고 형식 정의를 포함한다. 그뿐만 아니라 함수의 선언과 전역 변수, 구조체도 포함한다.  C에서는 함수나 변수, 구조체와 같은 몇몇 프로그래밍 요소의 선언을 정의와 분리해 다른 파일에 둘 수 있다. C++도 같은 패턴을 따른다. 하지만 자바와 같은 다른 프로그래밍 언어에서 컴포넌트는 선언한 곳에서 정의한다. 정의로부터 선언을 분리할 수 잇다는 점은 C와 C++의 좋은 특징이지만, 소스코드가 더 복잡해지기도 한다.

일반적으로 선언은 헤더 파일에 저장되며 그에 해당하는 정의는 소스 파일에 저장된다. 함수의 선언과 정의가 별도 파일에 저장된다는 점은 매우 중요하다. 헤더파일에는 함수의 선언만 두고, 함수의 정의는 그에 맞는 소스 파일로 옮기기를 적극 권장한다. 필수는 아니지만, 프로그램 설계 관행상 함수의 정의는 보통 헤더 파일 바깥에 둔다. 구조체 역시 선언과 정의를 분리할 수 있지만, 특별한 경우에만 서로 다른 파일에 둔다. 이에 관한 예제는 클래스 간의 상속 관계를 다르는 8장에서 살표보자.

더 자세히 알아보기 위해 예제를 보자. 함수 선언은 __반환형__ 과 __함수 시그니처__ 로 구성된다. 함수 시그니처는 입력 매개변수의 목록을 갖는 함수의 이름이다.

```c
double average(int*, int);
```

이 선언은 average 라는 이름의 함수 시그니처를 지정한다. 이 함수는 정수 배열을 가리키는 포인터와 배열의 원소 수를 나타내는 정수 인수를 받는다. 또한 선언부분에는 함수가 double값을 반환한다고 명시한다. 반환형은 선언에 속하지만 함수 시그니처에는 속하지는 않으니 유의하자.

함수의 선언은 세미콜론(;)으로 끝난다. 그리고 중괄호로 감싸인 몸체가 없다. 또한 앞의 선언에서 매개변수가 이름을 갖지 않는다는 점을 눈여겨봐야한다. 아는 C언에서 정의가 아닌 선언에만 해당한다. 그렇지만 선언에서도 매개변수의 이름을 짓기를 권장한다.

```c
double average(int* array, int length) {
    if (length <= 0) {
        return 0;
    }
    double sum = 0.0;
    for (int i = 0; i < length; i++) {
        sum += array[i];
    }
    return sum / length;
}
```

앞서 말한 내용을 더 강조하자면 함수의 선언은 헤더 파일에 정의는 소스 파일에 두어야 한다. 이를 위반하는 경우는 드물다. 소스코드가 선언을 확인하고 사용하려면 헤더 파일을 포함해야 하며, C 와 C++은 바로 이러한 방식으로 작동한다.

```
모든 함수와 구조체, 전역 변수는 변환단위 에서 어떤 선언에 관한 정의가 둘 이상일때 컴파일 오류가 발생한다. 그러므로 하나의 선언에 대한 두가지 정의는 허용되지 않는다.
```



#### 예제 소스 파일

다음 예제에는 총 3개의 파일이 있다. 한 개는 헤더 파일, 다른 두 개는 소스 파일이며 세 파일 모두 같은 경로에 있다.

헤더 파일은 2개의 소스 파일 사이를 잇는 다리로 사용된다. 2개의 별도 파일에서 코드를 작성할 수있지만 빌드는 함께 이루어진다. 헤더 파일이 없으면, 소스 파일은 소스에 포함되어서는 안 된다는 아퍼 언급한 원칙을 깨지 않는 한 코드를 2개의 소스 파일로 나눌 수 없다. 여기서 헤더 파일은 한 소스 코드의 기능을 사용하기 위해 다른 소스 코드에 필요한 모든 내용을 포함한다.

헤더파일은 프로그램이 작동하는 데 필요한 함수 선언 avg 하나만을 포함한다,. 소스 파일 중 하나는 선언된 함수의 정의를 포함한다. 다른 소스 파일은 main함수를 포함하는데, 이는 프로그램의 진입점 entry point 이다. main 함수 없이는 프로그램의 실행 파일을 가질 수 없다. main 함수는 컴파일러가 프로그램의 시작점으로 인식하는 것이다. 

```c
#ifndef HEARDER_H

typedef enum{
    NONE,
    NOMAL,
    SQUARED
} average_type_t;

double avg(int* int, average_type_t);

#endif
```

이 파일은 이름이 붙은 정수형 상수의 집합인 열거형을 포함한다. C에서 열거형은 선언과 정의가 분리될 수 없으며, 같은 곳에서 한 번에 선언과 정의가 이루어져야한다.

열거형뿐만 아니라 avg 함수의 __전방 선언 forward declaration__ 도 코드 박스에서 볼 수 있다. 함수를 정의하기 이전에 함수를 선언하는 행위를 전방 선언이라고 한다. 또한 헤더 파일은 __헤더 가드문__ 에 의해서 보호된다. 헤더 가드문은 헤더 파일이 컴파일될때 두 번 또는 그 이상 포함되는 것을 방지한다.

```c
#include "HEADER_H"

double avg(int* array, int length, average_type_t type) {
    if (length <= 0 || type == NONE) {
        return 0;
    }
    double sum = 0.0;
    for (int i = 0; i < length; i++) {
        if (type == NORMAL) {
            sum += array[i];
        } else if (type == SQUARED) {
            sum += array[i] * array[i];
        }
    }
    return sum / length;
}
```

이 코드에서 파일 이름이 .c 확장자로 끝난다는 점을 알아야한다. 소스 파일은 예제의 헤더 파일을 포함한다. average_type_t 열거형과 avg 함수를 사용하기 전에 이에 관한 선언이 필요하기 때문이다. 이번에 사용하는 새로운 자료형인 average_type_t 열거형은 사용 전에 선언하면 컴파일 오류가 발생한다.

```c
#include <stdio,h>
#include "HEADER.H"

int main(int argc, char **argv) {
    int array[5];
    
    array[0] = 10;
    array[1] = 3;
    array[2] = 5;
    array[3] = -8;
    array[4] = 9;
    
    double average = avg(array, 5, NORMAL);
    printf("The average: %f\n", average);
    
    average = avg(array, 5, SQUARED);
    printf("The squared average: %f\n", average);

    return 0;
}
```

main 함수는 정수의 배열을 선언하고 입력 받은 뒤에 서로 다른 두 개의 평균값을 계산했다. 코드에서 main 함수가 avg 함수를 호출하는 방식에 주목하자.



#### 예제 빌드하기

위 3개의 파일을 가져온 다음 빌드해, 프로그램으로 실행될 최종 실행 이진 파일을 만들어야 한다. C/C++ 프로젝트를 빌드한다는 말은 코드베이스 내의 모든 소스 파일을 컴파일해 __재배치 가능한 목적파일__ 을 만들고, 이러한 재배치 가능한 목적 파일을 결합해 __정적라이브러리__ 또는 __실행 이진파일__ 과 같은 최종 결과물을 만들겟다는 뜻이다.

진도를 더 나가기 전에 꼭 기억해야 할 중요한 규칙 두가지가 있다.

- __규칙 1: 소스 파일만 컴파일__ 
  첫 번째 규칙은 소스 파일만 컴파일한다는 것이다. 헤더 파일을 컴파일하는 것은 의미가 없기 때문이다. 헤더 파일은 몇 가지 선언 외에 어떠한 실제 C 코드도 포함하지 않는다. 그러므로 헤더 파일을 제외한 2개의 파일만 컴파일해야한다.
- __규칙 2: 각 소스 파일을 따로따로 컴파일__
  두 번째 규칙은 각 소스 파일을 따로따로 컴파일한다는 것이다. 각 실행에 하나의 소스 파일을 입력해 컴파일러를 두 번 실행해야 한다는 의미이다. 그러므로 100개의 소스 파일로 구성된 하나의 프로젝트라면 각 소스 파일을 모두 띠로 컴파일해야 하며, 이는 곧 컴파일러를 100번 실행한다는 의미이다.

```
만약 컴파일이 필요한 C 코드를 헤더 파일이 포함하더라도 해당 파일을 컴파일하지는 않는다. 대신, 이 헤더 파일을 소스 파일에 포함시킨 뒤 소스 파일을 컴파일한다. 이러한 방식으로 헤더의 C 코드가 소스 파일에 속해 컴파일된다.
```

소스파일을 컴파일할 때 소스 파일은 컴파일되지 않는다. 소스 파일에는 다른 소스 파일이 포함되지 않기 때문이다.  C/C++ 의 모범 사례를 따른다면 소스 파일을 소스 파일에 포함하는 것은 허용되지 않는다는 걸 명심하자.



### 2.1.2 1단계 : 전처리

 컴파일 파이프라인의 첫 단계는 __전처리__ 이다. 소스파일은 수많은 헤더 파일을 포함한다. 하지만 컴파일이 시작되기 전에 전처리기가 헤더 파일의 내용을 모아서 하나의 c 코드 몸체로 만든다. 즉, 전처리 단계 이후에는 헤더 파일의 내용을 소스 파일로 복사해 만들어진 한 덩어리의 코드를 얻는다.

 또한 다른 __전처리기 지시자__ 는 이 단계에서 반드시 해결되어야 한다. 전처리된 코드는 __변환단위__ 라고 한다. 변환 단위는 전처리기가 생성한 c 언어 코드의 하나의 논리단위로, 컴파일될 준비를 마친 것이다. 변환 단위는 __컴파일 단위__ 라고도 한다.

```
변환 단위에서 전처리기 지시자는 찾을 수 없다. 앞서 나온 내용을 떠올려 보면 모든 전처리기 지시자는 #으로 시작한다. 예를 들면 #include와 #define 이 있다.
```

 컴파일러에 더 컴파일하지 말고 변환 단위로 덤프하라고 요청할 수 있다. gcc의 경우에는 -E 옵션을 전ㄷ날하면 된다. 몇몇 드문 경우, 특히 코스 플랫폼을 개발할 때 변환 단위를 검사하면 이상한 이슈를 고칠 때 유용하다.

```c
$gcc -E ~~~~~
    

typedef enum{
    NONE,
    NOMAL,
    SQUARED
} average_type_t;

double avg(int* int, average_type_t);

#endif

double avg(int* array, int length, average_type_t type) {
    if (length <= 0 || type == NONE) {
        return 0;
    }
    double sum = 0.0;
    for (int i = 0; i < length; i++) {
        if (type == NORMAL) {
            sum += array[i];
        } else if (type == SQUARED) {
            sum += array[i] * array[i];
        }
    }
    return sum / length;
}
```

 모든 선언은 헤더 파일에서 변환 단위로 복제되었다. 또한 주석은 변환 단위에서 제거되었다.

main.c 의 변환다누이는 매우 크다. stdio.h 헤더 파일을 포함하기 때문이다. 이 헤더 파일의 모든 선언과 선언에 의해 포함된 헤더 파일의 내용은 재귀적으로 변환 단위에 복사된다. 

```
-E 옵션은 clang 컴파일러에서도 작동한다.
```



### 2.1.3 2단계 : 컴파일

변환단위를 얻고 나면 두 번째 단계인 컴파일을 진행할 수 있다. 컴팡리 단계에서는 이전 단계에서 얻은 변환 단위를 입력하고, 그에 해당하는 __어셈블리 코드__ 를 출력한다. 이 어셈블리 코드는 여전히 사람이 읽을 수는 있지만, 머신 의존적인 데다가 하드웨어에 더 가깝고 기계수준명령어가 되려면 처리가 더 진행되어야 한다.

 두 번쨰 단계를 수행한 뒤에도 언제든지 gcc로 중지 요청을 할 수 있으며, 컴파일 결과로 얻은 어셈블리 코드에 -S 옵션을 써서 덤프할 수 있다. 컴파일 출력 결과는 원래의 소스 코드와 같은 이름이지만 .s 확장자가 붙는다.



 컴파일 단계에서 컴파일러는 변환 단위를 구문 분석하고 이를 __대상 아키텍처__ 에 맞는 어셈블리 코드로 변환한다. 대상 아키텍처란 프로그램이 컴파일되어 실행될 하드웨어나 CPU를 뜻한다. 대상 아키텍처는 호스트아키텍처라고도 한다.

 C 코드에서 어셈블리 코드를 생성하는 일은 컴파일 파이프라인에서 가장 중요한 단계이다. 어셈블리 코드를 얻으면  CPU가 실행할 수 있는 언어와 매우 가까워진다. 이 역할의 중요성 때문에 컴파일러는 컴퓨터 과학에서 가장 많이 연구되는 주요 주제가 되었다.



### 2.1.4 3단계 : 어셈블리

컴파일 다음 단계는 어셈블리이다. 어셈블리 단계의 목적은 실질적인 기계수준명령어를 만드는 것으로, 이전의 단계에서 컴파일러가 만든 어셈블리 코드에 기반해 기계수준 명령어를 만든다. 각 아키텍처는 고유의 어셈블러를 가지며, 이 어셈블러는 아키텍처의 고유한 어셈블리 코드를 해당 아키텍처의 기계어로 변환할 수 있다.

이 절에서 우리가 어셈블하려는 기계 수준의 명령어를 포함하는 파일을 __목적 파일__ 이라고 한다. C 언어 프로젝트는 모두 목적 파일로 이루어진 최종 결과물을 가질 수도 있다. 이번에는 재배치 가능한 목적파일에 집중해보자. 재배치 가능한 목적파일은 빌드 단계에서 얻을 수 있는 가장 중요한 임시 파일이다.

이전의 두 단계를 상기해보면 어셈블리 단계의 목적은 컴파일러가 만든 어셈블리 코드로부터 재배치 가능한 목적 파일을 생성하는 데 있다. 모든 다른 결과물도 이 단계에서 어셈블러가 생성한 재배치 가능한 목적 파일에 기반한다.

유닉스 계열 운영체제에서 어셈블러 도구는 as라고 한다. as는 어셈블리 파일에서 재배치 가능한 목적파일을 만드는 데 사용할 수 있다.

하지만 이러한 재배치 가능한 목적 파일은 실행할 수 없다. 이 파일은 변환단위에서 생성된 기계수준의 명령어만 ㅗ함한다. 각 변환  단위는 다양한 함수와 전역변수로 구성되므로, 재배치 가능한 목적 파일은 소스 파일의 함수에 해당하는 기계수준의 명령어 및 전역 변수를 위해 미리 할당된 항목만 포함한다.

```shell
$ as file.s -o file.o
```

 이 셸 박스의 명령어를 보면 출력되는 목적 파일의 이름을 지정하기 위해 -o 옵션이 사용된다. 재배치 가능한 목적 파일은 대개 이름에 .o 확장자가 붙으므로 (윈도우에서는 .obj) 파일 이름에 .o를 붙여 입력했다.

.o 또는 .obj 파일의 내용은 텍스트가 아니어서 우리가 읽을 수 없다. 그러므로 목적 파일은 일반저긍로 이진으로 된 내용물을 갖는다고 할 수 있다. 위 셸 박스처럼 어셈블러는 직접 사용할 수도 있지만 권장하지는 않는다. 대신 재배치 가능한 목적 파일을 생성하도록 컴파일러 자체를 사용해 as를 간접적으로 호출하는 것이 좋다.



알려진 거의 모든 c 컴파일러로 -c 옵션을 전달한다면, 컴파일러는 곧바로 소스 파일을 그에 해당하는 목적 파일로 만든다. 즉, -c 옵션은 컴파일의 앞부분 세 단계를 한 번에 수행하도록 한다.

다음 예제를 보면 -c 옵션을 이용해 file.c 를 컴파일한뒤 목적 파일을 생성했음을 확인할 수 있다.

```shell
$ gcc -c file.c
```

이전에 수행한 모든 단계인 전처리, 컴파일, 어셈블리가 이 명령어 하나로 수행된다. 이는 -c 명령어를 실행한 뒤 재배치 가능한 목적 파일이 만들어진다는 의미이다. 재배치 가능한 목적 파일의 이름은 입력한 소스 파일의 이름과 같다. 하지만 .o 확장자를 가진다는 점에서 다르다.

```
컴파일이라는 용어는 두 번째 단계만이 아니라 앞의 컴파일 세 단계를 모두 나타낼 때도 있다. 또한 컴파일이라는 용어를 사용하더라도, 이는 실제로 네 단계를 모두 아우르는 빌드를 뜻할 수 도 있다. 가령 c의 컴파일 파이프라인이라고 한다면 실제로는 c의 빌드 파이프라인을 의미한다.
```

어셈블리는 하나의 소스 파일을 컴파일하는 마지막 단계이다. 즉, 소스 파일 하나에 해당하는 재배치 가능한 목적 파일을 얻으면 컴파일이 완료된 것이다. 이 단계에서는 이미 얻은 재배치 가능한 목적 파일을 얻으면 컴파일이 완료된 것이다. 이 단계에서는 이미 얻은 재배치 가능한 목적 파일 외에 다른 소스 파일을 계속 컴파일할 수 있다.

여기서, 재배치 가능한 목적 파일이 실행 파일이 아니라는 점을 알아두어야 한다. 만약 어떤 프로젝트에서 최종 결과물로 실행 파일을 얻으려면, 링크 단계를 거쳐 대상 실행파일을 빌드하기 위해 모두, 또는 아주 최소한, 또는 몇몇 개의 이미 만들어진 재배치 가능한 목적 파일을 사용해야한다.



### 2.1.5 4단계 : 링크

main함수가 main.c에 있다면 이를 실행 파일로 빌드해야 한다. 하지만 지금은 앞 선 예시로 두 개의 재배치 가능한 목적파일만 있다. 그러므로 다음 단계에서는 다른 실행 가능한 목적 파일로 만들기 위해 이러한 재배치 가능한 목적 파일을 결합해야 한다. __링크__ 단계에서 바로 이러한 일을 한다.

링크 단계로 넘어가기 위해, 유닉스 계열 운영체제에서 새로운 아키텍처 또는 하드웨어를 위해 추가로 지원할 수 있는지 부터 살펴보자.



##### 새 아키텍처 지원하기

모든 아키텍처는 제조사가 만든 일련의 프로세서가 있으며, 이 프로세서는 모두 특정 명령어 집합을 실행할 수있다.

명령어 집합은 인텔이나 ARM 같은 제조사가 자사의 프로세서를 위해 설계한 것이다. 그리고 제조사는 자사의 아키텍처를 위한 특정 어셈블리어도 설계한다.

새로운 아키텍처를 위한 프로그램은 다음의 선행 조건 두 가지를 충족하면 빌드할 수있다.

- 어셈블리어가 알려져 있다.
- 제조사에 의해 개발된 필수 어셈블러 도구가 있어야 한다. 이를 사용해 어셈블리 코드를 그에 해당하는 기계어 수준 명령어로 변환할 수 있다.

이러한 선행 조건이 갖춰지면 소스 코드에서 기계 수준의 명령어를 생성할 수 잇다. 그래야 목적 파일 포맷을 이용해 목적 파일 안에 기계수준의 명령어를 저장할 수있다. 예를 들면 ELF 또는 Mach-O라는 형태가 될 수 있다.

어셈블리어, 어셈블러 도구 그리고 목적 파일 포멧이 명확하다면 C 언어 개발자에게 필수인 다른 툴을 개발할 때 이 세가지 도구를 활용할 수 있다. 하지만 우리는 C 컴파일러를 자주 다루며 컴파일러가 개발자를 대신해 이 도구들을 사용하므로, 이들에 관해서는 잘 몰랐을 것이다.

- C 컴파일러
- 링커

이 도구들은 운영체제에서 새 아키텍처를 지원하는 첫 번째 필수 요소와도 같다. 운영체제에서 이러한 도구가 있는 하드웨어는 새로운 플랫폼을 만들 수 있다.

유닉스 계열 운영체제의 경우에는 유닉스에 모듈러 디자인이 있다는 점을 꼭 기억해야한다. 어셈블러, 컴파일러, 링커와 같은 몇 개의 기초 모듈을 만들 수 있다면, 그것으로 곧 다른 모듈도 만들 수 있으며, 전체 시스템이 새로운 아키텍처에서 작동할 수 있다.



#### 단계 세부 사항

앞서 살펴봤듯, 유닉스 계열의 운영체제를 사용하는 플랫폼은 작업을 위해 앞에서 언급한 필수 도구인 어셈블러나 링커가 반드시 있어야 한다. 어셈블러와 링커는 컴파일러와 별도로 실행할 수 있다는 점을 기억하자.

유닉스 계열 운영체제에서 ld는 기본 링커이다. 다음 셸 박스에서 볼 수  있는 명령어는 앞에서 만든 재배치 가능한 목적파일로부터 실행 파일을 만들 때 ld를 직접적으로 사용하는 방식을 보여준다. 그러나 곧 알게 되겠지만, 링커를 직접 사용하기란 쉽지 않다.



```shell
$ ld impl.o main.o
ld: warning: cannot find entry symbol _start; defaulting to 000000004000e8
main.o : In function 'main':
main.c :(.text+0x7a): undefined reference to 'printf'
main.c :(.text+0xb7): undefined reference to 'printf'
main.c :(.text+0xd0): undefined reference to '__stack_chk_fail' 
```

 보다시피 명령어가 실패해 오류 메시지가 나온다. 오류 메시지를 잘 살펴보면, 텍스트 세그먼트 ld의 세 지점에서 정의되지 않은 세번의 함수 호출이 발생했다고 한다.

세 번의 호출 중 두 번은 printf 함수를 호출하는 데 이는 main 함수에서 수행한 것이다. 하지만 다른 하나인 `__stack_chk_fail` 은 우리가 호출한 것이 아니다. 다른 어딘가에서 온 것인데, 어디일까? 컴파일러가 재배치 가능한 목작 파일에 넣은 보충 코드에서 호출되었다. 이 함수는 리눅스 전용이므로 다른 플랫폼에서 생성된 동일한 목적 파일에서는 볼 수 없다. 이 함수가 무엇이고 어떤 일을 하든 간에, 링커는 제공된 목적 파일에서 찾을 수 없는 정의를 찾고 있다.

앞서 말햇듯 기본 링커인 ld 는 오류 메시지를 냇다. 함수의 정의를 찾을 수 없엇기 때문이다. 논리적으로 이는 타당하며 참이다. `printf` 와 `__stack_chk_fail` 을 정의하지 않았기 때문이다.

이는 ld 로 다른 목적 파일을 제공해야 한다는 의미인데, 반드시 재배치 가능한 목적 파일일 필요는 없으며 `printf`와 `__stack_chk_fail` 함수를 포함하는 다른 목적 파일이면 된다. 앞의 내용을 읽어보면 ld 를 직접 사용하는 것이 왜 어려운지 설명된다. 즉, ld 가 작동해 실행 파일을 만들려면 지정되어야 할 목적 파일과 옵션이 더 많이 필요한다. 다행히 우닉스 계열 운영체제에서 가장 유명한 C 언어 컴파일러는 적절한 옵션을 전달하고, 추가로 더 필요한 목적파일을 지정해 ld를 사용한다. 따라서 ld 를 직접 사용할 필요는 없다.

```
프로젝트를 빌드한다는 것은 소스를 먼저 컴파일한 다음, 컴파일 결과물 도는 다른 라이브러리와 함께 링크해 최종 파일을 만드는 것이다.
```

지금까지 한 작업을 돌아보자. 소스코드를 재배치 가능한 목적 파일로 컴파일 했고, 컴파일로 생선한 목적 파일을 링크해 성공적으로 빌드햇으며 최종 실행 이진 파일을 만들었다.

어떤 C/C++ 코드베이스라도 이 과정은 같다. 하지만 소스를 컴파일하는 데 필요한 횟수는 프로젝트 내의 소스 파일의 개수에 따라 다르다.

컴파일 파이프라인은 여러 단계가 있으며 각 단계에는 그와 관련된 특정 컴포넌트가 있다. 2장의 나머지 부분에서는 컴파일 파이프라인의 각각의 컴포넌트를 둘러싼 필수 정보를 자세히 살펴보자.



## 2.2 전처리기

1장에서는 전처리기의 개념을 간략하게 소개햇다. 특히 매크로, 조건부 컴파일, 헤더 가드를 설명했다. 앞선 소개에서 C 언어의 필수요소로 전처리기를 설명했음을 기억하자. 다른 프로그래밍 언어에서는 쉽게 발견할 수 없다는 점에서 전처리기는 독특하다. 아주 간단히 말하자면, 전처리기는 컴파일러로 소스 코드를 보내기 전에 소스  코드를 수정할 수 있도록 한다. 이와 동시에 소스코드를 헤더 파일로 나누어서 나중에 여러개의 다른 소스 파일에 포함할 수 있도록 하며, 선언을 재사용할 수 있도록 한다.  소스코드에 문법 오류가 있다면, 전처리기는 C 언어 문법을 전혀 모르기 때문에 오류를 찾지 못한다. 그 대신 텍스트 치환을 위주로 하는 몇가지 쉬운 작업만 수행할 뿐이다.

```c
#include <stdio.h>
#define file 1000

hello, this is just a simple text file but ending with .C extension!
This is not a C file for sure!
But we can preprocess it!
```

```c
hello, this is just a simple text 1000 but ending with .C extension!
This is not a C 1000 for sure!
But we can preprocess it!
```

주의 깊게 살펴보면 흥미로운 치환이 이루어졋음을 알 수 있다. 텍스트 안의 file 이 1000으로 교체되었다.

이 예제는 전처리가 작동하는 방식을 정확히 보여준다. 전처리기는 파일의 내용을 복제하거나 텍스트 치환을 통해 매크로를 확장함으로써 포함과 같은  단순한 일만 수행한다. 전처리기는 C 언어는 전혀 모른다. 전처리기가 다른 일을 추가로 수행하려면 입력 파일을 구문 분석하는 파서가 필요하다. 즉, 전처리기는 파서를 이용해서 입력 코드에서 지시자를 찾는다.

```
일반적으로 파서란 추가적인 분석과 처리를 위해 입력 데이터를 처리하고 데이터의 특정부분을 추출하는 프로그램이다. 파서는 입력 데이터의 구조를 알아야 한다. 입력 데이터를 더 작게 나누어서 유용한 데이터를 얻기 위해서이다.
```



전처리기의 파서는 C 컴파일러가 사용하는 파서와 다르다. 전처리기의 파서는 C 언어의 문법과는 거의 독립적인 문법을 사용하기 때문이다. 그렇기에 C 파일을 전처리할 때 외에도 전처리기의 파서를 사용할 수 있다.

```
전처리기의 기능을 명확하게 이해하면, 프로그램을 비드하는 것 외의 다른 목적을 위해 파일을 포함하고 매크로를 확장할 수 있다. C 언어의 전처리기는 다른 텍스트 파일을 처리할 때도 사용할 수 있다.
```



마지막으로 설명할 내용은 .i 확장자를 가진 파일을 C 컴파일러에 입력할 때 전처리 단계를 건너뛴다는 점이다 .i 확장자를 가진 파일은 이미 전처리되었으므로 곧바로 컴파일 단계로 보내야 한다.

만약 .i 확장자를 가진 파일을 C 전처리기에 입력하겠다고 고집하면, 다음과 같은 경고 메시지를 받는다.



## 2.3 컴파일러

앞에서 설명한 대로 컴파일러는 전처리기가 준비한 변환 단위를 받고 그에 해당하는 어셈블리 명령어를 생성한다. 여러 소스 파일이 어셈블리 코드로 컴파일될때, 플랫폼에서 어셈블러나 같은 기존의 도구는 나머지 작업을 맡는다. 생성된 어셈블리 코드에서 재배치 가능한 목적 파일을 만들고 마지막으로는 이 파일을 함께 링크하낟. 그러면 라이브러리나 실행 파일을 만들게 된다.

C 언어 개발을 위해 유닉스에서 사용할 수 있는 여러 도구 가운데 as 와 ld 두가지를 예시로 설명햇다. 이 도구는 플랫폼에 따라 호환 가능한 목적 파일을 만들 때 주로 사용된다. 이 도구는 gcc 또는 다른 컴파일러의 외부에 반드시 존재한다. 컴파일러 외부에 존재함으로써 gcc 에 포함되어 개발되지는 않음을 의미하며, 심지어 설치된 gcc 가 없더라도 어떤 플랫폼에서도 사용할 수 있어야 한다. gcc는 이러한 도구를 컴파일 단계에서만 사용하며, 해당 도구는 gcc 에 포함되지는 않는다.

이는 프로세스가 허용하는 명령어 집합과 운영체제에 맞는 형식과 규칙을 가장 잘 아는 개체가 바로 플랫폼이기 때문이다. 컴파일러는 변환 단위에서 최적화하지 않는 이상 이러한 제한을 잘 알지 못한다. 따라서 gcc 가 하는 중요한 일이란, 변환 단위를 어셈블리 명령어로 번역하는 것이라고 결론 내릴 수 있다. 이것이 바로 컴파일이다.

컴파일할 때 어려운 점 중 하나는 대상 아키텍처가 허용하는 올바른 어셈블리 명령어를 생성해내는 일이다. ARM, 인텔 x86, AMD 그리고 더 많은 다양한 아키텍처에서 gcc를 사용해 같은 C 코드를 컴파일할 수 있다. 앞서 이야기한 대로 아키텍처마다 각자의 프로세서가 수용하는 명령어 집합이 있으며, gcc는 특정 아키텍처에 관한 올바른 어셈블리 코드를 생성하는 역할을 맡은 유일한 개체이다.

gcc 가 이러한 어려움을 극복하는 방식은 미션을 2단계로 나누는 것이다. 첫 번째는 변환 단위를 구문 분석한뒤 , 이를 재배치 가능하며 C에 독립적인 데이터 구조, 즉 __추상구문트리 abstract syntax tree(AST)__ 로 변환하는 것이다. 그다음 AST를 사용해 대상 아키텍처에 맞는 어셈블리 명령어를 생성한다. 첫 번째 단계는 아키텍처에 독립적이며 대상 명령어 집합에 상관없이 수행할 수 잇다. 그러나 두 번째 단계는 아키텍처 의존적이므로 컴파일러가 대상 명령어 집합에 관해 알아야 한다. 첫 번째 단계를 수행하는 하위 요소를 __컴파일러 프런트엔트__  라고 하며, 두 번째 단계를 수행하는 하위 요소는 __컴파일러 백엔드__ 라고 한다.



### 2.3.1 추상 구문 트리

앞에서 설명했듯이 컴파일러 프런트엔드는 변환 단위를 구문 분석해 중간 단계의 자료 구조를 만든다. 컴파일러는 C 의 문법에 따라 소스코드를 분석해 이러한 중간 단계 자료 구조를 만들고, 이 결과를 아키텍처에 의존적이지 않은, 트리 모양의 자료 구조에 결괏값을 저장한다. 이 최종 자료구조를 보통 AST라고 한다.

AST는 C 언어뿐만 아니라 다른 프로그래밍 언어로도 만들 수 있다. 따라서 AST 구조는 C 언어의 문법에 독립적이기 위해 충분히 추상적이어야 한다.

그러므로 컴파일러 프런트엔드가 다른 언어를 지원할 수 있도록 충분히 변경할 수 있다. 이러한 이유로 __GCC GNU Compiler Collection__ 나, __LLVM Low-Level Virtual Machine__ 이 C, C++ 외에 자바나 포트란과 같은 다른 언어의 컴파일러에도 포함된다. 참고로 GCC의 C 컴파일러에는 gcc가 , LLVM의 C 컴파일러에는 clang 이 있다.

AST가 일단 만들어지면 컴파일러 백엔드가 AST를 최적화한다., 그리고 최적화된 AST를 기반으로 대상 아키텍처에 관한 아셈블리 코드를 생성한다. 

clang 은 llvm 컴파일러 백엔드를 위한 LLVM 개발자 그룹이 개발한 C 컴파일러 프런트엔드이다. __LLVM 컴파일러 기반 프로젝트__  는 중간표현을 프런트와 백엔드 사이의 추상 데이터 구조로 사용했다. LLVM 은 연구 목적으로 IR 자료 구조를 덤프할 수 있다고 잘 알려져 있다. 소스코드에 관한 AST의 다른 이점은 명령어의 순서를 재배열할 수 잇고, 사용하지 않은 브랜치를 줄일 수 잇으며, 브랜치를 대체해 성능을 더 높이면서도 프로그램의 목적은 보존할 수 있다는 것이다. 앞서 언급한 대로 이는 최적화라고 하며, 보통 모든 C 컴파일러가 어느정도 구성 가능한 범위에서 최적화를 수행한다.



## 2.4 어셈블리

앞서 설명한대로 올바른 기계 수준 명령어를 포함하는 목적 파일을 만들기 위해 플랫폼에는 어셈블러가 있다. 유닉스 계열 운영체제에서는 as 유틸리티 프로그램으로 어셈블러를 불러 올 수 잇다, 이번 절에서는 이어서 어셈블리가 목적 파일에 무엇을 넣을 수 잇는지 살펴보자.

만약 같은 아키텍처에 서로 다른 유닉스 계열 운영체제를 2가지 설치할 경우, 설치된 어셈블러는 같지 않을 수도 잇다. 이는 매우 중요하다. 같은 하드웨어에 있기 때문에 기계 수준의 명령어가 같더라도, 생성된 목적 파일은 다를 수 잇다.

AMD64 아키텍처의 리눅스에서 프로그램을 커맢일하고 그에 해당하는 목적 파일을 만든다면, 같은 하드웨어에 있더라도 FreeBSD 또는 macOS와 같이 다른 운영체제에서 동일한 프로그램을 컴파일했을때 결과가 달라질 수 있다. 이는 목적파일이 같을 수는 없지만, 같은 기계 수준의 명령어를 포함한다는 의미이다. 나아가 목적 파일이 다양한 운영체제에서 별도의 포맷을 가질 수 있음을 증명한다.

즉 기계수준명령어를 목적 파일에 저장할 때, 각 운영체제는 고유한 특정 이진파일포맷 또는 __목적파일포맷__ 을 정의한다. 따라서 목적 파일의 내용을 트겆앟는 두 가지 요소가 존재한다. 바로 아키텍처와 운영체제이다. 일반적으로 이 두 가지를 결합해 플랫폼이라는 용어로 지칭한다.

이 절의 내용을 정리하면, 일반적으로 목적 파일과 이를 생성하는 어셈블러는 플랫폼에 따라 다르다. 리눅스에서는 __ELF 파일형식__ 을 사용한다. 이름 그대로 모든 실행 파일, 목적 파일, 공유 라이브러리가 이 파일 형식을 사용한다. 즉, 리눅스에서는 어셈블러가 ELF 목적 파일을 만든다.



## 2.5 링커

c 프로젝트를 빌드하는 첫 번째 큰 단계는 모든 소스 파일을 그에 해당하는 재배치 가능한 목적 파일로 컴파일하는 것이다. 이 단계는 최종 결과물을 준비하는 중요한 단계이지만, 이것만으로는 충분하지 않다. 아직 한 단계가 더 필요하다. 자세히 알아보기 전에, c 언어 프로젝트의 __결과물__ 로 가능한 형태에 관해 빠르게 훑어보자.

C/C++ 프로젝트는 다음 결과물을 만들 수 있다.

- 실행 파일: 대부분의 유닉스 계열 운영체제에서 이 파일의 확장자는 .out 이다. 윈도우에서는 .exe 이다.
- 정적 라이브러리: 대부분의 유닉스 계열 운영체제에서는 대체로 확장자가 .a이며 윈도우에서는 .lib이다.
- 동적 라이브러리 또는 공유 목적 파일: 대부분의 유닉스 계열 운영체제에서는 확장자가 .so이며 macOS에서는 .dylib, 윈도우에서는 .dll이다.

재배치 가능한 목적 파일은 임시 결과물로, 앞에서 나열한 목록의 파일을 만드는 링크 단계에만 관여한다. 링크가 끝나면 재배치 가능한 목적 파일은 더는 필요하지 않다. 링커는 주어진 재배치 가능한 목적 파일로부터  이 목록에 있는 결과물을 만드는 역할을 전적으로 담당한다.

이 3가지 결과물은 모두 __목적 파일__ 이라고 한다. 그러므로 어셈블러가 중간 단계 결과물로 만든 목적 파일을 가리킬 때는, 목적 파일 앞에 __재배치 가능한 relocatable__ 이라는 용어를 붙이는 것이 가장 좋다.



실행 가능한 목적 파일은 __프로세스__ 로서 실행될 수 있다. 이 파일은 프로젝트가 제공하는 요소의 상당 부분을 포함한다. 이 파일에는 기계 수준의 명령어 실행될 진입점이 반드시 잇어야 한다. C 언어 프로그램의 진입점은 main 함수이지만, 실행 파일의 진입점은 플랫폼마다 다르며 main 함수도 아니다. main 함수는 플랫폼에 따라 다른 명령어 묶음으로 준비된 뒤에야 호출된다. 이 명령어 묶음은 링크 단계의 결과로 링커가 덧붙인 것이다.

정적 라이브러리는 재배치 가능한 목적 파일 몇 개를 포함하는 아카이브 파일에 지나지 않는다. 따라서 링커는 정적 라이브러리 파일을 직접 만들지 않는다. 그 대신 시스템의 기본 아카이브 프로그램이 만들며, 유닉스 계열 시스템의 경우 ar 프로그램이 이에 해당한다.

정적 라이브러리는 다른 실행 파일에 연결되어 해당 실행 파일의 일부가 된다. 정적 라이브러리는 나중에 로직을 사용할 수 있도록 캡슐화하는 가장 간단하고 쉬운 방법이다.

공유 목적ㅈ 파일은 단순히 아카이브라기보다는 더 복잡한 구조를 가지며, 링커가 직접 생성한다. 그리고 다른 방식으로 사용되는데, 공유 목적 파일은 사용하기 전에 __실행 시__ 실행 중인 프로세스에 직접 로드되어야 한다.

공유 목적 파일은 최종 실행 파일의 일부가 되기 위해 __링크 시 link time__ 사용되는 정적 라이브러리와 반대이다. 게다가 공유 목적 파일 하나는 동시에 서로 다른 여러 프로세스에 로드되어 사용할 수 있다.



### 2.5.1 링커의 작동 방식

다섯 개의 소스 파일을 갖는 C 언어 프로젝트를 빌드한다고 가정해보자. 빌드 과정에서 모든 소스 파일을 컴파일했고, 이제 재배치 가능한 목적 파일이 5개 있다. 지금 필요한 것은 마지막 단계를 완성해 최종 실행 파일을 만들 링커이다.

지금까지 말한 내용을 토대로 간단히 말하자면, 링커는 최종 실행 파일을 만들기 위해 특정한 정적 라이브러리를 더해 모든 재배치 가능한 목적 파일을 결합한다. 작동하는 실행 파일ㅇ르 만들고자 목적 파일을 결합하려 할 때, 목적 파일의 내용에 관해 고려할 사항이 몇 가지 있다. 링커가 어떻게 작동하는지 알려면 링커가 재배치 가능한 목적 파일을 어떻게 사용하는지 알아야 한다. 그러려면 목적 파일 안에 무엇이 있는지도 알아야한다.

간단히 답하자면, 목적 파일은 변환 단위에 해당하는 기계 수준의 명령어를 포함한다. 그러나 이 명령어는 무작위로 파일에 들어가지 않는다. 대신 __심벌 symbol__ 이라고 하는 섹션 아래로 묶인다. 목적 파일 안에는 사실 많은 것이 있지만, 심벌은 링커가 작동하는 방식 및  링커가 목적 파일 몇개를 하나로 모아 더 큰 파일로 만ㄴ드는 방식을 설명하는 컴포넌트이다.

```c
int average(int a, int b){
    return (a + b) / 2;
}

int sum(int* numbers, int count) {
    int sun = 0;
    for (int i = 0; i < count; i++) {
        sum += numbers[i];
    }
    return sum;
}
```

먼저, 목적 파일을 만들려면 이 코드를 컴파일 해야 한다. 다음 명령어는 목적 파일인 target.o 를 만든다.

```shell
gcc -c file.c -o target.o
```

다음으로 nm 유틸리티를 써서 target.o 목적 파일을 들여다보자. nm 유틸리티로 목적 파일 안에 있는 심벌을 볼 수 있다.

```shell
$ nm target.o
0000000000 T average
000000001d T sum
```

목적파일에서 정의한 심벌을 보여준다. 심벌의 이름은 소스 파일에서 정의한 함수와 정확히 같다.

readelf 유틸리티를 사용하면 목적파일에 존재하는 __심벌 테이블__ 을 볼 수 있다. 심벌 테이블은 목적 파일에서 정의된 모든 심벌을 포함하며, 심벌에 관한 더 많은 정보를 제공할 수 있다.

readelf 의 출력에서 볼 수 있듯이 심벌 테이블에는 함수 심벌이 두개 있다. 또한 이 테이블에는 목적 파일 내의 다른 섹션을 가리키는 다른 심벌도 있다. 각각의 함수 심벌 아래에 기계 수준 명령어의 디스어셈블리를 보고 싶다면 objdump 도구를 사용할 수  있다.

소스코드에서 정의된 함수에 각 힘수 심벌이 대응한다. 하나의 실행 파일을 만들기 위해 재배치 가능한 목적 파일 여러 개를 링크해야 하는 경우, 이 유틸리티는 각각의 재배치 가능한 목적 파일이 완전한 실행 프로그램을 빌드하는 데 필요한 전체 함수 심벌의 일부만을 포함한다는 것을 나타낸다.

이제 이 절의 주제로 되돌아가면 링커는 재배치 가능한 목적 파일에서 모든 심벌을 모은다. 완전한 실행 이진 파일을 만들기 위해 더 큰 목적 파일 안에 이들을 한데 집어넣기 전에 그렇다.  예시를 보자

예시는 4개의 C 파일로 이루어진다. 3개는 소스파일, 1개는 헤더파일이다. 헤더 파일에는 2개의 함수를 선언했는데, 함수 각각은 각자의 소스 파일에서 정의된다. 세번째 소스 파일은 main 함수를 포함한다.

```c
#ifndef FILE_H
#define FILE_H

int add(int, int);
int multiply(int, int);

#endif
```

코드를 보면 __이중포함__ 을 막기 위해 헤더 가드문을 사용했음을 알 수 있다. 게다가 두 함수는 유사한 __시그니처__ 로 선언되었다.

```c
// add 함수 정의
int add (int a, int b) {
    return a + b;
}
```

```c
// multiply 함수 정의
int multiply(int a, int b) {
    return a * b
}
```

```c
// main.c
#include "FILE_H"

int main(int argc, char ** argv)
{
    int x = add(4,5);
    int y = multiply(9, x);
    return 0;
}
```

세번째 소스 파일은 함수의 두 개의 선언을 얻으려면 헤더파일을 포함해야 한다. 게다가 main 함수는 add 또는 multiply 의 정의에 관해서 아무것도 알지 못한다. 여기서 main 함수는 다른 소스 파일을 전혀 알지 못하면서 어떻게 이러한 정의를 찾는 걸까?  이 질문은 링커로 해결할 수 있다. 링커는 필요한 정의를 다양한 목적 파일에서 모아서 하나로 합친다. 그리고 이러한 방식으로 main 함수에 작성된 코드는 다른 함수에서 작성된 코드를 사용할 수 있다.

```
함수를 사용하는 소스 파일을 컴파일하려면 선언만으로 충분하다. 그러나 프로그램을 실제로 실행하려면 최종 실행 파일에 넣기 위해 링커에 함수의 정의를 제공해야한다.
```



모든 소스 파일을 컴파일해보자

```shell
$ gcc -c add.c -o add.o
$ gcc -c multiply.c -o multiply.o
$ gcc -c main.c -o main.o
```

다음 단계에서는 각각의 재배치 가능한 목적 파일에서 포함하는 심벌 테이블을 보자

```shell
$ nm add.o
000000000000 T add
```

```shell
$ nm multiply.o
000000000000 T multiply
```

```shell
$ nm main.o
			 U add
			 U _GLOBAL_OFFSET_TABLE_
000000000000 T main
			 U multiply
```

세번 째 소스 파일은 main 함수만 갖지만, 이 소스 파일에 해당하는 목적 파일에는 add 와 multiply 두 개의 심벌이 있다는 것을 알 수 있다. 그러나 main 심벌과는 다르다. main 심벌은 목적 파일 안에서 주소를 갖는다. 세 번째 소스의 add와 multiply 심벌은 __U 또는 미해결된__ 것으로 표기된다. 이는 컴파일러가 변환단위에서 이 심벌을 봣지만 실제 정의를 찾을 수 없었다는 의미이다. main 함수를 포함하는 소스 파일은 같은 변환 단위에서 정의되지 않았다면 다른 함수의 정의에 관해서는 아무것도 몰라야한다. 하지만 재배치 가능한 목적 파일에서 main 함수가 실제로 add 와 multiply의 정의에 의존한다는 사실을 짚어봐야 한다.

요약하자면, 현재 3개의 중간목적파일이 있으며 그중 하나에는 미해결 심벌 두 개가 있다. 바로 이 지점에서 링커의 역할이 명확해진다. 우리는 링커에 다른 목적파일에서 발견될 수 있는 필수 심벌ㅇ르 전달해야 한다. 필요한 모든 심벌을 찾은 뒤, 링커는 최종 실행 이진 파일을 만들기 위해 계속해서 심벌을 결합할 수 있다.

링커가 미해결된 심벌의 정의를 찾을 수 없다면 실패할 것이고, __링크 오류__ 를 출력해서 알려준다.

```shell
$ gcc add.o multiply.o main.o
```

어떠한 옵션도 전달하지 않은 상태로 목적 파일의 리스트를 가지고 gcc를 실행하면, 입력한 목적 파일에서 실행 목적 파일을 만드는 링크 단계로 이어진다. 이 실행은 주어진 목적 파일과 더불어 플랫폼에서 필요한 다른 정적 라이브러리 및 목적 파일과 함께 백그라운드에서 링커를 호출한다.

링커가 적절한 정의를 찾는 데 실패하면 어떤 일이 발생하는지 알아보기 위해, 두 개의 중간 단계 목적 파일(add.o 와 main.o)만 링커로 전달한다.

```shell
$ gcc add.o main.o
main.o ; In function 'main':
main.c:(.text+0x2c): undefined reference to 'multiply'
collect2: error: ld returned 1 exit status
$
```

제공된 목적 파일에서 multiply 심벌을 찾지 못했기 때문에 링커는 실패했다.

```shell
$ gcc main.o multiply.o
main.o ; In function 'main':
main.c:(.text+0x1a): undefined reference to 'add'
collect2: error: ld returned 1 exit status
$
```

제공된 목적 파일에서 multiply 심벌을 찾지 못했기 때문에 링커는 실패했다.

마지막으로 남은 조합인 add.o 와 multiply.o 를 링커에 전달해보자. 어느 쪽의 목적 파일에도 해당 파일의 심벌 테이블에 미해결 심벌이 없으므로 실행하기도 전에 이 조합은 작동하리라 예상하겠지만 실제로 어떤 일이 일어나는지 보자.

```shell
$ gcc add.o multiply.o
/usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/Scrt1.o:
In function '_start':
(.text+0x20): undefined reference to 'main'
collect2: error: ld returned 1 exit status
$
```

링커는 또다시 실패한다. 출력을 보면 알 수 있듯이, 두 목적 파일 모두 실행 파일을 만드는데 필수인 main 심벌을 포함하지 않앗기 때문이다. 링커에는 프로그램의 진입점이 필요한데, 표준 C 언어에 따르면 main 함수가 진입점이다.

여기서 강조하자면 main 심벌을 참조하는 지점을 주목해야 한다. main 심벌은 /usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/Scrtl.o에 위치한 파일에 있는 _start 함수가 만든다.

Srtl.o 파일은 우리가 생성하지 않은 재배치 가능한 목적 파일처럼 보인다. Sctl.o는 실제로 기본 C 목적 파일 그룹에 속하는 파일이다. 이 기본 목적 파일은 gcc 번들에 속하여 리눅스용으로 컴파일되엇으며, 모든 프로그램에 링크되어 해당 프로그램을 실행할 수 있도록 한다.

위처럼 소스 코드 주변에는 충돌을 일으키는 요소가 많다. 그뿐만 아니라, 실행되려면 프로그램에 링크해야 하는 다른 목적 파일도 매우 많다.



### 2.5.2 링커는 속일 수 있다

이번 예제는 소스 파일을 2개 가진다. 소스 중 하나는 main 함수에 선언된 것과 이름은 같지만 다른 시그니처를 가진 함수의 정의를 포함한다.

```c
int add(int a, int b, int c, int d) {
    return a + b + c + d;
}
```

```c
#include <stdio.h>

int add(int, int);

int main(int argc, char** argv)
{
    int x = add(5,6);
    printf("Result: %d\n", x);
    return 0;
}
```

main 함수는 add 함수의 다른 버전을 사용하며 다른 시그니처를 쓴다. main 함수는 2개의 정수를 받지만, 첫번째 소스 파일에서 add 함수는 4개의 정수를 받도록 정의되었다.

이들 함수는 서로 __오버로드__ 한다고 한다. 이 소스 파일을 컴파일하고 링크하면 무언가 확실히 잘못될 것이다. 링크해보자

```ㅅ
$ gcc -c add.c -o add.o
$ gcc -c main.c -o main.o
$ gcc add.o main.o -o ex.out
$
```

셸의 출력에서 알 수 있듯이 링크 단계는 잘 진행되었고 최종 실행 파일도 만들어졌다. 이는 심벌이 링커를 속일 수 있다는 것을 명확히 보여준다. 실행 파일을 실행시킨 뒤의 결과를 보자.

```shell
$ ./ex.out
Result: -1885535197
$ ./ex.out
Result: 1679625283
```

잘못된 결과가 출력된다. 심지어 실행할 때마다 달라지기까지 한다. 이 예제는 링커가 심벌의 잘못된 버전을 가져오면 나쁜일이 발생한다는 점을 보여준다. 함수의 심벌이란 단지 이름일 뿐이며 함수의 시그니처에 관해서는 어떠한 정보도 전달하지 않는다. 함수의 인수는 C 언어의 개념에 지나지 않는다. 실제로 함수의 인수는어셈블리 코드나 기계 수준 명령어에는 존재하지 않는다.



```c
// add_1.c
int add(int a, int b, int c, int d) {
    return a + b + c + d
}
```

```c
// add_2.c
int add(int a, int b) {
	return a + b;
}
```

첫 단계과는 이전과 마찬가지로 두 개의 소스파일을 모두 컴파일한다.

```shell
$ gcc -c add_1.c -o add_1.o
$ gcc -c add_2.c -o add_2.o
$
```

그다음에는 다른 목적 파일에서 add 심벌의 디스어셈블리를 봐야 한다. add_1.o 목적 파일부터 시작하자.

```shell
$ objdump -d add_1.O
생략..
```

함수가 호출되면 새로운 __스택프레임__이 스택 맨 위에 생성된다.  스택 프레임은 함수에 전달된 인수와 반환 주소를 둘 다 포함한다.

main 함수는 add 함수를 호출하는 동안 2개의 값만 스택 프레임에 넣는데, add 함수는 실제로 4개의 인수를 기대했다. 그러면 누락된 인수를 읽기 위해 잘못된 정의가 스택 프레임을 계속 넘어가기 쉽고, 그 결과 합계 연산에서 잘못된 값이 나온다.

이러한 현상은 입력 자료형에 따라 함수 심벌 이름을 변경해 막을 수 있다. 이 방식을 __네임 맹글링 name mangling__ 이라고 하며, 주로 C++에서 사용되는데 __함수 오버로딩__ 특성 때문이다.



### 2.5.3 C++ 네임 맹글링

C++ 에서 네임 맹글링의 작동 방식을 조명하기 위해 C++ 컴파일러를 이용해서 컴파일하자. 이를 위해 GNU C++ 컴퍄일러인 g++을 사용하자.

한번 해본 대로, 생성된 각 오브젝트 파일의 심벌 테이블에 덤프하려면 readelf 를 사용할 수 있다. 이렇게 하면 C++ 가 입력 매개변수의 자료형에 따라 함수 심벌의 이름을 바꾸는 방식을 확인할 수 있다.

```shell
$ g++ -c add_1.c -o add_1.o
$ g++ -c add_2.c -o add_2.o
$ readelf add_1.o

/.../
8: 000000000000 36 FUNC   GLOBAL DEFAULT 1 _Z3addiiii
$ readelf add_2.o


/.../
8: 000000000000 20 FUNC   GLOBAL DEFAULT 1 _Z3addii
```

출력에서 볼 수 잇듯 add 함수의 다른 오버로드에 관해 서로 다른 2개의 심벌이름을 가진다. 4개의 정수를 받는 오버로드는 심벌 이름이 _Z3addiiii이고 2개의 정수를 받는 다른 오버로드는 심벌 이름이 _Z3addii 이다.



심벌 이름의 모든 i는 정수 입력 매개변수 중 하나를 나타낸다.

이로써 심벌 이름이 다르다는 것을 알 수 있다. 잘못된 이름을 사용하려고 하면 링커가 잘못된 심벌의 정의를 찾을 수 없으므로 링크오류가 발생한다.네임 맹글링은 C++가 함수 오버로딩을 지원하는 기술이며 이는 앞서 마주한 문제를 방지하는 데 도움이 된다.



## 2.6 마무리

2장에서는 C 언어 프로젝트를 빌드하는 기초적인 단계 및 필수 컴포넌트를 다뤘다. 프로젝트를 빌드하는 방법을 모른 채로 코드를 작성한다면 무의미하다.

- C 의 컴파일 파이프라인을 살펴봣다. 컴파일의 각 단계와 입출력을 설명했다.
- __플랫폼__ 용어를 정의햇으며, 별개의 어셈블러가 같은 C 언어 프로그램으로 어떻게 서로 다른 기계 수준 명령어를 만드는지 알아봤다.
- 컴파일의 각 단계를 진행하는 컴포넌트에 관해서도 더 자세히 살펴봤다
- 컴파일러의 컴포넌트인 프런트엔드와 백엔드가 무엇인지 살펴보고, GCC와 LLVM이 여러 언어를 지원하기 위해서 프런트엔드와 백엔드를 사용하는 방식을 설명했다.
- 어셈블러와 관련해 목적 파일이 플랫폼 의존적이라는 점과, 어셈블러가 정확한 파일 형식을 가져야 한다는 것을 살펴봤다.
- 링커가 어떤 역할을 하는지, 그리고 링커가 누락된 정의를 찾기 위해 심벌의 사용법을 알아봤다. 이는 정의를 모아서 최종 파일을 만들기 위해서였다. 또한 C 언어 프로젝트로 만들 수 있는 다양한 결과물에 관해서도 설명햇다. 재배치 가능한 목적 파일이 최종 결과물이 아닌 이유도 설명했다
- 심벌이 잘못된 정의와 함께 제공될 때 링커가 어떻게 속는지를 예제로 설명했다.
- C++의 네임 맹글링이라는 특성과 예시에서 나타난 것과 같은 문제를 네임 맹글링을 통해 방지하는 법에 관해 설명했다.



























