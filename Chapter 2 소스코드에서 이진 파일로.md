# Chapter 2 소스코드에서 이진 파일로

프로그래밍의 모든 것은 __소스코드__ 에서 시작한다. 소스 코드 안의 각각의 텍스트 파일은 프로그래밍 언어로 쓰인, 텍스트로 된 명령어를 포함한다.

CPU는 텍스트로 된 명령어를 실행할 수 있다.  CPU가 이를 실행하려면 먼저 기계 수준의 명령어로 컴파일 해야 하고 그 결과 프로그램이 실행된다.

__1. 표준 컴파일 파이프라인__ : C의 표준 컴파일과 컴파일 파이프라인의 여러 단계, 그리고 컴파일 파이프라인을 통해 C 언어의 소스 코드로부터 최종 결과물이 만들어지는 방식을 다룹니다.

__2. 전처리기__ : 전처리 단계를 진행하는 전처리기를 더 자세히 알아보자.

__3. 컴파일러__ : 컴파일러를 더 깊이 들여다본다. 컴파일 단계를 거치며 컴파일러가 소스 코드에서 __중간표현__ 을 만드는 방식과 기계어로 이를 번역하는 방식을 설명한다.

__4. 어셈블러__ : 어셈블러를 설명한다. 어셈블러는 컴파일러로부터 받은 어셈블리 명령어를 기계 수준 명령어로 번역하는 중요한 역할을 수행한다. 어셈블러는 어셈블리 단계를 진행한다.

__5. 링커__ : 링크 단계를 진행하는 링커라는 컴포넌트를 상세히 다룬다. 링커는 C 프로젝ㅈ트의 실제 결과물을 마지막으로 만드는 빌드 컴포넌트이다. 링커에 따라 빌드 오류가 발생할 수 있는데 , 링커를 충분히 안다면 이러한 오류를 방지하고 해결할 수 있다. 또한 C  프로젝트의 다양한 최종 결과물도 살펴보고, 목적파일을 역어셈블링하고 그 내용을 읽는 법도 설명한다. 그리고 C++ 네임맹글링 name mangling 이 무엇인지, C++ 코드를 빌드할 때 네임 맹글링이 링크 단계에서 특정 결함을 어떻게 방지하는지도 간단히 다룬다.



## 2.1 표준 컴파일 파이프라인

C 파일을 몇 개 컴파일할 때는 대개 수 초 정도 걸린다. 이 짧은 순간에도 소스 코드는 다음 네 가지 요소로 구성된 파이프라인으로 진입하며, 각 요소는 특정 작업을 수행한다.

- 전처리기
- 컴파일러
- 어셈블리
- 링커

파이프라인 내부의 각 컴포넌트는 이전 요소로부터 특정한 입력값을 받고, 다음 컴포넌트를 위한 특정 결괏값을 생성한다. 이 과정은 마지막 요소에 의해 __최종 결과물__ 이 만들어질때까지 계속된다.

모든 필수 요소를 성공적으로 통과했다면 소스코도는 최종 결과물로 바뀐다. 즉, 컴포넌트 중 어느 작은 한 단계라도 실패한다면 이는 컴파일 실패 또는 링크 실패로 이어지며, 그에 관한 오류 메시지가 등장한다.

__재배치 가능한 목적 파일 relocatable object file__ 과 같은 어떤 중간 결과물은 소스 파일 하나가 앞의 세 가지 요소만 성공적으로 통과해도 충분히 만들어진다. 마지막 컴포넌트인 링커는 더 큰 결과물을 만들 때 사용하는데 , 이러한 큰 결과물을 __실행 가능한 목적파일 executable object file__ 이라고 한다. 실행 가능한 목적 파일은 이미 준비된, 재배치할 수 있는 목적 파일 몇 개를 합쳐서 만든다. 그러므로 C 소스파일의 모음을 빌드하면 하나 또는 여러 개의 목적 파일을 만들 수 있다. 이러한 목적파일종류로는 재배치가능한 파일과 실행가능한 파일, 공유목적파일이 있다.



2장 전반에 C 컴파일러의 기본 플랫폼과 우리가 사용할 C 컴파일러를 이야기하기 전에, __플랫폼__ 이라는 용어를 좀 더 알아보자.

플랫폼은 특정 하드웨어에서 실행되는 운영체제의 결합이다. 플랫폼 CPU의 명령어 집합은 플랫폼에서 가장 중요한 부분이다. 운영체제는 플랫폼의 소프트웨어 컴포넌트고, 아키텍처는 하드웨어 부분을 뜻한다. 예를 들면 ARM 파워 보드에서 작동하는 우분투 또는 AMD 64비트 CPU에서 작동하는 마이크로소프트 윈도우가 있다.

크로스 플랫폼 소프트웨어는 다른 플랫폼에서 실행할 수 있다. 하지만 크로스 플랫폼이라는 말은 이식 가능한 것과는 다르다는 점을 꼭 알아야 한다. 크로스 플랫폼 소프트웨어는 대개 각 플랫폼에 따라 다른 이진 파일과 인스톨러가 있다. 반면에 이식 가능한 소프트웨어는 모든 플랫폼에서 같은 이진 파일과 인스톨러를 사용한다. 예를 들면 gcc 와  clang 같은 C 컴파일러는 크로스 플랫폼으로서, 다른 플랫폼에서도 코드를 생성할 수 있다. 한편 자바의 바이트코드는 이식 가능하다.

만약 C/C++ 코드가 이식 가능하다고 한다면, 이는 소스 코드에 어떠한 변경이나 수정을 거치지 않고 서로 다른 플랫폼에서 컴파일할 수 있다는 말이다. 그러나 최종 목적 파일에 이식성이 있다는 의미는 아니다.



### 2.1.1 프로젝트 빌드하기

#### 헤더파일 vs 소스파일

- 헤더파일: 일반적으로 이름의 확장자가 .h인 파일
- 소스파일: 확장자가 .c인 파일

헤더파일은 주로 열거형(enumeration), 매크로(macro) 그리고 형식 정의를 포함한다. 그뿐만 아니라 함수의 선언과 전역 변수, 구조체도 포함한다.  C에서는 함수나 변수, 구조체와 같은 몇몇 프로그래밍 요소의 선언을 정의와 분리해 다른 파일에 둘 수 있다. C++도 같은 패턴을 따른다. 하지만 자바와 같은 다른 프로그래밍 언어에서 컴포넌트는 선언한 곳에서 정의한다. 정의로부터 선언을 분리할 수 잇다는 점은 C와 C++의 좋은 특징이지만, 소스코드가 더 복잡해지기도 한다.

일반적으로 선언은 헤더 파일에 저장되며 그에 해당하는 정의는 소스 파일에 저장된다. 함수의 선언과 정의가 별도 파일에 저장된다는 점은 매우 중요하다. 헤더파일에는 함수의 선언만 두고, 함수의 정의는 그에 맞는 소스 파일로 옮기기를 적극 권장한다. 필수는 아니지만, 프로그램 설계 관행상 함수의 정의는 보통 헤더 파일 바깥에 둔다. 구조체 역시 선언과 정의를 분리할 수 있지만, 특별한 경우에만 서로 다른 파일에 둔다. 이에 관한 예제는 클래스 간의 상속 관계를 다르는 8장에서 살표보자.

더 자세히 알아보기 위해 예제를 보자. 함수 선언은 __반환형__ 과 __함수 시그니처__ 로 구성된다. 함수 시그니처는 입력 매개변수의 목록을 갖는 함수의 이름이다.

```c
double average(int*, int);
```

이 선언은 average 라는 이름의 함수 시그니처를 지정한다. 이 함수는 정수 배열을 가리키는 포인터와 배열의 원소 수를 나타내는 정수 인수를 받는다. 또한 선언부분에는 함수가 double값을 반환한다고 명시한다. 반환형은 선언에 속하지만 함수 시그니처에는 속하지는 않으니 유의하자.

함수의 선언은 세미콜론(;)으로 끝난다. 그리고 중괄호로 감싸인 몸체가 없다. 또한 앞의 선언에서 매개변수가 이름을 갖지 않는다는 점을 눈여겨봐야한다. 아는 C언에서 정의가 아닌 선언에만 해당한다. 그렇지만 선언에서도 매개변수의 이름을 짓기를 권장한다.

```c
double average(int* array, int length) {
    if (length <= 0) {
        return 0;
    }
    double sum = 0.0;
    for (int i = 0; i < length; i++) {
        sum += array[i];
    }
    return sum / length;
}
```

앞서 말한 내용을 더 강조하자면 함수의 선언은 헤더 파일에 정의는 소스 파일에 두어야 한다. 이를 위반하는 경우는 드물다. 소스코드가 선언을 확인하고 사용하려면 헤더 파일을 포함해야 하며, C 와 C++은 바로 이러한 방식으로 작동한다.

```
모든 함수와 구조체, 전역 변수는 변환단위 에서 어떤 선언에 관한 정의가 둘 이상일때 컴파일 오류가 발생한다. 그러므로 하나의 선언에 대한 두가지 정의는 허용되지 않는다.
```



#### 예제 소스 파일

다음 예제에는 총 3개의 파일이 있다. 한 개는 헤더 파일, 다른 두 개는 소스 파일이며 세 파일 모두 같은 경로에 있다.

헤더 파일은 2개의 소스 파일 사이를 잇는 다리로 사용된다. 2개의 별도 파일에서 코드를 작성할 수있지만 빌드는 함께 이루어진다. 헤더 파일이 없으면, 소스 파일은 소스에 포함되어서는 안 된다는 아퍼 언급한 원칙을 깨지 않는 한 코드를 2개의 소스 파일로 나눌 수 없다. 여기서 헤더 파일은 한 소스 코드의 기능을 사용하기 위해 다른 소스 코드에 필요한 모든 내용을 포함한다.

헤더파일은 프로그램이 작동하는 데 필요한 함수 선언 avg 하나만을 포함한다,. 소스 파일 중 하나는 선언된 함수의 정의를 포함한다. 다른 소스 파일은 main함수를 포함하는데, 이는 프로그램의 진입점 entry point 이다. main 함수 없이는 프로그램의 실행 파일을 가질 수 없다. main 함수는 컴파일러가 프로그램의 시작점으로 인식하는 것이다. 

```c
#ifndef HEARDER_H

typedef enum{
    NONE,
    NOMAL,
    SQUARED
} average_type_t;

double avg(int* int, average_type_t);

#endif
```

이 파일은 이름이 붙은 정수형 상수의 집합인 열거형을 포함한다. C에서 열거형은 선언과 정의가 분리될 수 없으며, 같은 곳에서 한 번에 선언과 정의가 이루어져야한다.

열거형뿐만 아니라 avg 함수의 __전방 선언 forward declaration__ 도 코드 박스에서 볼 수 있다. 함수를 정의하기 이전에 함수를 선언하는 행위를 전방 선언이라고 한다. 또한 헤더 파일은 __헤더 가드문__ 에 의해서 보호된다. 헤더 가드문은 헤더 파일이 컴파일될때 두 번 또는 그 이상 포함되는 것을 방지한다.

```c
#include "HEADER_H"

double avg(int* array, int length, average_type_t type) {
    if (length <= 0 || type == NONE) {
        return 0;
    }
    double sum = 0.0;
    for (int i = 0; i < length; i++) {
        if (type == NORMAL) {
            sum += array[i];
        } else if (type == SQUARED) {
            sum += array[i] * array[i];
        }
    }
    return sum / length;
}
```

이 코드에서 파일 이름이 .c 확장자로 끝난다는 점을 알아야한다. 소스 파일은 예제의 헤더 파일을 포함한다. average_type_t 열거형과 avg 함수를 사용하기 전에 이에 관한 선언이 필요하기 때문이다. 이번에 사용하는 새로운 자료형인 average_type_t 열거형은 사용 전에 선언하면 컴파일 오류가 발생한다.

```c
#include <stdio,h>
#include "HEADER.H"

int main(int argc, char **argv) {
    int array[5];
    
    array[0] = 10;
    array[1] = 3;
    array[2] = 5;
    array[3] = -8;
    array[4] = 9;
    
    double average = avg(array, 5, NORMAL);
    printf("The average: %f\n", average);
    
    average = avg(array, 5, SQUARED);
    printf("The squared average: %f\n", average);

    return 0;
}
```

main 함수는 정수의 배열을 선언하고 입력 받은 뒤에 서로 다른 두 개의 평균값을 계산했다. 코드에서 main 함수가 avg 함수를 호출하는 방식에 주목하자.



#### 예제 빌드하기

위 3개의 파일을 가져온 다음 빌드해, 프로그램으로 실행될 최종 실행 이진 파일을 만들어야 한다. C/C++ 프로젝트를 빌드한다는 말은 코드베이스 내의 모든 소스 파일을 컴파일해 __재배치 가능한 목적파일__ 을 만들고, 이러한 재배치 가능한 목적 파일을 결합해 __정적라이브러리__ 또는 __실행 이진파일__ 과 같은 최종 결과물을 만들겟다는 뜻이다.

진도를 더 나가기 전에 꼭 기억해야 할 중요한 규칙 두가지가 있다.

- __규칙 1: 소스 파일만 컴파일__ 
  첫 번째 규칙은 소스 파일만 컴파일한다는 것이다. 헤더 파일을 컴파일하는 것은 의미가 없기 때문이다. 헤더 파일은 몇 가지 선언 외에 어떠한 실제 C 코드도 포함하지 않는다. 그러므로 헤더 파일을 제외한 2개의 파일만 컴파일해야한다.
- __규칙 2: 각 소스 파일을 따로따로 컴파일__
  두 번째 규칙은 각 소스 파일을 따로따로 컴파일한다는 것이다. 각 실행에 하나의 소스 파일을 입력해 컴파일러를 두 번 실행해야 한다는 의미이다. 그러므로 100개의 소스 파일로 구성된 하나의 프로젝트라면 각 소스 파일을 모두 띠로 컴파일해야 하며, 이는 곧 컴파일러를 100번 실행한다는 의미이다.

```
만약 컴파일이 필요한 C 코드를 헤더 파일이 포함하더라도 해당 파일을 컴파일하지는 않는다. 대신, 이 헤더 파일을 소스 파일에 포함시킨 뒤 소스 파일을 컴파일한다. 이러한 방식으로 헤더의 C 코드가 소스 파일에 속해 컴파일된다.
```

소스파일을 컴파일할 때 소스 파일은 컴파일되지 않는다. 소스 파일에는 다른 소스 파일이 포함되지 않기 때문이다.  C/C++ 의 모범 사례를 따른다면 소스 파일을 소스 파일에 포함하는 것은 허용되지 않는다는 걸 명심하자.



### 2.1.2 1단계 : 전처리







