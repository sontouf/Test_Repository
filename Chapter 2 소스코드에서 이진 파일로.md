# Chapter 2 소스코드에서 이진 파일로

프로그래밍의 모든 것은 __소스코드__ 에서 시작한다. 소스 코드 안의 각각의 텍스트 파일은 프로그래밍 언어로 쓰인, 텍스트로 된 명령어를 포함한다.

CPU는 텍스트로 된 명령어를 실행할 수 있다.  CPU가 이를 실행하려면 먼저 기계 수준의 명령어로 컴파일 해야 하고 그 결과 프로그램이 실행된다.

__1. 표준 컴파일 파이프라인__ : C의 표준 컴파일과 컴파일 파이프라인의 여러 단계, 그리고 컴파일 파이프라인을 통해 C 언어의 소스 코드로부터 최종 결과물이 만들어지는 방식을 다룹니다.

__2. 전처리기__ : 전처리 단계를 진행하는 전처리기를 더 자세히 알아보자.

__3. 컴파일러__ : 컴파일러를 더 깊이 들여다본다. 컴파일 단계를 거치며 컴파일러가 소스 코드에서 __중간표현__ 을 만드는 방식과 기계어로 이를 번역하는 방식을 설명한다.

__4. 어셈블러__ : 어셈블러를 설명한다. 어셈블러는 컴파일러로부터 받은 어셈블리 명령어를 기계 수준 명령어로 번역하는 중요한 역할을 수행한다. 어셈블러는 어셈블리 단계를 진행한다.

__5. 링커__ : 링크 단계를 진행하는 링커라는 컴포넌트를 상세히 다룬다. 링커는 C 프로젝ㅈ트의 실제 결과물을 마지막으로 만드는 빌드 컴포넌트이다. 링커에 따라 빌드 오류가 발생할 수 있는데 , 링커를 충분히 안다면 이러한 오류를 방지하고 해결할 수 있다. 또한 C  프로젝트의 다양한 최종 결과물도 살펴보고, 목적파일을 역어셈블링하고 그 내용을 읽는 법도 설명한다. 그리고 C++ 네임맹글링 name mangling 이 무엇인지, C++ 코드를 빌드할 때 네임 맹글링이 링크 단계에서 특정 결함을 어떻게 방지하는지도 간단히 다룬다.



## 2.1 표준 컴파일 파이프라인

C 파일을 몇 개 컴파일할 때는 대개 수 초 정도 걸린다. 이 짧은 순간에도 소스 코드는 다음 네 가지 요소로 구성된 파이프라인으로 진입하며, 각 요소는 특정 작업을 수행한다.

- 전처리기
- 컴파일러
- 어셈블리
- 링커

파이프라인 내부의 각 컴포넌트는 이전 요소로부터 특정한 입력값을 받고, 다음 컴포넌트를 위한 특정 결괏값을 생성한다. 이 과정은 마지막 요소에 의해 __최종 결과물__ 이 만들어질때까지 계속된다.

모든 필수 요소를 성공적으로 통과했다면 소스코도는 최종 결과물로 바뀐다. 즉, 컴포넌트 중 어느 작은 한 단계라도 실패한다면 이는 컴파일 실패 또는 링크 실패로 이어지며, 그에 관한 오류 메시지가 등장한다.

__재배치 가능한 목적 파일 relocatable object file__ 과 같은 어떤 중간 결과물은 소스 파일 하나가 앞의 세 가지 요소만 성공적으로 통과해도 충분히 만들어진다. 마지막 컴포넌트인 링커는 더 큰 결과물을 만들 때 사용하는데 , 이러한 큰 결과물을 __실행 가능한 목적파일 executable object file__ 이라고 한다. 실행 가능한 목적 파일은 이미 준비된, 재배치할 수 있는 목적 파일 몇 개를 합쳐서 만든다. 그러므로 C 소스파일의 모음을 빌드하면 하나 또는 여러 개의 목적 파일을 만들 수 있다. 이러한 목적파일종류로는 재배치가능한 파일과 실행가능한 파일, 공유목적파일이 있다.



2장 전반에 C 컴파일러의 기본 플랫폼과 우리가 사용할 C 컴파일러를 이야기하기 전에, __플랫폼__ 이라는 용어를 좀 더 알아보자.

플랫폼은 특정 하드웨어에서 실행되는 운영체제의 결합이다. 플랫폼 CPU의 명령어 집합은 플랫폼에서 가장 중요한 부분이다. 운영체제는 플랫폼의 소프트웨어 컴포넌트고, 아키텍처는 하드웨어 부분을 뜻한다. 예를 들면 ARM 파워 보드에서 작동하는 우분투 또는 AMD 64비트 CPU에서 작동하는 마이크로소프트 윈도우가 있다.

크로스 플랫폼 소프트웨어는 다른 플랫폼에서 실행할 수 있다. 하지만 크로스 플랫폼이라는 말은 이식 가능한 것과는 다르다는 점을 꼭 알아야 한다. 크로스 플랫폼 소프트웨어는 대개 각 플랫폼에 따라 다른 이진 파일과 인스톨러가 있다. 반면에 이식 가능한 소프트웨어는 모든 플랫폼에서 같은 이진 파일과 인스톨러를 사용한다. 예를 들면 gcc 와  clang 같은 C 컴파일러는 크로스 플랫폼으로서, 다른 플랫폼에서도 코드를 생성할 수 있다. 한편 자바의 바이트코드는 이식 가능하다.

만약 C/C++ 코드가 이식 가능하다고 한다면, 이는 소스 코드에 어떠한 변경이나 수정을 거치지 않고 서로 다른 플랫폼에서 컴파일할 수 있다는 말이다. 그러나 최종 목적 파일에 이식성이 있다는 의미는 아니다.



### 2.1.1 프로젝트 빌드하기

#### 헤더파일 vs 소스파일

- 헤더파일: 일반적으로 이름의 확장자가 .h인 파일
- 소스파일: 확장자가 .c인 파일

헤더파일은 주로 열거형(enumeration), 매크로(macro) 그리고 형식 정의를 포함한다. 그뿐만 아니라 함수의 선언과 전역 변수, 구조체도 포함한다.  C에서는 함수나 변수, 구조체와 같은 몇몇 프로그래밍 요소의 선언을 정의와 분리해 다른 파일에 둘 수 있다. C++도 같은 패턴을 따른다. 하지만 자바와 같은 다른 프로그래밍 언어에서 컴포넌트는 선언한 곳에서 정의한다. 정의로부터 선언을 분리할 수 잇다는 점은 C와 C++의 좋은 특징이지만, 소스코드가 더 복잡해지기도 한다.

일반적으로 선언은 헤더 파일에 저장되며 그에 해당하는 정의는 소스 파일에 저장된다. 함수의 선언과 정의가 별도 파일에 저장된다는 점은 매우 중요하다. 헤더파일에는 함수의 선언만 두고, 함수의 정의는 그에 맞는 소스 파일로 옮기기를 적극 권장한다. 필수는 아니지만, 프로그램 설계 관행상 함수의 정의는 보통 헤더 파일 바깥에 둔다. 구조체 역시 선언과 정의를 분리할 수 있지만, 특별한 경우에만 서로 다른 파일에 둔다. 이에 관한 예제는 클래스 간의 상속 관계를 다르는 8장에서 살표보자.

더 자세히 알아보기 위해 예제를 보자. 함수 선언은 __반환형__ 과 __함수 시그니처__ 로 구성된다. 함수 시그니처는 입력 매개변수의 목록을 갖는 함수의 이름이다.

```c
double average(int*, int);
```

이 선언은 average 라는 이름의 함수 시그니처를 지정한다. 이 함수는 정수 배열을 가리키는 포인터와 배열의 원소 수를 나타내는 정수 인수를 받는다. 또한 선언부분에는 함수가 double값을 반환한다고 명시한다. 반환형은 선언에 속하지만 함수 시그니처에는 속하지는 않으니 유의하자.

함수의 선언은 세미콜론(;)으로 끝난다. 그리고 중괄호로 감싸인 몸체가 없다. 또한 앞의 선언에서 매개변수가 이름을 갖지 않는다는 점을 눈여겨봐야한다. 아는 C언에서 정의가 아닌 선언에만 해당한다. 그렇지만 선언에서도 매개변수의 이름을 짓기를 권장한다.

```c
double average(int* array, int length) {
    if (length <= 0) {
        return 0;
    }
    double sum = 0.0;
    for (int i = 0; i < length; i++) {
        sum += array[i];
    }
    return sum / length;
}
```

앞서 말한 내용을 더 강조하자면 함수의 선언은 헤더 파일에 정의는 소스 파일에 두어야 한다. 이를 위반하는 경우는 드물다. 소스코드가 선언을 확인하고 사용하려면 헤더 파일을 포함해야 하며, C 와 C++은 바로 이러한 방식으로 작동한다.

```
모든 함수와 구조체, 전역 변수는 변환단위 에서 어떤 선언에 관한 정의가 둘 이상일때 컴파일 오류가 발생한다. 그러므로 하나의 선언에 대한 두가지 정의는 허용되지 않는다.
```



#### 예제 소스 파일

다음 예제에는 총 3개의 파일이 있다. 한 개는 헤더 파일, 다른 두 개는 소스 파일이며 세 파일 모두 같은 경로에 있다.

헤더 파일은 2개의 소스 파일 사이를 잇는 다리로 사용된다. 2개의 별도 파일에서 코드를 작성할 수있지만 빌드는 함께 이루어진다. 헤더 파일이 없으면, 소스 파일은 소스에 포함되어서는 안 된다는 아퍼 언급한 원칙을 깨지 않는 한 코드를 2개의 소스 파일로 나눌 수 없다. 여기서 헤더 파일은 한 소스 코드의 기능을 사용하기 위해 다른 소스 코드에 필요한 모든 내용을 포함한다.

헤더파일은 프로그램이 작동하는 데 필요한 함수 선언 avg 하나만을 포함한다,. 소스 파일 중 하나는 선언된 함수의 정의를 포함한다. 다른 소스 파일은 main함수를 포함하는데, 이는 프로그램의 진입점 entry point 이다. main 함수 없이는 프로그램의 실행 파일을 가질 수 없다. main 함수는 컴파일러가 프로그램의 시작점으로 인식하는 것이다. 

```c
#ifndef HEARDER_H

typedef enum{
    NONE,
    NOMAL,
    SQUARED
} average_type_t;

double avg(int* int, average_type_t);

#endif
```

이 파일은 이름이 붙은 정수형 상수의 집합인 열거형을 포함한다. C에서 열거형은 선언과 정의가 분리될 수 없으며, 같은 곳에서 한 번에 선언과 정의가 이루어져야한다.

열거형뿐만 아니라 avg 함수의 __전방 선언 forward declaration__ 도 코드 박스에서 볼 수 있다. 함수를 정의하기 이전에 함수를 선언하는 행위를 전방 선언이라고 한다. 또한 헤더 파일은 __헤더 가드문__ 에 의해서 보호된다. 헤더 가드문은 헤더 파일이 컴파일될때 두 번 또는 그 이상 포함되는 것을 방지한다.

```c
#include "HEADER_H"

double avg(int* array, int length, average_type_t type) {
    if (length <= 0 || type == NONE) {
        return 0;
    }
    double sum = 0.0;
    for (int i = 0; i < length; i++) {
        if (type == NORMAL) {
            sum += array[i];
        } else if (type == SQUARED) {
            sum += array[i] * array[i];
        }
    }
    return sum / length;
}
```

이 코드에서 파일 이름이 .c 확장자로 끝난다는 점을 알아야한다. 소스 파일은 예제의 헤더 파일을 포함한다. average_type_t 열거형과 avg 함수를 사용하기 전에 이에 관한 선언이 필요하기 때문이다. 이번에 사용하는 새로운 자료형인 average_type_t 열거형은 사용 전에 선언하면 컴파일 오류가 발생한다.

```c
#include <stdio,h>
#include "HEADER.H"

int main(int argc, char **argv) {
    int array[5];
    
    array[0] = 10;
    array[1] = 3;
    array[2] = 5;
    array[3] = -8;
    array[4] = 9;
    
    double average = avg(array, 5, NORMAL);
    printf("The average: %f\n", average);
    
    average = avg(array, 5, SQUARED);
    printf("The squared average: %f\n", average);

    return 0;
}
```

main 함수는 정수의 배열을 선언하고 입력 받은 뒤에 서로 다른 두 개의 평균값을 계산했다. 코드에서 main 함수가 avg 함수를 호출하는 방식에 주목하자.



#### 예제 빌드하기

위 3개의 파일을 가져온 다음 빌드해, 프로그램으로 실행될 최종 실행 이진 파일을 만들어야 한다. C/C++ 프로젝트를 빌드한다는 말은 코드베이스 내의 모든 소스 파일을 컴파일해 __재배치 가능한 목적파일__ 을 만들고, 이러한 재배치 가능한 목적 파일을 결합해 __정적라이브러리__ 또는 __실행 이진파일__ 과 같은 최종 결과물을 만들겟다는 뜻이다.

진도를 더 나가기 전에 꼭 기억해야 할 중요한 규칙 두가지가 있다.

- __규칙 1: 소스 파일만 컴파일__ 
  첫 번째 규칙은 소스 파일만 컴파일한다는 것이다. 헤더 파일을 컴파일하는 것은 의미가 없기 때문이다. 헤더 파일은 몇 가지 선언 외에 어떠한 실제 C 코드도 포함하지 않는다. 그러므로 헤더 파일을 제외한 2개의 파일만 컴파일해야한다.
- __규칙 2: 각 소스 파일을 따로따로 컴파일__
  두 번째 규칙은 각 소스 파일을 따로따로 컴파일한다는 것이다. 각 실행에 하나의 소스 파일을 입력해 컴파일러를 두 번 실행해야 한다는 의미이다. 그러므로 100개의 소스 파일로 구성된 하나의 프로젝트라면 각 소스 파일을 모두 띠로 컴파일해야 하며, 이는 곧 컴파일러를 100번 실행한다는 의미이다.

```
만약 컴파일이 필요한 C 코드를 헤더 파일이 포함하더라도 해당 파일을 컴파일하지는 않는다. 대신, 이 헤더 파일을 소스 파일에 포함시킨 뒤 소스 파일을 컴파일한다. 이러한 방식으로 헤더의 C 코드가 소스 파일에 속해 컴파일된다.
```

소스파일을 컴파일할 때 소스 파일은 컴파일되지 않는다. 소스 파일에는 다른 소스 파일이 포함되지 않기 때문이다.  C/C++ 의 모범 사례를 따른다면 소스 파일을 소스 파일에 포함하는 것은 허용되지 않는다는 걸 명심하자.



### 2.1.2 1단계 : 전처리

 컴파일 파이프라인의 첫 단계는 __전처리__ 이다. 소스파일은 수많은 헤더 파일을 포함한다. 하지만 컴파일이 시작되기 전에 전처리기가 헤더 파일의 내용을 모아서 하나의 c 코드 몸체로 만든다. 즉, 전처리 단계 이후에는 헤더 파일의 내용을 소스 파일로 복사해 만들어진 한 덩어리의 코드를 얻는다.

 또한 다른 __전처리기 지시자__ 는 이 단계에서 반드시 해결되어야 한다. 전처리된 코드는 __변환단위__ 라고 한다. 변환 단위는 전처리기가 생성한 c 언어 코드의 하나의 논리단위로, 컴파일될 준비를 마친 것이다. 변환 단위는 __컴파일 단위__ 라고도 한다.

```
변환 단위에서 전처리기 지시자는 찾을 수 없다. 앞서 나온 내용을 떠올려 보면 모든 전처리기 지시자는 #으로 시작한다. 예를 들면 #include와 #define 이 있다.
```

 컴파일러에 더 컴파일하지 말고 변환 단위로 덤프하라고 요청할 수 있다. gcc의 경우에는 -E 옵션을 전ㄷ날하면 된다. 몇몇 드문 경우, 특히 코스 플랫폼을 개발할 때 변환 단위를 검사하면 이상한 이슈를 고칠 때 유용하다.

```c
$gcc -E ~~~~~
    

typedef enum{
    NONE,
    NOMAL,
    SQUARED
} average_type_t;

double avg(int* int, average_type_t);

#endif

double avg(int* array, int length, average_type_t type) {
    if (length <= 0 || type == NONE) {
        return 0;
    }
    double sum = 0.0;
    for (int i = 0; i < length; i++) {
        if (type == NORMAL) {
            sum += array[i];
        } else if (type == SQUARED) {
            sum += array[i] * array[i];
        }
    }
    return sum / length;
}
```

 모든 선언은 헤더 파일에서 변환 단위로 복제되었다. 또한 주석은 변환 단위에서 제거되었다.

main.c 의 변환다누이는 매우 크다. stdio.h 헤더 파일을 포함하기 때문이다. 이 헤더 파일의 모든 선언과 선언에 의해 포함된 헤더 파일의 내용은 재귀적으로 변환 단위에 복사된다. 

```
-E 옵션은 clang 컴파일러에서도 작동한다.
```



### 2.1.3 2단계 : 컴파일

변환단위를 얻고 나면 두 번째 단계인 컴파일을 진행할 수 있다. 컴팡리 단계에서는 이전 단계에서 얻은 변환 단위를 입력하고, 그에 해당하는 __어셈블리 코드__ 를 출력한다. 이 어셈블리 코드는 여전히 사람이 읽을 수는 있지만, 머신 의존적인 데다가 하드웨어에 더 가깝고 기계수준명령어가 되려면 처리가 더 진행되어야 한다.

 두 번쨰 단계를 수행한 뒤에도 언제든지 gcc로 중지 요청을 할 수 있으며, 컴파일 결과로 얻은 어셈블리 코드에 -S 옵션을 써서 덤프할 수 있다. 컴파일 출력 결과는 원래의 소스 코드와 같은 이름이지만 .s 확장자가 붙는다.



 컴파일 단계에서 컴파일러는 변환 단위를 구문 분석하고 이를 __대상 아키텍처__ 에 맞는 어셈블리 코드로 변환한다. 대상 아키텍처란 프로그램이 컴파일되어 실행될 하드웨어나 CPU를 뜻한다. 대상 아키텍처는 호스트아키텍처라고도 한다.

 C 코드에서 어셈블리 코드를 생성하는 일은 컴파일 파이프라인에서 가장 중요한 단계이다. 어셈블리 코드를 얻으면  CPU가 실행할 수 있는 언어와 매우 가까워진다. 이 역할의 중요성 때문에 컴파일러는 컴퓨터 과학에서 가장 많이 연구되는 주요 주제가 되었다.



### 2.1.4 3단계 : 어셈블리

컴파일 다음 단계는 어셈블리이다. 어셈블리 단계의 목적은 실질적인 기계수준명령어를 만드는 것으로, 이전의 단계에서 컴파일러가 만든 어셈블리 코드에 기반해 기계수준 명령어를 만든다. 각 아키텍처는 고유의 어셈블러를 가지며, 이 어셈블러는 아키텍처의 고유한 어셈블리 코드를 해당 아키텍처의 기계어로 변환할 수 있다.

이 절에서 우리가 어셈블하려는 기계 수준의 명령어를 포함하는 파일을 __목적 파일__ 이라고 한다. C 언어 프로젝트는 모두 목적 파일로 이루어진 최종 결과물을 가질 수도 있다. 이번에는 재배치 가능한 목적파일에 집중해보자. 재배치 가능한 목적파일은 빌드 단계에서 얻을 수 있는 가장 중요한 임시 파일이다.

이전의 두 단계를 상기해보면 어셈블리 단계의 목적은 컴파일러가 만든 어셈블리 코드로부터 재배치 가능한 목적 파일을 생성하는 데 있다. 모든 다른 결과물도 이 단계에서 어셈블러가 생성한 재배치 가능한 목적 파일에 기반한다.

유닉스 계열 운영체제에서 어셈블러 도구는 as라고 한다. as는 어셈블리 파일에서 재배치 가능한 목적파일을 만드는 데 사용할 수 있다.

하지만 이러한 재배치 가능한 목적 파일은 실행할 수 없다. 이 파일은 변환단위에서 생성된 기계수준의 명령어만 ㅗ함한다. 각 변환  단위는 다양한 함수와 전역변수로 구성되므로, 재배치 가능한 목적 파일은 소스 파일의 함수에 해당하는 기계수준의 명령어 및 전역 변수를 위해 미리 할당된 항목만 포함한다.

```shell
$ as file.s -o file.o
```

 이 셸 박스의 명령어를 보면 출력되는 목적 파일의 이름을 지정하기 위해 -o 옵션이 사용된다. 재배치 가능한 목적 파일은 대개 이름에 .o 확장자가 붙으므로 (윈도우에서는 .obj) 파일 이름에 .o를 붙여 입력했다.

.o 또는 .obj 파일의 내용은 텍스트가 아니어서 우리가 읽을 수 없다. 그러므로 목적 파일은 일반저긍로 이진으로 된 내용물을 갖는다고 할 수 있다. 위 셸 박스처럼 어셈블러는 직접 사용할 수도 있지만 권장하지는 않는다. 대신 재배치 가능한 목적 파일을 생성하도록 컴파일러 자체를 사용해 as를 간접적으로 호출하는 것이 좋다.



알려진 거의 모든 c 컴파일러로 -c 옵션을 전달한다면, 컴파일러는 곧바로 소스 파일을 그에 해당하는 목적 파일로 만든다. 즉, -c 옵션은 컴파일의 앞부분 세 단계를 한 번에 수행하도록 한다.

다음 예제를 보면 -c 옵션을 이용해 file.c 를 컴파일한뒤 목적 파일을 생성했음을 확인할 수 있다.

```shell
$ gcc -c file.c
```

이전에 수행한 모든 단계인 전처리, 컴파일, 어셈블리가 이 명령어 하나로 수행된다. 이는 -c 명령어를 실행한 뒤 재배치 가능한 목적 파일이 만들어진다는 의미이다. 재배치 가능한 목적 파일의 이름은 입력한 소스 파일의 이름과 같다. 하지만 .o 확장자를 가진다는 점에서 다르다.

```
컴파일이라는 용어는 두 번째 단계만이 아니라 앞의 컴파일 세 단계를 모두 나타낼 때도 있다. 또한 컴파일이라는 용어를 사용하더라도, 이는 실제로 네 단계를 모두 아우르는 빌드를 뜻할 수 도 있다. 가령 c의 컴파일 파이프라인이라고 한다면 실제로는 c의 빌드 파이프라인을 의미한다.
```

어셈블리는 하나의 소스 파일을 컴파일하는 마지막 단계이다. 즉, 소스 파일 하나에 해당하는 재배치 가능한 목적 파일을 얻으면 컴파일이 완료된 것이다. 이 단계에서는 이미 얻은 재배치 가능한 목적 파일을 얻으면 컴파일이 완료된 것이다. 이 단계에서는 이미 얻은 재배치 가능한 목적 파일 외에 다른 소스 파일을 계속 컴파일할 수 있다.

여기서, 재배치 가능한 목적 파일이 실행 파일이 아니라는 점을 알아두어야 한다. 만약 어떤 프로젝트에서 최종 결과물로 실행 파일을 얻으려면, 링크 단계를 거쳐 대상 실행파일을 빌드하기 위해 모두, 또는 아주 최소한, 또는 몇몇 개의 이미 만들어진 재배치 가능한 목적 파일을 사용해야한다.



### 2.1.5 4단계 : 링크

main함수가 main.c에 있다면 이를 실행 파일로 빌드해야 한다. 하지만 지금은 앞 선 예시로 두 개의 재배치 가능한 목적파일만 있다. 그러므로 다음 단계에서는 다른 실행 가능한 목적 파일로 만들기 위해 이러한 재배치 가능한 목적 파일을 결합해야 한다. __링크__ 단계에서 바로 이러한 일을 한다.

링크 단계로 넘어가기 위해, 유닉스 계열 운영체제에서 새로운 아키텍처 또는 하드웨어를 위해 추가로 지원할 수 있는지 부터 살펴보자.



##### 새 아키텍처 지원하기

모든 아키텍처는 제조사가 만든 일련의 프로세서가 있으며, 이 프로세서는 모두 특정 명령어 집합을 실행할 수있다.

명령어 집합은 인텔이나 ARM 같은 제조사가 자사의 프로세서를 위해 설계한 것이다. 그리고 제조사는 자사의 아키텍처를 위한 특정 어셈블리어도 설계한다.

새로운 아키텍처를 위한 프로그램은 다음의 선행 조건 두 가지를 충족하면 빌드할 수있다.

- 어셈블리어가 알려져 있다.
- 제조사에 의해 개발된 필수 어셈블러 도구가 있어야 한다. 이를 사용해 어셈블리 코드를 그에 해당하는 기계어 수준 명령어로 변환할 수 있다.

이러한 선행 조건이 갖춰지면 소스 코드에서 기계 수준의 명령어를 생성할 수 잇다. 그래야 목적 파일 포맷을 이용해 목적 파일 안에 기계수준의 명령어를 저장할 수있다. 예를 들면 ELF 또는 Mach-O라는 형태가 될 수 있다.

어셈블리어, 어셈블러 도구 그리고 목적 파일 포멧이 명확하다면 C 언어 개발자에게 필수인 다른 툴을 개발할 때 이 세가지 도구를 활용할 수 있다. 하지만 우리는 C 컴파일러를 자주 다루며 컴파일러가 개발자를 대신해 이 도구들을 사용하므로, 이들에 관해서는 잘 몰랐을 것이다.

- C 컴파일러
- 링커

이 도구들은 운영체제에서 새 아키텍처를 지원하는 첫 번째 필수 요소와도 같다. 운영체제에서 이러한 도구가 있는 하드웨어는 새로운 플랫폼을 만들 수 있다.

유닉스 계열 운영체제의 경우에는 유닉스에 모듈러 디자인이 있다는 점을 꼭 기억해야한다. 어셈블러, 컴파일러, 링커와 같은 몇 개의 기초 모듈을 만들 수 있다면, 그것으로 곧 다른 모듈도 만들 수 있으며, 전체 시스템이 새로운 아키텍처에서 작동할 수 있다.



#### 단계 세부 사항

앞서 살펴봤듯, 유닉스 계열의 운영체제를 사용하는 플랫폼은 작업을 위해 앞에서 언급한 필수 도구인 어셈블러나 링커가 반드시 있어야 한다. 어셈블러와 링커는 컴파일러와 별도로 실행할 수 있다는 점을 기억하자.

유닉스 계열 운영체제에서 ld는 기본 링커이다. 다음 셸 박스에서 볼 수  있는 명령어는 앞에서 만든 재배치 가능한 목적파일로부터 실행 파일을 만들 때 ld를 직접적으로 사용하는 방식을 보여준다. 그러나 곧 알게 되겠지만, 링커를 직접 사용하기란 쉽지 않다.



```shell
$ ld impl.o main.o
ld: warning: cannot find entry symbol _start; defaulting to 000000004000e8
main.o : In function 'main':
main.c :(.text+0x7a): undefined reference to 'printf'
main.c :(.text+0xb7): undefined reference to 'printf'
main.c :(.text+0xd0): undefined reference to '__stack_chk_fail' 
```

 보다시피 명령어가 실패해 오류 메시지가 나온다. 오류 메시지를 잘 살펴보면, 텍스트 세그먼트 ld의 세 지점에서 정의되지 않은 세번의 함수 호출이 발생했다고 한다.

세 번의 호출 중 두 번은 printf 함수를 호출하는 데 이는 main 함수에서 수행한 것이다. 하지만 다른 하나인 `__stack_chk_fail` 은 우리가 호출한 것이 아니다. 다른 어딘가에서 온 것인데, 어디일까? 컴파일러가 재배치 가능한 목작 파일에 넣은 보충 코드에서 호출되었다. 이 함수는 리눅스 전용이므로 다른 플랫폼에서 생성된 동일한 목적 파일에서는 볼 수 없다. 이 함수가 무엇이고 어떤 일을 하든 간에, 링커는 제공된 목적 파일에서 찾을 수 없는 정의를 찾고 있다.

앞서 말햇듯 기본 링커인 ld 는 오류 메시지를 냇다. 함수의 정의를 찾을 수 없엇기 때문이다. 논리적으로 이는 타당하며 참이다. `printf` 와 `__stack_chk_fail` 을 정의하지 않았기 때문이다.

이는 ld 로 다른 목적 파일을 제공해야 한다는 의미인데, 반드시 재배치 가능한 목적 파일일 필요는 없으며 `printf`와 `__stack_chk_fail` 함수를 포함하는 다른 목적 파일이면 된다. 앞의 내용을 읽어보면 ld 를 직접 사용하는 것이 왜 어려운지 설명된다. 즉, ld 가 작동해 실행 파일을 만들려면 지정되어야 할 목적 파일과 옵션이 더 많이 필요한다. 다행히 우닉스 계열 운영체제에서 가장 유명한 C 언어 컴파일러는 적절한 옵션을 전달하고, 추가로 더 필요한 목적파일을 지정해 ld를 사용한다. 따라서 ld 를 직접 사용할 필요는 없다.

```
프로젝트를 빌드한다는 것은 소스를 먼저 컴파일한 다음, 컴파일 결과물 도는 다른 라이브러리와 함께 링크해 최종 파일을 만드는 것이다.
```

지금까지 한 작업을 돌아보자. 소스코드를 재배치 가능한 목적 파일로 컴파일 했고, 컴파일로 생선한 목적 파일을 링크해 성공적으로 빌드햇으며 최종 실행 이진 파일을 만들었다.

어떤 C/C++ 코드베이스라도 이 과정은 같다. 하지만 소스를 컴파일하는 데 필요한 횟수는 프로젝트 내의 소스 파일의 개수에 따라 다르다.

컴파일 파이프라인은 여러 단계가 있으며 각 단계에는 그와 관련된 특정 컴포넌트가 있다. 2장의 나머지 부분에서는 컴파일 파이프라인의 각각의 컴포넌트를 둘러싼 필수 정보를 자세히 살펴보자.



## 2.2 전처리기

1장에서는 전처리기의 개념을 간략하게 소개햇다. 특히 매크로, 조건부 컴파일, 헤더 가드를 설명했다. 앞선 소개에서 C 언어의 필수요소로 전처리기를 설명했음을 기억하자. 다른 프로그래밍 언어에서는 쉽게 발견할 수 없다는 점에서 전처리기는 독특하다. 아주 간단히 말하자면, 전처리기는 컴파일러로 소스 코드를 보내기 전에 소스  코드를 수정할 수 있도록 한다. 이와 동시에 소스코드를 헤더 파일로 나누어서 나중에 여러개의 다른 소스 파일에 포함할 수 있도록 하며, 선언을 재사용할 수 있도록 한다.  소스코드에 문법 오류가 있다면, 전처리기는 C 언어 문법을 전혀 모르기 때문에 오류를 찾지 못한다. 그 대신 텍스트 치환을 위주로 하는 몇가지 쉬운 작업만 수행할 뿐이다.

```c
#include <stdio.h>
#define file 1000

hello, this is just a simple text file but ending with .C extension!
This is not a C file for sure!
But we can preprocess it!
```

```c
hello, this is just a simple text 1000 but ending with .C extension!
This is not a C 1000 for sure!
But we can preprocess it!
```

주의 깊게 살펴보면 흥미로운 치환이 이루어졋음을 알 수 있다. 텍스트 안의 file 이 1000으로 교체되었다.

이 예제는 전처리가 작동하는 방식을 정확히 보여준다. 전처리기는 파일의 내용을 복제하거나 텍스트 치환을 통해 매크로를 확장함으로써 포함과 같은  단순한 일만 수행한다. 전처리기는 C 언어는 전혀 모른다. 전처리기가 다른 일을 추가로 수행하려면 입력 파일을 구문 분석하는 파서가 필요하다. 즉, 전처리기는 파서를 이용해서 입력 코드에서 지시자를 찾는다.

```
일반적으로 파서란 추가적인 분석과 처리를 위해 입력 데이터를 처리하고 데이터의 특정부분을 추출하는 프로그램이다. 파서는 입력 데이터의 구조를 알아야 한다. 입력 데이터를 더 작게 나누어서 유용한 데이터를 얻기 위해서이다.
```



전처리기의 파서는 C 컴파일러가 사용하는 파서와 다르다. 전처리기의 파서는 C 언어의 문법과는 거의 독립적인 문법을 사용하기 때문이다. 그렇기에 C 파일을 전처리할 때 외에도 전처리기의 파서를 사용할 수 있다.

```
전처리기의 기능을 명확하게 이해하면, 프로그램을 비드하는 것 외의 다른 목적을 위해 파일을 포함하고 매크로를 확장할 수 있다. C 언어의 전처리기는 다른 텍스트 파일을 처리할 때도 사용할 수 있다.
```



마지막으로 설명할 내용은 .i 확장자를 가진 파일을 C 컴파일러에 입력할 때 전처리 단계를 건너뛴다는 점이다 .i 확장자를 가진 파일은 이미 전처리되었으므로 곧바로 컴파일 단계로 보내야 한다.

만약 .i 확장자를 가진 파일을 C 전처리기에 입력하겠다고 고집하면, 다음과 같은 경고 메시지를 받는다.



## 2.3 컴파일러

앞에서 설명한 대로 컴파일러는 전처리기가 준비한 변환 단위를 받고 그에 해당하는 어셈블리 명령어를 생성한다. 여러 소스 파일이 어셈블리 코드로 컴파일될때, 플랫폼에서 어셈블러나 같은 기존의 도구는 나머지 작업을 맡는다. 생성된 어셈블리 코드에서 재배치 가능한 목적 파일을 만들고 마지막으로는 이 파일을 함께 링크하낟. 그러면 라이브러리나 실행 파일을 만들게 된다.

C 언어 개발을 위해 유닉스에서 사용할 수 있는 여러 도구 가운데 as 와 ld 두가지를 예시로 설명햇다. 이 도구는 플랫폼에 따라 호환 가능한 목적 파일을 만들 때 주로 사용된다. 이 도구는 gcc 또는 다른 컴파일러의 외부에 반드시 존재한다. 컴파일러 외부에 존재함으로써 gcc 에 포함되어 개발되지는 않음을 의미하며, 심지어 설치된 gcc 가 없더라도 어떤 플랫폼에서도 사용할 수 있어야 한다. gcc는 이러한 도구를 컴파일 단계에서만 사용하며, 해당 도구는 gcc 에 포함되지는 않는다.

이는 프로세스가 허용하는 명령어 집합과 운영체제에 맞는 형식과 규칙을 가장 잘 아는 개체가 바로 플랫폼이기 때문이다. 컴파일러는 변환 단위에서 최적화하지 않는 이상 이러한 제한을 잘 알지 못한다. 따라서 gcc 가 하는 중요한 일이란, 변환 단위를 어셈블리 명령어로 번역하는 것이라고 결론 내릴 수 있다. 이것이 바로 컴파일이다.

컴파일할 때 어려운 점 중 하나는 대상 아키텍처가 허용하는 올바른 어셈블리 명령어를 생성해내는 일이다. ARM, 인텔 x86, AMD 그리고 더 많은 다양한 아키텍처에서 gcc를 사용해 같은 C 코드를 컴파일할 수 있다. 앞서 이야기한 대로 아키텍처마다 각자의 프로세서가 수용하는 명령어 집합이 있으며, gcc는 특정 아키텍처에 관한 올바른 어셈블리 코드를 생성하는 역할을 맡은 유일한 개체이다.

gcc 가 이러한 어려움을 극복하는 방식은 미션을 2단계로 나누는 것이다. 첫 번째는 변환 단위를 구문 분석한뒤 , 이를 재배치 가능하며 C에 독립적인 데이터 구조, 즉 __추상구문트리 abstract syntax tree(AST)__ 로 변환하는 것이다. 그다음 AST를 사용해 대상 아키텍처에 맞는 어셈블리 명령어를 생성한다. 첫 번째 단계는 아키텍처에 독립적이며 대상 명령어 집합에 상관없이 수행할 수 잇다. 그러나 두 번째 단계는 아키텍처 의존적이므로 컴파일러가 대상 명령어 집합에 관해 알아야 한다. 첫 번째 단계를 수행하는 하위 요소를 __컴파일러 프런트엔트__  라고 하며, 두 번째 단계를 수행하는 하위 요소는 __컴파일러 백엔드__ 라고 한다.



### 2.3.1 추상 구문 트리

앞에서 설명했듯이 컴파일러 프런트엔드는 변환 단위를 구문 분석해 중간 단계의 자료 구조를 만든다. 컴파일러는 C 의 문법에 따라 소스코드를 분석해 이러한 중간 단계 자료 구조를 만들고, 이 결과를 아키텍처에 의존적이지 않은, 트리 모양의 자료 구조에 결괏값을 저장한다. 이 최종 자료구조를 보통 AST라고 한다.

AST는 C 언어뿐만 아니라 다른 프로그래밍 언어로도 만들 수 있다. 따라서 AST 구조는 C 언어의 문법에 독립적이기 위해 충분히 추상적이어야 한다.

그러므로 컴파일러 프런트엔드가 다른 언어를 지원할 수 있도록 충분히 변경할 수 있다. 이러한 이유로 __GCC GNU Compiler Collection__ 나, __LLVM Low-Level Virtual Machine__ 이 C, C++ 외에 자바나 포트란과 같은 다른 언어의 컴파일러에도 포함된다. 참고로 GCC의 C 컴파일러에는 gcc가 , LLVM의 C 컴파일러에는 clang 이 있다.

AST가 일단 만들어지면 컴파일러 백엔드가 AST를 최적화한다., 그리고 최적화된 AST를 기반으로 대상 아키텍처에 관한 아셈블리 코드를 생성한다. 

clang 은 llvm 컴파일러 백엔드를 위한 LLVM 개발자 그룹이 개발한 C 컴파일러 프런트엔드이다. __LLVM 컴파일러 기반 프로젝트__  는 중간표현을 프런트와 백엔드 사이의 추상 데이터 구조로 사용했다. LLVM 은 연구 목적으로 IR 자료 구조를 덤프할 수 있다고 잘 알려져 있다. 소스코드에 관한 AST의 다른 이점은 명령어의 순서를 재배열할 수 잇고, 사용하지 않은 브랜치를 줄일 수 잇으며, 브랜치를 대체해 성능을 더 높이면서도 프로그램의 목적은 보존할 수 있다는 것이다. 앞서 언급한 대로 이는 최적화라고 하며, 보통 모든 C 컴파일러가 어느정도 구성 가능한 범위에서 최적화를 수행한다.



## 2.4 어셈블리

앞서 설명한대로 올바른 기계 수준 명령어를 포함하는 목적 파일을 만들기 위해 플랫폼에는 어셈블러가 있다. 유닉스 계열 운영체제에서는 as 유틸리티 프로그램으로 어셈블러를 불러 올 수 잇다, 이번 절에서는 이어서 어셈블리가 목적 파일에 무엇을 넣을 수 잇는지 살펴보자.

만약 같은 아키텍처에 서로 다른 유닉스 계열 운영체제를 2가지 설치할 경우, 설치된 어셈블러는 같지 않을 수도 잇다. 이는 매우 중요하다. 같은 하드웨어에 있기 때문에 기계 수준의 명령어가 같더라도, 생성된 목적 파일은 다를 수 잇다.

AMD64 아키텍처의 리눅스에서 프로그램을 커맢일하고 그에 해당하는 목적 파일을 만든다면, 같은 하드웨어에 있더라도 FreeBSD 또는 macOS와 같이 다른 운영체제에서 동일한 프로그램을 컴파일했을때 결과가 달라질 수 있다. 이는 목적파일이 같을 수는 없지만, 같은 기계 수준의 명령어를 포함한다는 의미이다. 나아가 목적 파일이 다양한 운영체제에서 별도의 포맷을 가질 수 있음을 증명한다.

즉 기계수준명령어를 목적 파일에 저장할 때, 각 운영체제는 고유한 특정 이진파일포맷 또는 __목적파일포맷__ 을 정의한다. 따라서 목적 파일의 내용을 트겆앟는 두 가지 요소가 존재한다. 바로 아키텍처와 운영체제이다. 일반적으로 이 두 가지를 결합해 플랫폼이라는 용어로 지칭한다.

이 절의 내용을 정리하면, 일반적으로 목적 파일과 이를 생성하는 어셈블러는 플랫폼에 따라 다르다. 리눅스에서는 __ELF 파일형식__ 을 사용한다. 이름 그대로 모든 실행 파일, 목적 파일, 공유 라이브러리가 이 파일 형식을 사용한다. 즉, 리눅스에서는 어셈블러가 ELF 목적 파일을 만든다.



## 2.5 링커





