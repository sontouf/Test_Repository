# Chapter3 목적파일

​	3장에서는 C/C++ 프로젝트가 가질 수 있는 다양한 결과물을 상세히 설명한다. 프로젝트의 결과물로는 재배치 가능한 목적 파일, 실행 파일, 정적 라이브러리, 공유목적 파일이 있다. 하지만 재배치 가능한 목적파일은 임시 결과물로 간주하며, 이 파일은 최종 결과물을 만드는 재료 역할을 한다.

오늘날 c 언어에서 다얀한 유형의 목적 파일과 그 내부 구조를 알아보는 일은 매우 중요하다. 대다수의 C 언어 책에서는 C 언어의 문법과 언어 자체만 다룬다. 하지만 현실에서 성공적인 C 언어 개발자가 되려면 더 깊은 지식이 필요하다

소프트웨어를 만드는 일은 단지 개발이나 프로그래밍 언어에만 국한되지 않는다. 실제로는 코드작성, 컴파일, 최적화, 적합한 결과물 만들기, 이후 단계 등 과정 전체에 관한 작업이다. 이는 대상 플랫폼에서 결과물을 수행하고 유지 보수하려는 것이다.

이러한 중급 단계는 마주할 문제를 해결하는 데 도움이 되는 중요한 과정이다.

3장에서는 다음 내용을 학습한다.

__1. ABI: 응용프로그램 이진 인터페이스 application binary interface (ABI)__ 와 그 중요성을 설명한다.

__2. 목적파일형식__ : 현존하는 다양한 목적 파일 형식과 시간이 지나면서 더는 슬모가 없어진 파일 형식을 설명한다. 또한 유닉스 계열 시스템에서 가장 많이 사용되는 목적 파일 형식인 ELF 를 소개한다.

__3. 재배치 가능한 목적파일__ : 재배치 가능한 목적 파일, 즉 C 언어 프로젝트의 첫 번째 결과물을 다룬다. ELF 재배치 간으한 목적 파일의 내부를 살펴보고 거기서 무엇을 찾을 수 있는지 알아보자

__4. 실행 가능한 목적 파일__ : 실행 가능한 목적 파일ㅇ르 설명한다. 또한 재배치 가능한 목적 파일 여러 개에서 어떻게 실행 가능한 목적 파일이 생성되는지도 설명한다. 내부 구조의 관점에서 ELF 재배치 가능한 목적 파일과 실행 가능한 목적 파일 간의 차이를 비교해보자

__5. 정적 라이브러리__ : 정적 라이브러리의 내용과 만드는 법을 이야기한다. 또한 프로그램을 작성하는 법과 기존에 빌드된 정적 라이브러리를 사용하는 법을 예제로 설명한다.

__6. 동적 라이브러리__ : 공유 목적 파일을 이야기한다. 재배치 가능한 목적 파일 여러 개로부터 동적 라이브러리를 만드는 법을 설명하며, 프로그램 안에서 동적 라이브러리를 사용하는 방법도 설명한다. 또한 ELF 공유 목적 파일의 내부 구조를 간략히 살펴보자.



## 3.1 ABI

​	이미 알겠지만 모든 라이브러리나 프레임워크는 사용된 기술이나 프로그래밍 언어와 상관없이 특정한 기능을 제공하며, 이는 __응용프로그램 인터페이스 (API) 라고 한다. 다른 코드가 라이브러리를 사용하려는 경우, 사용자 코드는 제공받은 API를 사용해야 한다. 더  확실히 말하면 라이브러리를 사용하려면 API를 사용해야만 한다는 뜻이다. API가 바로 라이브러리의 공용 인터페이스이며 다른 모든 것은 블랙박스처럼 보여서 읽을 수 없기 때문이다.

시간이 조금 흐른 뒤 라이브러리의 API가 약산 수정되었다고 하자. 사용자 코드가 라이브러리의 새 버전을 계속 사용하려면, 그 코드는 자기 자신을 새 API에 맞추어야한다. 그렇지 않으면 라이브러리를 더 이상 사용할 수 없다. 사용자 코드는 라이브러리의 특정 버전을 계속 사용하며 새 버전을 무시할 수도 있다. 하지만 라이브러리의 최신 버전으로 업그레이드하려는 경우를 가졍해보자.

간단히 말하면 API는 두 소프트웨어 컴포넌트가 서로를 사용하거나 서로 기능을 제공할 때 수용하는 규칙과 같다. ABI는 API와 꽤 비슷하지만, 수준이 다르다. API는 두 소프트웨어의 컴포넌트 간 호환성을 보장해 기능적으로 계속 협력할 수있도록 한다. 반면 ABI는 두 프로그램이 기계 수준의 명령어 수준에서 호환 가능하도록 두 프로그램의 목적 파일을 함께 사용할 수 잇게 한다.

예를 들면 프로그램은 서로 다른 ABI를 갖는 동적 혹은 정적 라이브러리를 사용할 수 없다. 이보다 더 나쁜 경우, (사실 목적 파일인) 실행 파일은 파일이 빌드된 것과 다른 ABI를 지원하는 시스템에서는 실행될 수 없다. __동적 링크, 실행 파일 로딩, 함수 호출 규칙__ 과 같이 시스템의 중요한 여러 기능은 합의된 ABI에 따라 정확하게 수행되어야 한다.

- __대상 아키텍처의 명령어 집합__ : 프로세서 명령어, 메모리 레이아웃, 엔디언, 레지스터 등
- __기존의 자료형과 크기 및 정렬 규칙__
- __함수 호출 규칙__ : 함수가 호출되는 방식, 예를 들어 스택 프레임의 구조나, 인자의 순서를 푸시하는 문제가 함수 호출 방식과 관련이 있다.
- __유닉스 계열 시스템에서 시스템 호출 방식 정의__
- __사용된 목적 파일형식: 재배치 가능한, 실행 가능한, 공유목적파일__ 에 관한 내용
- __C++ 컴파일러로 생성한 목적 파일의 네임 맹글링, 가상 테이블 레이아웃__

System V ABI는 리눅스 BSD 시스템과 같은 유닉스 계열 시스템에서 가장 널리 사용되는 ABI 표준이다. __실행 가능한 링크 파일 형식 executable and linking format (ELF)__ 은 System V ABI에서 사용되는 표준 목적 파일 형식이다.



## 3.2 목적 파일 형식

​	2장에서 설명햇듯, 플랫폼에서 목적 파일에는 기계 수준의 명령어를 저장하는 목적 파일만의 특정 파일 형식이 있다. 참고로 이는 목적 파일의 구조에 관한 것이며, 각 아키텍처가 자체적인 명령어 집합을 갖는다는 점과는 다른 내용이다. 앞서 설명한 대로 이 두가지 변형은 플랫폼은 ABI와는 다른 부분인 목적 파일 형식과 아키텍처의 명령어 집합이다.

이번에는 널리 알려진 몇 가지 목적 파일을 간단히 살펴보려고 한다. 먼저 다양한 운영체제에서 사용되는 목적 파일 형식을 살펴보자.

- 리눅스와 다른 유닉스 계열 운영체제에서 사용되는 ELF
- OS X 에서 사용되는 Mach-O
- 마이크로소프트 윈도우에서 사용되는 PE

현존하는 모든 목적 파일 형식은 예전의 a.out 목적 파일 형식을 계승한다. 이 파일 형식은 유닉스의 초기 버전을 위해 설계되엇다. a.out은 어셈블러 출력결과를 나타낸다. 오늘날에는 이 파일 형식은 구식이지만, 이 이름은 대부분의 링커가 생성하는 실행 파일의 기본 이름으로 여전히 사용된다.

하지만 a.out 형식은 곧 COFF common object file format(공용 목적 파일 형식) 로 대체되었다.COFF는 ELF 의 토대가 되었다. 애플은 a.out을 OS/X에서 Mach-O로 바꾸었다. 윈도우는 목적 파일의 형식으로 __이식 가능한 실행 파일 portable Dxecution(PE)__ 을 사용하며 이는 COFF를 기반으로 한다.

ELF 는 리눅스와 대부분의 유닉스 계열 운영체제에서 사용되는 목적 파일 형식이다. ELF 는 System V ABI에서 사용되는 목적 파일 형식이며 대부분의 유닉스 시스템에서 많이 사용한다. 오늘날에는 운영체제가 사용하는 목적 파일 형식으로 널리 받아들여지고 있다.

ELF의 기반 아키텍처가 같다면, 이러한 한 운영체제에서 생성된 ELF 목적 파일은 다른 운영체제에서도 실행하거나 사용할 수 있다.



## 3.3 재배치 가능한 목적 파일

​	앞에서 설명했듯 이 목적 파일은 컴파일 파이프라인에서 어셈블리 단계의 결과물이다. 재배치 가능한 목적 파일은 C 언어 프로젝트의 임시 결과물로 간주되며, 이후 최종 결과물을 만드는 주재료이다. 그러므로 재배치 가능한 목적 파일을 자세히 살펴보고 이 파일에서 무엇을 이해할 수 있는지 알아보면 유용하다.

재배치 가능한 목적 파일에서는 컴파일된 변환 단위와 관련해 다음 항목을 찾아볼 수 있다.

- 변환 단위에서 발견되는 함수에 대해 생성된 기계 수준의 명령어
- 변환 단위에서 선언된, 초기화된 전역 변숫값
- 변환 단위에서 정의된 심벌 및 참조된 심벌을 모두 포함하는 __심벌 테이블__

앞의 항목은 모든 재배치 간으한 목적 파일에서 찾아볼 수 있는 주요 항목이다. 당연히 이러한 항목이 결합하는 방식은 목적 파일 형식에 따라 다르다. 하지만 알맞은 도구를 이용하면 재배치 가능한 목적 파일에서 이 항목들을 추출할 수 있다.

하지만 예제를 살펴보기 전에 재배치 간으한 목적 파일이라는 이름이 붙은 이유를 살펴보자. 그러니까 __재배치 가능한__ 이라는 말은 결국 무엇을 의미할까 이는 링커가 수행하는 과정에서 비롯되었다. 링커는 재배치 가능한 목적 파일 여러 개를 한데 모아서 더 큰 목적 파일을 형성하는데, 이 파일은 실행 가능한 목적 파일 혹은 공유 목적 파일이라고 한다.

하나의 재배치 가능한 목적 파일에서 나타나는 기계 수준의 명령어는 다른 재배치 가능한 목적 파일에서 나온 기계 수준의 명령어 다음에 위치해야 한다. 이는 즉 명령어가 __이동할 수 있거나 재배치 가능__ 하다는 점을 의미한다. 따라서 재배치 가능한 목적 파일에서 명령어는 주소를 갖지 않는다. 링크 단계를 거치고 나서야 명령어는 주소를 갖는다. 이러한 이유로 이 목적 파일을 재배치 가능하다고 한다.

예제는 두 개의 소스 파일에 관한 것으로, 한 소스 파일은 max와 max_3 를 사용하는 main 함수를 포함한다.

```c
//max.c
int max(int a, int b) {
    return a > b ? a : b;
}
int max_3(int a, int b, int c) {
	int temp = max(a, b);
    return c > temp ? c : temp;
}
```

```c
//main.c
int max(int, int);
int max_3(int, int, int);

int a = 5;
int b = 10;

int main(int argc, char** argv)
{
    int m1 = max(a, b);
    int m2 = max_3(5, 8, -1);
    return 0;
}
```

앞의 소스 파일로 재배치 가능한 목적 파일을 만들어보자. 이렇게 해서 코드의 내용 및 앞서 설명한 내용을 살펴볼 수 있다. 라눅스 머신에서 소스를 컴파일하므로, 컴파일 결과로는 ELF 목적파일이 나온다.

```shell
$ gcc -c max.c -o max.o
$ gcc -c main.c -o main.o
$
```

max.o 와 main.o 는 둘 다 재배치 가능한 ELF 목적 파일이다. ELF 목적 파일에서는 재배치 가능한 목적 파일에서 서술된 항목이 ELF 목적 파일의 여러 섹션에 배치된다.

```shell
$ readelf -hSl max.o
/.../
```

재배치 가능한 목적파일은 11개의 섹션이 있다. 굵은 폰트로 된 섹션은 목적 파일에 존재하는 항목이라고 소개햇던 부분이다. .text 섹션은 변환 단위를 위한 모든 기계 수준의 명령어를 포함한다. .data와 .bss 섹션은 초기화된 전역 변숫값과 초기화되지 않은 전역 변수에 필요한 바이트의 숫자를 각각 포함한다. .symtab 섹션은 심벌 테이블을 포함한다.

앞서 언근한 대로 ELF 목적 파일의 섹션 중 하나는 심벌 테이블을 포함한다. 이전 장에서 심벌 테이블과 엔트리를 자세히 알아본 바 있다. 실행 파일 및 공유 목적 파일을 만들고자 링커가 심벌 테이블과 엔트리를 사용하는 방식을 설명했다. 여기서는 앞 장에서 설명하지 않은 심벌 테이블을 주목해보자. 재배치 가능한 목적 파일에 재배치 가능하다는 이름이 붙은 이유와 관련이 있다.

amx







