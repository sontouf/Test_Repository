# Chapter3 목적파일

	3장에서는 C/C++ 프로젝트가 가질 수 있는 다양한 결과물을 상세히 설명한다. 프로젝트의 결과물로는 재배치 가능한 목적 파일, 실행 파일, 정적 라이브러리, 공유목적 파일이 있다. 하지만 재배치 가능한 목적파일은 임시 결과물로 간주하며, 이 파일은 최종 결과물을 만드는 재료 역할을 한다.
	
	오늘날 c 언어에서 다얀한 유형의 목적 파일과 그 내부 구조를 알아보는 일은 매우 중요하다. 대다수의 C 언어 책에서는 C 언어의 문법과 언어 자체만 다룬다. 하지만 현실에서 성공적인 C 언어 개발자가 되려면 더 깊은 지식이 필요하다

소프트웨어를 만드는 일은 단지 개발이나 프로그래밍 언어에만 국한되지 않는다. 실제로는 코드작성, 컴파일, 최적화, 적합한 결과물 만들기, 이후 단계 등 과정 전체에 관한 작업이다. 이는 대상 플랫폼에서 결과물을 수행하고 유지 보수하려는 것이다.

이러한 중급 단계는 마주할 문제를 해결하는 데 도움이 되는 중요한 과정이다.

3장에서는 다음 내용을 학습한다.

__1. ABI: 응용프로그램 이진 인터페이스 application binary interface (ABI)__ 와 그 중요성을 설명한다.

__2. 목적파일형식__ : 현존하는 다양한 목적 파일 형식과 시간이 지나면서 더는 슬모가 없어진 파일 형식을 설명한다. 또한 유닉스 계열 시스템에서 가장 많이 사용되는 목적 파일 형식인 ELF 를 소개한다.

__3. 재배치 가능한 목적파일__ : 재배치 가능한 목적 파일, 즉 C 언어 프로젝트의 첫 번째 결과물을 다룬다. ELF 재배치 간으한 목적 파일의 내부를 살펴보고 거기서 무엇을 찾을 수 있는지 알아보자

__4. 실행 가능한 목적 파일__ : 실행 가능한 목적 파일ㅇ르 설명한다. 또한 재배치 가능한 목적 파일 여러 개에서 어떻게 실행 가능한 목적 파일이 생성되는지도 설명한다. 내부 구조의 관점에서 ELF 재배치 가능한 목적 파일과 실행 가능한 목적 파일 간의 차이를 비교해보자

__5. 정적 라이브러리__ : 정적 라이브러리의 내용과 만드는 법을 이야기한다. 또한 프로그램을 작성하는 법과 기존에 빌드된 정적 라이브러리를 사용하는 법을 예제로 설명한다.

__6. 동적 라이브러리__ : 공유 목적 파일을 이야기한다. 재배치 가능한 목적 파일 여러 개로부터 동적 라이브러리를 만드는 법을 설명하며, 프로그램 안에서 동적 라이브러리를 사용하는 방법도 설명한다. 또한 ELF 공유 목적 파일의 내부 구조를 간략히 살펴보자.



## 3.1 ABI

	이미 알겠지만 모든 라이브러리나 프레임워크는 사용된 기술이나 프로그래밍 언어와 상관없이 특정한 기능을 제공하며, 이는 __응용프로그램 인터페이스 (API) 라고 한다. 다른 코드가 라이브러리를 사용하려는 경우, 사용자 코드는 제공받은 API를 사용해야 한다. 더  확실히 말하면 라이브러리를 사용하려면 API를 사용해야만 한다는 뜻이다. API가 바로 라이브러리의 공용 인터페이스이며 다른 모든 것은 블랙박스처럼 보여서 읽을 수 없기 때문이다.
	
	시간이 조금 흐른 뒤 라이브러리의 API가 약산 수정되었다고 하자. 사용자 코드가 라이브러리의 새 버전을 계속 사용하려면, 그 코드는 자기 자신을 새 API에 맞추어야한다. 그렇지 않으면 라이브러리를 더 이상 사용할 수 없다. 사용자 코드는 라이브러리의 특정 버전을 계속 사용하며 새 버전을 무시할 수도 있다. 하지만 라이브러리의 최신 버전으로 업그레이드하려는 경우를 가졍해보자.

간단히 말하면 API는 두 소프트웨어 컴포넌트가 서로를 사용하거나 서로 기능을 제공할 때 수용하는 규칙과 같다. ABI는 API와 꽤 비슷하지만, 수준이 다르다. API는 두 소프트웨어의 컴포넌트 간 호환성을 보장해 기능적으로 계속 협력할 수있도록 한다. 반면 ABI는 두 프로그램이 기계 수준의 명령어 수준에서 호환 가능하도록 두 프로그램의 목적 파일을 함께 사용할 수 잇게 한다.

예를 들면 프로그램은 서로 다른 ABI를 갖는 동적 혹은 정적 라이브러리를 사용할 수 없다. 이보다 더 나쁜 경우, (사실 목적 파일인) 실행 파일은 파일이 빌드된 것과 다른 ABI를 지원하는 시스템에서는 실행될 수 없다. __동적 링크, 실행 파일 로딩, 함수 호출 규칙__ 과 같이 시스템의 중요한 여러 기능은 합의된 ABI에 따라 정확하게 수행되어야 한다.

- __대상 아키텍처의 명령어 집합__ : 프로세서 명령어, 메모리 레이아웃, 엔디언, 레지스터 등
- __기존의 자료형과 크기 및 정렬 규칙__
- __함수 호출 규칙__ : 함수가 호출되는 방식, 예를 들어 스택 프레임의 구조나, 인자의 순서를 푸시하는 문제가 함수 호출 방식과 관련이 있다.
- __유닉스 계열 시스템에서 시스템 호출 방식 정의__
- __사용된 목적 파일형식: 재배치 가능한, 실행 가능한, 공유목적파일__ 에 관한 내용
- __C++ 컴파일러로 생성한 목적 파일의 네임 맹글링, 가상 테이블 레이아웃__

System V ABI는 리눅스 BSD 시스템과 같은 유닉스 계열 시스템에서 가장 널리 사용되는 ABI 표준이다. __실행 가능한 링크 파일 형식 executable and linking format (ELF)__ 은 System V ABI에서 사용되는 표준 목적 파일 형식이다.



## 3.2 목적 파일 형식

	2장에서 설명햇듯, 플랫폼에서 목적 파일에는 기계 수준의 명령어를 저장하는 목적 파일만의 특정 파일 형식이 있다. 참고로 이는 목적 파일의 구조에 관한 것이며, 각 아키텍처가 자체적인 명령어 집합을 갖는다는 점과는 다른 내용이다. 앞서 설명한 대로 이 두가지 변형은 플랫폼은 ABI와는 다른 부분인 목적 파일 형식과 아키텍처의 명령어 집합이다.
	
	이번에는 널리 알려진 몇 가지 목적 파일을 간단히 살펴보려고 한다. 먼저 다양한 운영체제에서 사용되는 목적 파일 형식을 살펴보자.

- 리눅스와 다른 유닉스 계열 운영체제에서 사용되는 ELF
- OS X 에서 사용되는 Mach-O
- 마이크로소프트 윈도우에서 사용되는 PE

현존하는 모든 목적 파일 형식은 예전의 a.out 목적 파일 형식을 계승한다. 이 파일 형식은 유닉스의 초기 버전을 위해 설계되엇다. a.out은 어셈블러 출력결과를 나타낸다. 오늘날에는 이 파일 형식은 구식이지만, 이 이름은 대부분의 링커가 생성하는 실행 파일의 기본 이름으로 여전히 사용된다.

하지만 a.out 형식은 곧 COFF common object file format(공용 목적 파일 형식) 로 대체되었다.COFF는 ELF 의 토대가 되었다. 애플은 a.out을 OS/X에서 Mach-O로 바꾸었다. 윈도우는 목적 파일의 형식으로 __이식 가능한 실행 파일 portable Dxecution(PE)__ 을 사용하며 이는 COFF를 기반으로 한다.

ELF 는 리눅스와 대부분의 유닉스 계열 운영체제에서 사용되는 목적 파일 형식이다. ELF 는 System V ABI에서 사용되는 목적 파일 형식이며 대부분의 유닉스 시스템에서 많이 사용한다. 오늘날에는 운영체제가 사용하는 목적 파일 형식으로 널리 받아들여지고 있다.

ELF의 기반 아키텍처가 같다면, 이러한 한 운영체제에서 생성된 ELF 목적 파일은 다른 운영체제에서도 실행하거나 사용할 수 있다.



## 3.3 재배치 가능한 목적 파일

	앞에서 설명했듯 이 목적 파일은 컴파일 파이프라인에서 어셈블리 단계의 결과물이다. 재배치 가능한 목적 파일은 C 언어 프로젝트의 임시 결과물로 간주되며, 이후 최종 결과물을 만드는 주재료이다. 그러므로 재배치 가능한 목적 파일을 자세히 살펴보고 이 파일에서 무엇을 이해할 수 있는지 알아보면 유용하다.

재배치 가능한 목적 파일에서는 컴파일된 변환 단위와 관련해 다음 항목을 찾아볼 수 있다.

- 변환 단위에서 발견되는 함수에 대해 생성된 기계 수준의 명령어

- 변환 단위에서 선언된, 초기화된 전역 변숫값

- 변환 단위에서 정의된 심벌 및 참조된 심벌을 모두 포함하는 __심벌 테이블__

  앞의 항목은 모든 재배치 간으한 목적 파일에서 찾아볼 수 있는 주요 항목이다. 당연히 이러한 항목이 결합하는 방식은 목적 파일 형식에 따라 다르다. 하지만 알맞은 도구를 이용하면 재배치 가능한 목적 파일에서 이 항목들을 추출할 수 있다.

하지만 예제를 살펴보기 전에 재배치 간으한 목적 파일이라는 이름이 붙은 이유를 살펴보자. 그러니까 __재배치 가능한__ 이라는 말은 결국 무엇을 의미할까 이는 링커가 수행하는 과정에서 비롯되었다. 링커는 재배치 가능한 목적 파일 여러 개를 한데 모아서 더 큰 목적 파일을 형성하는데, 이 파일은 실행 가능한 목적 파일 혹은 공유 목적 파일이라고 한다.

하나의 재배치 가능한 목적 파일에서 나타나는 기계 수준의 명령어는 다른 재배치 가능한 목적 파일에서 나온 기계 수준의 명령어 다음에 위치해야 한다. 이는 즉 명령어가 __이동할 수 있거나 재배치 가능__ 하다는 점을 의미한다. 따라서 재배치 가능한 목적 파일에서 명령어는 주소를 갖지 않는다. 링크 단계를 거치고 나서야 명령어는 주소를 갖는다. 이러한 이유로 이 목적 파일을 재배치 가능하다고 한다.

예제는 두 개의 소스 파일에 관한 것으로, 한 소스 파일은 max와 max_3 를 사용하는 main 함수를 포함한다.

```c
//max.c
int max(int a, int b) {
    return a > b ? a : b;
}
int max_3(int a, int b, int c) {
	int temp = max(a, b);
    return c > temp ? c : temp;
}
```

```c
//main.c
int max(int, int);
int max_3(int, int, int);

int a = 5;
int b = 10;

int main(int argc, char** argv)
{
    int m1 = max(a, b);
    int m2 = max_3(5, 8, -1);
    return 0;
}
```

앞의 소스 파일로 재배치 가능한 목적 파일을 만들어보자. 이렇게 해서 코드의 내용 및 앞서 설명한 내용을 살펴볼 수 있다. 라눅스 머신에서 소스를 컴파일하므로, 컴파일 결과로는 ELF 목적파일이 나온다.

```shell
$ gcc -c max.c -o max.o
$ gcc -c main.c -o main.o
$
```

max.o 와 main.o 는 둘 다 재배치 가능한 ELF 목적 파일이다. ELF 목적 파일에서는 재배치 가능한 목적 파일에서 서술된 항목이 ELF 목적 파일의 여러 섹션에 배치된다.

```shell
$ readelf -hSl max.o
/.../
```

재배치 가능한 목적파일은 11개의 섹션이 있다. 굵은 폰트로 된 섹션은 목적 파일에 존재하는 항목이라고 소개햇던 부분이다. .text 섹션은 변환 단위를 위한 모든 기계 수준의 명령어를 포함한다. .data와 .bss 섹션은 초기화된 전역 변숫값과 초기화되지 않은 전역 변수에 필요한 바이트의 숫자를 각각 포함한다. .symtab 섹션은 심벌 테이블을 포함한다.

앞서 언근한 대로 ELF 목적 파일의 섹션 중 하나는 심벌 테이블을 포함한다. 이전 장에서 심벌 테이블과 엔트리를 자세히 알아본 바 있다. 실행 파일 및 공유 목적 파일을 만들고자 링커가 심벌 테이블과 엔트리를 사용하는 방식을 설명했다. 여기서는 앞 장에서 설명하지 않은 심벌 테이블을 주목해보자. 재배치 가능한 목적 파일에 재배치 가능하다는 이름이 붙은 이유와 관련이 있다.

max.o에 심벌 테이블을 덤프해보자. 앞 장에서는 objdump를 사용했지만, 지금은 readelf를 사용하자

```shell
$ readelf -s max.o

Symbol table 'symtab' contains 1- entries:
	Num:		Value		Size	Type	Bind	Vis		  Ndx	Name
...
	8: 	0000000000000000	22		FUNC	GLOBAL	DEFAULT 	1	max
	9:	0000000000000016	47		FUNC	GLOBAL	DEFAULT		1	max_3
$
```

Value 열에서 볼 수 있듯, max에 할당된 주소는 0이며 max_3에 할당된 주소는 22(16진수로 16)이다. 이 심벌에 관련된 명령어는 서로 인접했고 그 주소는 0부터 시작한다는 뜻이다. 이 심벌과 그에 해당하는 기계 수준의 명령어는 최종파일에서 다른 장소로 재배치될 준비를 마친 상태이다.

```shell
$ readelf -s main.o

Symbol table 'symtab' contains 1- entries:
	Num:		Value		Size	Type	Bind	Vis		  Ndx	Name
...
	8: 	0000000000000000	4		OBJECT	GLOBAL	DEFAULT 	3	a
	9:	0000000000000004	4		OBJECT	GLOBAL	DEFAULT		3	b
   10:	0000000000000000	69		OBJECT	GLOBAL	DEFAULT		1	main
   11:	0000000000000000	0		NOTYPE	GLOBAL	DEFAULT	  UND	_GLOBAL_OFFSET_
TABLE_
   12:  0000000000000000    0       NOTYPE	GLOBAL	DEFAULT	  UND	max
   13:  0000000000000000    0       NOTYPE	GLOBAL	DEFAULT	  UND	max_3
$
```

전역 변수 a와 b에 관련된 심벌뿐만 아니라 main 함수에 대한 심벌도 각 심벌이 위치할 최종 주소로는 보이지 않은 주소에 놓였다. 이는 재배치 가능한 목적 파일이라는 표시이다.  앞서 설명했듯 재배치 가능한 목적 파일의 심벌은 어떠한 최종 혹은 절대 주소를 갖지 않으며, 주소는 링크 단계에서 결정된다.



## 3.4 실행 가능한 목적 파일

	재배치 가능한 목적 파일처럼 실행 가능한 목적 파일도 기계 수준의 명령어, 초기화된 전역 변숫값, 심벌 테이블과 같은 항목을 가진다. 하지만 정렬은 다를 수 있다. ELF 실행 가능한 목적 파일은 생성하기도 내부 구조를 이해하기도 쉬운 만큼, 이 파일과 관련한 차이점을 설명할 수 있다.

```shell
$ gcc max.o main.o -o exe.out
$
```

앞 절에서 ELF 목적 파일에 존재하는 섹션을 설명했다. ELF 실행 가능한 목적 파일에는 더 많은 섹션이 있는 데, 이들은 몇몇 세그먼트와 함께 있다. 모든 ELF 실행 가능한 목적 파일과, 이 장의 후반부에서 보게 될 ELF 공유 목적 파일은 섹션뿐만 아니라 여러 세그먼트를 갖는다. 각 세그먼트는 많은 섹션으로 구성되며, 섹션은 내용에 따라 세그먼트에 놓인다.

예를 들면 기계 수준의 명령어를 포함하는 모든 섹션은 같은 세그먼트에 들어간다. 4장에서는 이러한 섹션이 실행 중인 프로세스의 메모리 레이아웃에서 볼 수 있는 정적 __메모리 세그먼트__ 에 잘 연결되었음을 보게 된다.

- ELF 관점에서, 목적 파일의 유형은 공유 목적 파일이라는 것을 알 수 있다. 즉, ELF 에서 실행 가능한 목적 파일이란 INTERP 와 같은 특정 세그먼트를 갖는 공유 목적 파일이다. 로더 프로그램이 이 세그먼트를 이용해 실행 가능한 목적 파일을 로드한다.
- 4개의 세그먼트에 굵은 폰트를 적용했다. 첫 번째 세그먼트는 INTERP 세그먼트를 가리킨다. INTERP 세그먼트는 첫 번째 항목에서 설명했다. 두 번째 세그먼트는 TEXT 세그먼트이다. 이 세그먼트는 기계 수준의 명령어를 갖는 섹션을 모두 포함한다. 세 번째는 DATA 세그먼트로, 전역 변수를 초기화할 때 사용할 모든 값과 다른 초기 구조체를 포함한다. 네 번째 세그먼트는 동적 링크와 관련한 정보를 찾을 수 있는 섹션을 나타낸다. 동적 링크와 관련한 정보로는 실행의 일부로 로드해야 하는 공유 목적 파일이 있다.
- 재배치 가능한 공유 목적 파일보다 더 많은 섹션이 있다. 이 섹션은 목적 파일을 로드하고 실행하는 데 필요한 데이터로 채워져 있다.

앞 절에서 설명했듯 재배치 가능한 목적 파일의 심벌 테이블에 있는 그 어떠한 심벌도 절대 주소나 사전에 정해진 주소를 갖지 않는다. 기계 수준의 명령어를 포함하는 섹션이 아직 링크되지 않았기 때문이다. 더 자세히 설명하면, 여러 개의 재배치 가능한 목적 파일를 링크한다는 것은 주어진 재배치 가능한 목적 파일에서 모든 유사한 섹션을 모아서 더 큰 섹션을 형성하고, 이렇게 모은 섹션을 실행 혹은 공유 목적 파일로 만드는 일이다. 그러므로 이 단계를 거쳐야만 심벌이 마무리될 수 있으며 또한 변하지 않는 주소를 가질 수 있다. 실행 가능한 목적 파일에서 주소는 절대적이다. 하지만 공유 목적에서는 __상대 주솟값__ 이 절대적이다. 동적 라이브러리를 설명하는 절에서 더 다뤄보자

exe.out 실행 파일의 심벌 테이블을 보자.

하나의 실행 가능한 목적 파일에 2개의 다른 심벌 테이블이 있다. 첫번째 심벌 테이블인 .dynsym 은 실행 파일을 로드할 때 해결할 심벌을 포함한다. 하지만 두 번째 심벌 테이블인 .symtab은 동적 심벌 테이블에서 가져온, 미해결된 심벌과 함께 해결된 심벌도 모두 포함한다. 즉, 두 번째 심벌 테이블은 동적 테이블의 미해결 심벌 또한 포함한다.

심벌 테이블에서 해결된 심벌은 링크 단계에서 획득한 주소에 해당하는 절대주소 absolute corresponding address를 갖는다. max 및 max_3 심벌의 주소는 굵은 글씨로 보인다.



## 3.5 정적 라이브러리

	정적 라이브러리는 쉽게 말해 재배치 가능한 목적 파일에서 만들어지는 유닉스 아카이브이다. 정적 라이브러리는 다른 목적 파일과 함께 링크되어 실행 가능한 목적 파일을 형성한다. 정적 라이브러리 그 자체는 목적 파일로 볼 수 없으며, 오히려 목적 파일을 위한 컨테이너이다. 즉 리눅스 시스템에서 정적 라이브러리는 ELF 파일이 아니다.또한 macOS 시스템에서 Mack-O 파일인 것도 아니다. 정적 라이브러리는 유닉스의 ar 유틸리티로 파일을  아카이브 할 뿐이다.

링커가 링크 단계에서 정적 라이브러리를 사용하려고 할 때, 우선 재배치 가능한 목적 파일에서 정적 라이브러리를 추출하려고 시도한다. 그 다음에는 거기서 정의되지 않은 심벌을 찾아서 해결하기 시작한다.

이번에는 여러 개의 소스 파일을 가진 프로젝트에서 정젖ㄱ 라이브러리를 만들어볼 차례이다. 첫 번째 단계는 재배치 가능한 목적 파일을 만드는 일이다. C/C++ 프로젝트의 모든 소스 파일을 컴파일하고 나면 정적 라이브러리의 아카이브 파일을 만들고자 유닉스의 아카이브 도구인 ar을 사용할 수 있다.

유닉스  시스템에서 정적 라이브러리는 널리 사용되고 수용되는 규칙에 따라 이름이 붙는다. 이름은 lib로 시작하고 .a 확장자로 끝난다. 다른 운영체제에서는 다를 수 있다. 예를 들어 윈도우에서는 정적 라이브러리에 .lib 확장자가 붙는다.

```shell
$ gcc -c aa.c -o aa.o
$ gcc -c bb.c -o bb.o
.
.
.
$ gcc -c zz.c -o zz.o
$
```

앞의 명령어를 실행하면 필요한 재배치 가능한 목적 파일을 모두 얻게 된다. 만약 프로젝트가 커서 수천 개의 소스 파일을 포함한다면 상당한 시간이 걸릴 수 있다. 컴파일 작업을 병렬적으로 함께 실행할 수 있는 강력한 빌드 머신은 당연히 빌드 시간을 많이 줄일 수 있다.

정적 라이브러리 파일을 만들 때는 다음 명령어를 사용한다.

```shell
$ ar crs lib,a aa.o bb.o ... zz.o
```

그 결과 lib.a 가 생성되었다. 이 파일은 하나의 아카이브에 이전의 재배치 가능한 목적 파일 모두를 포함한다. ar 유틸리티에 전달된 crs 옵션에 관한 설명은 3장의 범위를 벗어난다.

```
ar 명령어는 꼭 압축된 아카이브 파일을 만들지는 않는다. 이 명령어는 파일을 모두 모으고, 모은 파일 전부에 대한 아카이브인 파일 한 개를 만들 때만 사용된다. ar이라는 도구는 다용도로 사용할 수 있다. 그리고 어떤 종류의 파일을 합치는 데에도 쓸 수 있으며 그 파일들로부터 아카이브를 만들 수 있다.
```



이제 정적 라이브러리를 만드는 법을 알았으니 예제에서 실제로 만들어보자

우선 예제가 기하학에 관련한 C 프로젝트라고 가정해보자. 이 예제는 3개의 파일과 1개의 헤더 파일로 구성되었다. 이 라이브러리는 다른 응용프로그램에서 사용될 수 잇는 기하학과 관련된 함수의 모음을 정의한다.

그러려면 3개의 소스 파일로부터 libgeometry.a 라는 이름이 붙은 정적 라이브러리 파일을 만들어야한다. 정적 라이브러리를 얻은 뒤, 라이브러리에 정의된 기하학 함수를 사용할 다른 프로그램을 작성할 때 헤더 파일과 정적 파일을 함께 사용할 수 있다.

첫 번째 파일인 geometry.h는 기하학 라이브러리에서 내보내야 하는 선언을 모두 포함한다. 이 선언은 라이브러리를 사용할 응용프로그램이 사용할 것이다.

나중에 라이브러리를 사용할 응용프로그램은 선언에만 의존적이어야 하며 정의에 의존해서는 절대 안 된다는 점을 명심하자.

```c
// geometry.h
#ifndef GEOMETRY_H
#define GEOMETRY_H

#define PI 3.14159265359
typedef struct {
    double x;
    double y;
} cartesizn_pos_2d_t;

typedef struct {
    double length;
    double theta;
} polar_pos_2d_t;

typedef struct {
    double x;
    double y;
    double z;
} cartesian_pos_3d_t;

typedef struct {
    double length;
    double theta;
    double phi;
} polar_pos_3d_t;

double to_radian(double deg);
double to_degree(double rad);

double cos_deg(double deg);
double acos_deg(double deg);

double sin_deg(double deg);
double asin_deg(double deg);

cartesian_pos_2d_t convert_to_2d_cartesian_pos(const polar_pos_2d_t* polar_pos);
polar_pos_2d_t convert_to_2d_cartesian_pos(const polar_pos_2d_t* cartesian_pos);

cartesian_pos_3d_t convert_to_3d_cartesian_pos(const polar_pos_3d_t* polar_pos);
polar_pos_2d_t convert_to_3d_cartesian_pos(const polar_pos_3d_t* cartesian_pos);

#endif
```

두 번째 파일은 삼각함수의 정의를 포함하는 소스파일이다. 이 삼각 함수는 앞의 헤더 파일에서 정의된 처음 여섯개 함수이다.

```c
// trigon.c
# include <math.h>

// 헤더파일을 포함한다. 매크로 PI를 써야하기 때문.
#include "geometry.h"
double to_radian(double deg) {
    return (PI * deg) / 180;
}

double to_degree(double rad) {
    return (180 * rad) / PI;
}

double cos_deg(double deg) {
    return cos(to_radian(deg));
}

double acos_deg(double deg) {
    return acos(to_radian(deg));
}

double sin_deg(double deg) {
    return sin(to_radian(deg));
}

double asin_deg(double deg){
    return asin(to_radian(deg));
}
```

헤더 파일에서 선언된 PI나  to_degree 같은 선언을 사용하지 않는다면, 소스가 헤더를 포함할 필요는 없다.

세번 째 파일은 마찬가지로 소스 파일이며 이 파일은 모든 2D 기하학 함수의 정의를 포함한다.

```c
// 2d.c
# include <math.h>

// 삼각함수를 사용하기 위해 헤더 파일을 포함해야 한다.
# include "geometry.h"

cartesian_pos_2d_t convert_to_2d_cartesian_pos(const polar_pos_2d_t* polar pos) {
    cartesian_pos_2d_t result;
    result.x = polar_pos->length * cos_deg(polar_pos->theta);
    result.y = polar_pos->length * sin_deg(polar_pos->theta);
    return result;
}

polar_pos_2d_t convert_to_2d_polar_pos(const cartesian_pos_2d_t* cartesian_pos) {
    polar_pos_2d_t result;
    result.length = sqrt(cartesian_pos->x * cartesian_pos->x + cartesian_pos->y * cartesian_pos->y);
    result.theta = to_degree(atan(cartesian_pos->y / cartesian_pos->x));
    return result;
}
```

마지막으로 네 번째 소스파일은 3D 기하학 함수의 정의를 포함한다.

```c
// 3d.c
# include <math.h>

// 삼각함수를 사용하기 위해 헤더 파일을 포함해야 한다.
# include "geometry.h"

cartesian_pos_3d_t convert_to_3d_cartesian_pos(const polar_pos_3d_t* polar pos) {
    cartesian_pos_3d_t result;
    result.x = polar_pos->length * sin_deg(polar_pos->theta) * cos_deg(polar_pos->phi);
    result.y = polar_pos->length * sin_deg(polar_pos->theta) * sin_deg(polar_pos->phi);
    result.z = polar_pos->length * con_deg(polar_pos->theta);
    return result;
}

polar_pos_3d_t convert_to_3d_polar_pos(const cartesian_pos_3d_t* cartesian_pos) {
    polar_pos_3d_t result;
    result.length = sqrt(cartesian_pos->x * cartesian_pos->x + cartesian_pos->y * cartesian_pos->y + cartesian_pos->z * cartesian_pos->z);
    result.theta = to_degree(acos(cartesian_pos->z / result.length));
    result.phi = to_degree(atan(cartesian_pos->y / cartesian_pos->x));
    return result;
}
```

이제 정적 라이브러리 파일을 만들어보자. 그러려면 우선 앞의 소스를 재배치 가느한 목적 파일로 컴파일해야 한다. 앞의 소스 파일 중 어느 것에도 main 함수가 없으므로 링크해서 실행 파일을 만들 수 는 없다는 점을 알아두자. 따라서 이들 파일은 정적 라이브러리를 만드는 재배치 가능한 목적 파일로 두거나 아카이브로 둘 수 있다. 이 파일로 공유 목적 파일을 만드는 다른 옵션도 있지만, 일단 보류하겠다.

```shell
$ gcc -c trigon.c -o trigon-o
$ gcc -c 2d.c -o 2d.o
$ gcc -c 3d.c -o 3d.o
$
```

이 목적 파일을 정적 라이브러리 파일로 아카이브하려면 다음 명령어를 실행해야 한다.

```shell
$ ar crs libgeometry.a trigon.o 2d.o 3d.o
$ mkdir -p /opt/geometry
$ mv libgeometry.a /opt/geometry
$
```

libgeometry.a 가 생성되었음을 알 수 있다. 보다시피 다른 프로그램으로 쉽게 배치할 수 있는 /opt/geometry 경로로 라이브러리 파일을 이동했다. 한 번 더 설명하자마녀 ar 명령어와 -t 옵션을 사용해 아카이브 파일의 내용을 볼 수 있다.

```shell
$ ar t /opt/geometry/libgeometry.a
trigon.o
2d.o
3d.o
$
```

셸 박스를 보면 정적 라이브러리 파일은 의도한 대로 3개의 재배치 가능한 목적 파일을 확실히 포함한다. 다음으로는 정적 라이브러리 파일을 사용할 차례이다.

기하학 예제로부터 정적 라이브러리를 생성했으니, 새 응용프로그램에서 이를 사용해보자. C 언어 라이브러리를 사용하려면 정적 라이브러리 파일과 함께 라이브러리가 제공하는 선언에 접근해야 한다. 이 선언은 라이브러리의 __공용 인터페이스__ , 더 일반적으로는 라이브러리의 API라고 간주한다.

컴파일 단계에서는 선언이 필요하다. 컴파일 단계란 컴파일러가 자료형의 존재나 함수 시그니처 등을 알아야 하는 단계이다. 이 내용은 헤더 파일에 잇다. 자료형의 크기나 함수 주소와 같은 세부 사항은 다음 단계인 링크와 로딩에서 필요하다.

앞서 말했듯 C 언어의 API는 헤더파일의 그룹으로 대개 알려졌다. 따라서 예제의 헤더 파일 및 생성된 libgeometry.a 정적 라이브러리 파일은 기하학 라이브러리를 사용하는 새 프로그램을 작성하기에 충분하다.

정적 라이브러리를 사용하려면 새로운 소스 파일을 만들어서 라이브러리의 함수를 사용해야 한다. 이 소스 파일은 라이브러리의 API를 포함한다. 새로운 코드는 다음에서 보자.

```c
//main.c

#include <stdio.h>

#include "geometry.h"

int main(int argc, char** argv)
{
    cartesian_pos_2d_t cartesian_pos;
    cartesian_pos.x = 100;
    cartesian_pos.y = 200;
    polar_pos_2d-t polar_pos = convert_to_2d_polar_pos(&cartesian-pos);
    printf("Polar Position: Length: %f, Theta: %f (deg)\n", polar_pos.length, polar_pos.theta);
    return 0;
}
```

위 예제는 앞선 예제의 헤더 파일을 포함한다. 앞으로 사용할 함수의 선언이 필요하기 때문이다. 이어서 리눅스 시스템에서 앞의 소스 파일을 컴파일해 재배치 가능한 목적 파일을 만들어야 한다.



```shell
$ gcc -c main.c -o main.o
$
```

컴파일이 끝난 뒤 예제에서 생성한 정적 라이브러리와 앞에서 만든 재배치 가능한 목적 파일을 링크해야 한다. 이때 libgeometry.a 는 /opt/geometry 경로에 위치한다. 다음 명령어는 링크 단계를 수행하고 ex.out 이라는 실행 가능한 목적 파일을 만들어서 빌드 과정을 마무리 한다.

```shell
$ gcc main.o -L/opt/gometry -lgeomtry -lm -o ex.out
$
```

앞의 명령어를 설명하기 위해 각각의 옵션을 설명하겠다.

- -L /opt/geometry는 gcc가 opt/geometry 를 정적 혹은 공유 라이브러리를 찾을 수 잇는 여러 장소 중 하나로 인식하도록 명령한다. /usr/lib 혹은 /usr/local/lib 과 같이 잘 알려진 경로는 링커가 기본적으로 라이브러리를 찾는 곳이다. 만약 -L 을 명시하지 않으면 기본 경로만을 탐색한다.
- -lgeometry 는 gcc 가 libgeometry.a 혹은 libgeometry.so 를 검색하도록 한다. .so로 끝나는 파일은 공유 목적 파일이다. 이 파일은 다음 절에서 설명한다.
  사용된 규칙을 살펴보자. lxyz 옵션을 통과시키면 링커는 기본 혹은 특정 경로에서 libxy.a 또는 libxyz.so 을 찾을 것이다. 파일을 찾을 수 없다면 링커가 중지되고 오류가 발생한다.
- -lm 은 gcc 가 libm.a 또는 libm.so와 같은 라이브러리를 찾도록 한다. 이 라이브러리에는 glibc의 수학 함수에 관한 정의가 있다. 이는 cos,sin,acos 함수를 위해 필요한 라이브러리이다. 기본 C 라이브러리를 구현하는 glibc 를 사용하는 리눅스머신에서 예제를 빌드한다는 점을 참고하자. masOS 나 다른 유닉스 계열 시스템에서는 옵션을 명시할 필요는 없다.
- -o ex.out은 gcc 가 출력되는 실행 파일의 이름을 ex.out 으로 붙이도록 명령한다.

앞의 명령어를 실행하고 나면 모든 것이 매끄럽게 진행되어, 정적 라이브러리 libgeometry.a 에 더해 main.o 에서 찾아볼 수 있는 모든 재배치 가능한 목적 파일을 갖는 하나의 실행 가능한 이진 파일을 얻는다.

링크 이후에 정적 라이브러리 파일에 의존하는 것은 아무것도 없으며, 모든 것은 실행 파일 그 자체의 내부에 임베드되어 있다. 즉, 실행 파일은 정적 라이브러리 파일이 필요하지 않으며 자기 자신만으로도 실행될 수  있다.

하지만 실행파일은 대체로 크기가 엄청나게 큰 여러 정적 라이브러리를 링크해 생성된다. 정적 라이브러리가 많으면 많을수록 재배치 간으한 목적 파일도 더 많아지며 최종 파일의 크기도 더 커진다. 때로는 수백 메가바이트 혹은 수 기가 바이트에 달할 수도 있다.

이진 파일의 크기와 이진 파일이 갖는 의존성 사이에는 트레이드오프가 있다. 작은 이진파일을 가질 수는 있지만 공유 라이브러리를 사용해야 한다. 즉, 외부의 공유 라이브러리가 없거나 찾을 수 없는 경우에 최종 이진 파일은 완전하지 않으며 실행될 수 없다는 의미이다.

이번 절에서는 정적 라이브러리를 설명했으며 정적 라이브러리가 어떻게 생성되고 사용되어야 하는지도 설명했다. 다른 프로그램이 제공받은 API를 사용하는 방법이나 기존의 정적 라이브러리와 링크되는 방식도 설명했다. 다음 절에서는 동적 라이브러리를 알아보고, 정적 라이브러리를 사용하지 않고서 예제에 있는 소스로부터 공유 목적 파일을 만드는 방식을 설명하겠다.



## 3.6 동적 라이브러리

​	동적 라이브러리 혹은 공유 라이브러리는 재사용을 위한 라이브러리를 만드는 또 다른 방식이다. 이름대로, 정적 라이브러리와는 달리 동적 라이브러리는 그 자체가 실행 파일에 해당하지는 않는다. 대신 동적 라이브러리는 실행을 위한 프로세스가 로딩될 때 가져와서 로드되어야 한다.

정적 라이브러리가 실행 파일의 일부이므로, 링커는 주어진 재배치 가능한 파일의 모든 것을 최종 실행 파일에 넣는다. 즉, 링커는 정의되지 않은 심벌을 감지하고, 정의가 필요하며, 이를 주어진 재배치 가능한 목적 파일에서 찾고자 하고, 그렇게 출력되는 최종 파일에 모든 것을 집어넣는다.

모든 정의되지 않은 심벌을 찾고 나서야 최종 결과물이 만들어진다. 고유한 관점에서 링크 단계에서 모든 심벌의 의존 관계를 찾아서 해결한다. 동적 라이브러리의 경우 정의되지 않은 심벌을 가질 수도 있다. 이러한 정의되지 않은 심벌은 링크 단계에서 해결되지 않는다. 실행 파일이 로드되고 실행을 시작할 때 이 심벌을 검색한다. 즉, 정의되지 않은 동적 심벌을 찾고자 할 때는 다른 종류의 링크 단계가 필요하다. 실행 파일을 로드하고 프로세스로 실행될 준비를 할 때, __동적 링커__ 혹은 간단히는 __로더__ 가 주로 이 링크를 수행한다.

정의되지 않은 동적 심벌을 실행 파일에서 찾을 수 없으므로 어딘가 다른 곳에서 찾아야 한다. 이 심벌은 공유 목적 파일에서 로드해야 한다. 공유 목적 파일은 정적 라이브러리 파일의 자매 격인 파일이다. 대부분의 유닉스 계열 시스템에서 정적 라이브러리는 .a 확장자를 갖지만, 정적 목적 파일은 .so 확장자를 갖는다. macOS 에서는 .dylib 확장자를 가진다.

프로세스를 로드하고 실행할 때, 공유 목적 파일이 로드되며 프로세스가 접근 할 수 있는 메모리 지역이 이 파일이 연결된다. 이 절차는 동적 링커에 의해 수행되며, 동적 링커는 실행 파일을 로드하고 실행한다.

실행 가능한 목적파일에 대한 절에서 설명한 대로, ELF 실행 파일 및 공유 목적 파일은 각자의 ELF 구조 내에 세그먼트가 있다. 각 세그먼트 안에는 0개 혹은 그 이상의 섹션이 있다. ELF 실행 가능한 목적 파일과 ELF 공유 목적 파일 간에는 주요 차이점이 두 가지 있다.

첫 번째, 심벌이 상대적인 절대 주소를 가지며 이 주소를 통해 심벌이 여러 프로세스에 동시에 로드되도록 한다. 이는 각 명령어의 주소가 프로세스에서 다른 한편, 두 명령어 사이의 거리는 고정되어 있음을 의미한다. 다시 말하면 주소는 오프셋에 상대적으로 고정된다. 이는 재배치 가능한 목적 파일이 __위치 독립적__이기 때문이다.

예를 들어, 한 프로세스에서 두 명령어가 100과 200이라는 주소에 위치하고, 다른 프로세스에서는 명령어가 140과 240, 또 다른 프로세스에서는 323과 423에 있다고 해보자. 서로 연관된 주소는 절대적이지만, 실제 주소는 변할 수 있다. 이 두 명령어는 언제나 주소가 서로 100만큼 떨어져 있을 것이다.

두 번째 차이점은 ELF 실행 가능한 목적 파일에 관련된 세그먼트가 공유 목적 파일에는 존재하지 않는다는 것이다. 이는 결국 공유 목적 파일이 실행될 수 없음을 의미한다.

공유 목적 파일이 다른 프로세스에서 어떻게 접근하는지 세부적으로 설명하지 전에, 공유 목적 파일이 어떻게 생성되고 사용되는지에 관한 예제를 살펴봐야 한다. 다라서 앞 절에서 작업한 예제와 동일한 기하학 라이브러리를 위한 동적 라이브러리를 생성하겠다.

앞서 기하학 라이브러리를 위한 정적 라이브러리를 생성햇다. 이번에는 공유 목적 파일을 만들고자 소스를 다시 컴파일하려 한다. 다음 명령어는 3개의 소스 파일을 재배치 가능한 목적 파일로 컴파일하는 방법을 나타낸다. 하나의 차이점이 있다면 명령어에서 -fPIC 옵션이 gcc로 전달된다는 점을 주의하자

```shell
$ gcc -c 2d.c -fPIC -o 2d.o
$ gcc -c 3d.c -fPIC -o 3d.o
$ gcc -c trigon.c -fPIC -o trigon.o
$
```

​	명령어를 보면 소스를 컴파일하는 동안 gcc에 추가옵션인 fPIC를 전달했다는 것을 알 수 있다. 만약 재배치 가능한 목적 파일에서 공유 목적 파일을 만들려고 한다면 이 옵션은 반드시 사용해야 한다. __PIC__ 는 __위치 독립적인 코드 position independent code__ 를 나타낸다. 앞서 설명한대로 만약 재배치 가능한 목적 파일이 위치 독립적이라면, 이는 곧 파일 안의 명령어가 고정 주소를 갖지 않는다는 의미이다. 그 대신 상대 주소를 가리킨다. 따라서 재배치 가능한  목적 파일은 다른 프로세스에서 다른 주소를 가질 수 있다. 공유 목적 파일을 사용하는 방식 때문에 이는 필수 조건이다.

​	프로세스가 다른 경우 로더 프로그램이 같은 주소에서 공유 목적 파일을 로드하리라는 보장은 없다. 사실 로더는 공유 목적 파일에 메모리 매핑을 생성하고, 그러한 매핑을 위한 주소의 범위는 다를 수 있다. 만약 명령어의 주소가 절대적이라면, 다양한 프로세스나 다양한 메모리 지역에서 같은 공유 목적 파일을 동시에 로드할 수 없다.

공유 목적 파일을 만들려면 컴파일러가 필요하며, 여기서는 다시 gcc를 사용한다. 정적 라이브러리 파일과는 달리 공유 목적 파일은 단순한 아카이브이며, 공유 목적 파일은 그 자체로 목적 파일이다. 따라서 재배치 가능한 목적 파일을 만들려면 사용한 것과 동일한 링커 프로그램으로 생성해야 한다. (예 : ld)

알다시피 대부분의 유닉스 계열 시스템에서 ld 가 컴파일을 수행한다. 하지만 앞서 설명한 이유 때문에 ld를 직접 사용해서 목적파일을 일크하지 않기를 강력히 권고한다.

 

​	다음 명령어는 -fPIC 옵션을 사용해 컴파일한 여러 재배치 가능한 목적 파일로부터 공유 목적 파일을 만드는 법을 나타낸다.

```shell
$ gcc -shared 2d.o 3d.o trigon.o -o libgeometry.so
$ mkdir -p /opt/geometry
$ mv libgeometry.so /opt/geometry
$
```

공유 목적 파일을 opt/geometry 로 이동해 다른 프로그램이 사용하기 쉽게 두었다.

앞에서는 예제를 컴파일해 정적 라이브러리 파일인 libgeometry.a 와 링크했다. 여기서도 같은 과정을 수행하지만, 링크는 libgeometry.so 즉 동적 라이브러리와 링크하겠다.

 모든 것은 같아 보인다. 특히 명령어도 똑같아 보이지만, 사실은 다르다. 이번에는 libgeometry.a 대신 libgeometry.so 를 링크한다. 게다가 동적 라이브러리는 최종 실행 파일에 임베드 되지 않는다. 대신 실행할 때 라이브러리가 로드된다. 연습을 위해 소스파일에 다시 링크하기 전 opt/geometry에서 정적 라이브러리 파일인 libgeometry.a 를 제거하자.

```shell
$ rm -fv /opt/geometry/libgeometry.a
$ gcc -c main.c -o main.o
$ gcc main.o -L/opt/geometry -lgeometry -lm -o ex.out
$
```

앞서 설명한 대로 -lgeometry 옵션은 컴파일러가 정적 혹은 동적 라이브러리를 찾아서 사용하도록 하고, 그 파일을 나머지 목적 파일과 링크하도록 한다. 정적 라이브러리 파일을 제거했으므로 공유 목적 파일이 선택된다. 만약 지정 경로에 정적 라이브러리와 공유 목적 파일이 둘 다 존재한다면, gcc 는 공유 목적 파일을 선택해 프로그램과 링크한다.

실행 파일인 ex.out을 실행하면 대부분 다음과 같은 오류가 나타난다.

```shell
$ ./ex.out
./ex.out: error while loading shared libraries: libgeometry.so:
cannot open shared object file: No such file or directory
$

```

지금까지는 정적 링크와 정적 라이브러리를 사용했으므로 이런 오류를 볼 수 없었다. 하지만 이번에는 동적 라이브러리를 가져왔으므로, 만약 __동적 의존성__ 을 갖는 프로그램을 실행한다면 실행에 필요한 동적 라이브러리를 제공해야 한다. 하지만 무슨 일이 발생했으며 왜 이런 오류메시지를 받게 될까?

실행 파일 ex.out 은 필요한 정의의 일부를 공유 목적 파일에서만 찾으므로 libgeometry.so 에 의존한다. 정적 라이브러리인 libgeometry.a 에서는 그렇지 않다는 점을 알아두자. 정적 라이브러리와 링크된 실행 파일은 독립 실행 파일에서 실행할 수 있다. 이는 정적 라이브러리 파일로부터 모든 것을 복제하기 때문이며 따라서 정적 라이브러리 파일의 존재에 더는 의존하지 않는다.

공유 목적 파일에서는 그렇지 않다. 프로그램 로더가 기본 탐색 경로에서 libgeometry.so 를 찾을 수 없으므로 오류가 발생했다. 그러므로 탐색 경로에 /opt/geometry 를 추가해서 거기에서 libgeometry.so 를 찾을 수 있도록 해야 한다. 경로를 추가하기 위해 환경 변수인 LD_LIBRARY_PATH 가 현재 경로를 가리키도록 업데이트한다.

로더는 환경 변수를 검사할 것이고, 필요한 공유 라이브러리를 지정 경로에서 검색할 것이다. 환경 변수에는 하나 이상의 경로를 지정할 수 있다.

```shell
$ export LD_LIBRARY_PATH=/opt/geometry
$ ./ex.out
Polar Position: Length: 223.606798, Theta: 63.434949 (deg)
$
```

이번에는 프로그램이 성공적으로 실행된다. 프로그램 로더가 공유 목적 파일을 찾았고 동적 링커가 그 파일로부터 필요한 심벌을 성공적으로 로드했다는 의미이다.

앞의 셀 박스에서 LD_LIBRARY_PATH 를 변경하려고 export 명령어를 사용했으니 유의하자. 하지만 일반적으로는 환경 변수를 실행 명령어와 함께 설정한다. 다음 셸 박스에서 이를 확인할 수 있다.

```shell
$ LD_LIBRARY_PATH=/opt/geometry ./ex.out
Polar Position: Length: 223.606798, Theta: 63.434949 (deg)
$
```

 앞에서 한 대로 몇 개의 공유 목적 파일과 실행 파일 하나를 링크함으로써, 이 실행 파일이 실행 시 많은 공유 라이브러리를 찾아서 로드해야 한다고 시스템에 명령한다. 따라서 실행 파일을 실행하기 전에, 로더는 자동으로 이러한 공유 목적 파일ㅇ르 찾고, 필요한 심벌이 프로세스가 접근할 수 있는 알맞은 주소에 연결된다. 그래야만 프로세서가 실행을 시작할 수 있다.



### 3.6.1 공유 라이브러리의 수동 로딩

또한 공유 목적 파일은 다른 방식으로 로드되고 사용될 수 있다. 로더 프로그램이 자동으로 로드되지 않는 방식이다. 공유 라이브러리 내부에서 찾을 수 있는 심벌을 이용하기 전, 공유 목적 파일을 수동으로 로드하는 함수를 개발자가 사용할 수 있다. 수동 로딩 메커니즘을 위한 응용프로그램이 존재한다.

예제는 링크 단계에서 공유 목적 파일을 느리게 또는 수동으로, 혹은 공유 목적 파일 없이 로드하는 법을 제시한다. 이번 예제는 전과 같은 로직을 빌려 오지만, 그 대신 프로그램 내에서 공유 목적 파일인 libgeometry.so 를 수동을 로드한다.

예제를 보기 전에 예제가 작동할 수 있도록 libgeometry.so 를 약간 다르게 생성해야 한다.

```shell
$ gcc -shared 2d.o 3d.o trigon.o -lm -o libgeometry.so
$
```

앞의 명령어에서는 새로운 옵션인 -m을 볼 수 있다. 이것은 링커가 표준 수학 라이브러리인 libm.so와 관련된 공유 목적 파일을 링크하도록 한다. libgeometry.so 를 수동으로 로드할 때, 이 파일의 의존성이 어느 정도는 자동으로 로드되어야 하기 때문이다. 만약 그렇지 않다면 cos 또는 sqrt 같이 libgeometry.so 가 필요로 하는 심벌에 관한 오류가 발생한다. 최종 실행 파일과 수학 표준 라이브러리를 링크하지는 않을 것이며, libgeometry.so 를 로드할 때 로더가 이를 자동으로 해결할 것이라는 점을 참고하자.



```c
#include <stdio.h>
#include <stdlib.h>
#include <dlfcn.h>

#include "geometry.h"

polar_pos_2d_t (*func_ptr)(cartesian_pos_2d_t*);

int main(int argc, char **argv)
{
    void* handle = dlopen("/opt/geometry/libgeometry.so", RTLD_LAZY);
    if (!handle) {
        fprintf(stderr, ""%s\n", dlerror());
        exit(1);
    }
                
    func_ptr = dlsym(handle, "convert_to_2d_polar_pos");
    if (!func_ptr) {
        fprintf(stderr, "%s\n", dlerror());
    }
    
    cartesian_pos_2d_t cartesian_pos;
    cartesian_pos.x = 100;
    cartesian_pos.y = 200;
    polar_pos_2d_r polar_pos = func_ptr(&cartesian_pos);
    printf("Polar Position: Length: %f, Theta: %f (deg)\n", polar_pos.length, polar_pos.theta);
    return 0;
}
```

이 코드에서 dlopen과 dlsym이라는 함수로 공유 목적 파일을 로드하는 방법을 확인할 수  있다. 또한 convert_to_2d_polar_pos 가 공유 목적 파일 안에 잇다는 것도 볼 수 있다. dlsym 함수는 함수 포인터를 반환하며, 이 포인터는 대상 함수를 불러오는 데에 쓰인다.

이 코드는 /opt/geometry 에서 공유 목적 파일을 찾으며, 이 디렉터리에 해당 파일이 없다면 오류 메시지가 나타나니 주의해야 한다. 참고로 macOS 에서 공유 목적 파일의 확장자는 .dylib이다. 따라서 올바른 확장자로 파일을 로드하려면 이 코드를 수정해야 한다.



```shell
$ gcc main.c -ldl -o ex.out
$ ./ex.out
Polar Position: Length: 223.606798, Theta: 63.434949 (deg)
$
```

 프로그램을 libgeometry.so 파일과 링크하지 않았다. 필요할 때 이 파일을 수동으로 로드하려고 했기 때문이다. 이 방법은 공유 목적 파일의 __지연된 로딩__ 이라고 한다. 이름은 이렇지만, 경우에 따라 공유 목적 파일을 지연해 로드하는 방식은 정말 유용하다.

같은 라이브러리의 별도 실행 혹은 별도 버전을 위한 공유 목적 파일을 별개로 만들려고 할 때가 지연된 로딩에 해당하는 경우이다. 지연된 로딩을 하면 필요한 공유 목적 파일을 자유롭게 로드할 수 있다. 반면 자동을 로드하면 이에 대한 자유도가 감사한다.



## 3.7 마무리

3장에서는 C/C++ 프로젝트를 빌드한 뒤 결과물인 여러 종류의 목적 파일을 주로 설명했다. 이번 장의 각 부분에서는 다음과 같은 요점을 다뤘다.

- API와 ABI. 그리고 이들의 차이점을 알아봤다.
- 다양한 목적 파일 형식을 살펴보고 역사도 간단히 짚어봤다. 목적 파일 형식은 조상이 같지만 각자 특정한 경로를 거쳐 현재와 같은 모습이 되었다.
- 재배치 가능한 목적 파일 및 이 파일의 내부 구조를 ELF 재배치 가능한 목적 파일과 관련해 설명했다.
- 실행 파일을 알아보고, 실행 파일과 재배치 가능한 목적 파일 간의 차이를 논의했다. ELF 실행 가능한 목적 파일도 살펴봤다.
- 정적 심벌 테이블과 동적 심벌 테이블을 살펴봤고, 커맨드 라인 도구를 사용해서 심벌 테이블의 내용을 읽는 법을 알아봤다.
- 정적 링크와 동적 링크를 다뤘다. 그리고 다양한 최종 이진 파일을 만들거나 프로그램을 실행할 때 다양한 심벌 테이블을 찾는 방법을 설명했다.
- 정적 라이브러리 파일을 살펴봤으며, 이 파일이 여러 재배치 가능한 목적 파일을 포함하는 아카이브 파일에 불과하다는 사실을 설명했다.
- 위치 독립적 코드를 설명했으며, 공유 라이브러리를 생성하는 데 관여하는 재배치 가능한 목적 파일이 반드시 위치 독립적이어야 하는 이유도 살펴봤다.

4장에서는 프로세스의 메모리 구조를 살펴볼거다. 이는 C/C++의 또다른 주요 주제이다. 다양한 메모리 세그먼트를 다음 장에서 설명할 것이며, 메모리 문제없이 코드를 작성하는 법을 알아보자.















