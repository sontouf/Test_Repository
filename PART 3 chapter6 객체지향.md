# PART 3 객체지향

# CHAPTER 6 OOP와 캡슐화

객체지향 프로그래밍 또는 OOP를 주제로 한 좋은 책과 글은 많다. 하지만 같은 주제를 C처럼 객체지향적이지 않은 언어로 다루지는 않는 것 같다. 가능하긴 한 일일까? 객체지향을 지원하지 않는 언어로 객체지향 프로그램을 작성할 수 있을까? 정확히 말하자면 C 언어를 사용해서 객체지향 프로그램을 작성할 수 있을까?

그렇다. 하지만 방법 이전에 이유부터 설명해야 한다. 질문을 작게 나누어서 OOP 가 실제로 무엇을 의미하는 지 살펴봐야 한다. 객체지향을 지원하지 않는 언어를 언어를 이용해서 객체지향 프로그램을 작성할 수 있는 까닭은 무엇일까? 역설처럼 들리지만 그렇지 않다. 이번 장에서는 C 에서 객체지향 프로그램을 작성할 수 있는 이유는 무엇인지, 그리고 어떻게 해야 하는지를 설명한다.

주요 프로그래밍 언어로 C 를 사용할 때 OOP에 관한 설명과 이해가 무슨 의미가 있느냐 하는 것이다. 오픈 소스 커널처럼 성숙한 C 코드 베이스, 그리고 HTTPD, Postfix, nfsd, ftpd 와 같은 서비스의 구현, 또 OpenSSL 과 OpenCV 와 같은 여러 C 라이브러리는 모두 객체지향 방식으로 작성되었다. 이것이 C 가 객체지향이라는 의미가 아니다. 그보다는 이러한 프로젝트가 내부 구조를 구성하는 방식이 객체지향적 사고방식에서 비롯한다는 뜻이다.

 C는 문법상 클래스, 상속, 가상 함수와 같은 객체지향 개념을 지원하지 않는다. 하지만 간접적인 방식으로는 객체지향 개념을 지원한다. 사실 역사상 거의 모든 컴퓨터 언어는 기본적으로 OOP를 지원했다. 모든 범용 프로그래밍 언어에서는 자료형을 확장하는 방법이 반드시 존재할 것이고 이것이 OOP 로 향하는 첫걸음이기 때문이다.

C는 문법상 객체지향을 특징으로 삼을 수도 없고 __그래서도 안된다__ 오래된 언어여서가 아니라, 그럴 만한 이유가 있어서다. 간단히 말하자면 C로 객체지향 프로그램을 작성할 수는 있지만, 복잡성을 해결하려면 추가로 약간의 수고가 든다.

절차지향 그리고 함수형 패러다임과 더불어 OOP를 또 다른 프로그래밍 패러다임이라고 한다. 하지만 OOP는 그 이상의 의미가 있다. OOP는 문제를 생각하고 분석하는 방식에 더 가깝다. OOP는 전 우주와 그 안에 있는 대상의 위계질서에 관한 태도이다. OOP는 기본적으로 우리 주변의 물리적 개체와 추상적 개체를 이해하는 , 오래전부터 전해 내려온 고유한 방법이다. 이는 자연을 이해하는 매우 기본적인 방법이다. 우리는 언제나 모든 문제를 객체지향적 관점에서 생각했다. OOP는 인간이 항상 채택했던 것과 같은 관점을 적용하는 것에 불과하다. 다만 이번에는 계산 문제를 해결하기 위해 프로그래밍 언어를 사용할 뿐이다. 이 모든 것은 소프트웨어 작성에 사용되는 가장 일반적인 프로그래밍 패러다임이 OOP인 이유를 설명한다.

이 후 나올 내용에서는 클래스를 선언하거나 상속관계를 만들거나 다른 OOP 개념을 다룰 때 사용하는 특정 라이브러리 또는 매크로를 제안하려는게 아니다. 게다가 어떠한 방법론이나 특정한 명명 규칙을 도입하지도 않을 것이다. 단순히 있는 그대로의 C 언어로 OOP 개념을 구핸해보자.

- OOP 관련 자료에서 사용하는 가장 기본적인 용어의 정의를 설명한다, 클래스, 객체, 속성, 행위, 메서드, 도메인 등을 정의한다. 또한 이 용어는 다른 OOP 관련 자료를 이해할 때도 필수적이다. OOP를 받아들이는 언어의 주요 부분이기 때문이다
- 첫 번째 절에서 용어만 설명하지는 않는다. 용어 뿐만 아니라 객체지향의 뿌리와 철학을 깊게 다루며, 객체지향적 사고방식의 본질을 탐구해보자
- 두 번째 절에서는 C가 왜 객체지향이 아닌지, 왜 객체지향이 될 수 없는지를 다룬다. 질의응답이 필요한 매우 중요한 질문이다.
- 세 번쨰 절에서는 캡슐화를 설명한다. 캡슐화는 OOP에서 가장 기본적인 개념이다. 간단히 말하면 캡슐화는 객체를 생성하고 사용할 수 있도록 한다. 객체 안에 변수와 메서드를 넣을 수 있다는 개념은 직접적으로 캡슐화에서 비롯한다.
- 그 다음 정보 은닉으로 넘어간다. 정보 은닉은 캡슐화의 기능이다. 정보 은닉이 없다면 소프트웨어 모듈의 의존성을 분리할 수 없으며, 사실상 구현에 의존하는 API를 클라이언트에게 제공할 수도 없다.



## 6.1 객체지향적 사고

이번 절의 내용을 소개하면 말한 대로, 객체지향적 사고는 우리 주변의 대상을 작게 나누어 분석하는 방법이다. 이를테면 테이블 위의 물병 하나를 바라볼 떄, 깊게 분석하지 않아도 물병과 테이블은 서로 다른 물체라고 이해한다.

사람은 물병과 테이블 사이에서 둘을 구분하는 경계를 무의식적으로 인식한다. 물병의 색을 바꿀 수 있고, 테이블의 색은 바뀌지 않는다는 것도 알고 있다.

이는 우리가 객체지향적 관점에서 주위환경을 본다는 점을 드러낸다. 즉, 우리는 주변의 객체지향적 현실을 마음에 반영할 뿐이다. 또한 컴퓨터게임, 3D 모델링 소프트웨어, 엔지니어링 소프트웨어에서도 이러한 현상을 많이 찾아볼 수 있는데, 인간과 상호작용하는 대상을 모두 포함한다.

OOP는 객체지향적 사고를 소프트웨어 설계 및 개발에 도입하는 것이다. 객체지향적  사고는 우리의 환경을 처리하는 기본 방식이며, 따라서 OOP는 소프트웨어 작성에 가장 보편적으로 사용된 패러다임이었다.



### 6.1.1 정신적 개념

인간이 프로그램을 작성할 떄는 자연스럽게 객체지향적인 것이 된다. 변수 이름에서부터 분명히 나타날 것이다.

```c
char* student_first_names[10];
char* student_surnames[10];
int student_ages[10];
double student_marks[10];

```

위에서 보이는 선언은 변수 이름을 이용해서 __student __ 라는 동일한 개념으로 변수 여러 개를 그룹으로 묶는 법을 보여준다. 명명은 이렇게 해야 한다. 그렇지 않으면 객체지향적 사고에 전혀 의미가 없는 임시 이름 때문에 혼란스러울 것이다.

변수의 명명은 어제나 중요하다. 마음속 개념이나 데이터 및 이러한 개념의 관계는 이름을 통해 떠올 수 잇기 때문이다. 이런 방식의 임시 이름을 사용하면 코드에서 개념과 개념의 관계를 알 수 없다. 컴퓨터는 문제가 되지 않지만, 개발자가 문제를 분석하고 해결하는 일을 복잡하게 만들며 실수할 가능성이 커진다.

여기에서 개념의 의미하는 바를 더 명확히 하자. 개념이란 사고 또는 생각으로, 마음속에 존재하는 정신적 또는 추상적 이미지이다. 개념은 현실 세계의 개체에 관한 인식으로 형성되거나, 단순하게는 완전히 가상적이며 추상적일 수 있다. 나무를 보거나 자동차를 생각할 떄 이에 해당하는 이미지가 서로 다른 두 가지 개념으로 떠오른다. 다른 맥락에서 개념이라는 용어를 쓸 때, 예를 들면 객체지향적 개념의 경우 개념이라는 용어를 방금 정의한 것과 같은 방식으로는 전혀 사용하지 않는다. 기술 관련 주제에서 사용하는 개념이라는 단어는 쉽게 말해, 주제와 관련해서 이해해야 하는 원리를 일컫는다. 지금부터는 이러한 기술 관련 주제에 해당하는 정의를 사용하겠다.

 객체지향적 사고는 개념과 개념 사이 관계의 관점에서 사고하는 것이다. 따라서 올바른 객체지향 프로그램을 작성하려면 서로 연관된 객체 및 그에 대응하는 개념과 관계를 제대로 이해해야 한다. 

 객체지향 지도는 여러 개념과 그 개념의 상호 관계로 형성된다. 예를 들면 한 팀으로서 업무를 처리해야 할 떄, 이러한 지도로는 다른 사람과 쉽게 소통할 수 없다. 게다가 이러한 정신적 개념은 휘발성이 있고 종잡을 수 없으며 잊히기 십상이다. 그래서 마인드맵을 소통 가능한 아이디어로 변환하려면 표현에 관한 모데링나 다른 도구가 필요하다는 사실을 더욱 강조한다.



### 6.1.2 마인드맵과 객체 모델

예를 들어보자.

우리 교실은 두 개의 창문이 있는 오래된 곳이다. 교실에 들어서면 반대편 벽에 창문 두 개가 보인다. 교실 가운데에는 갈색 나무 의자가 많다. 의자에 앉은 학생이 5명 있고, 그 중 2명은 남자아이다. 나무로 된 초록색 칠판이 오른쪽 벽에 있고, 선생님이 학생들에게 이야기하고 있다. 선생님은 파란 셔츠를 입은 나이 든 남자다.

다섯가지 개념이 떠오른다. 하나는 교실 안의 각 학생이다. 또한 의자에 관한 또 다른 개념이 다섯가지이다. 나무에 관한 개념과 유리에 관한 다른 개념도 있다. 그리고 모든 의자가 나무로 만들어졌다는 걸 안다. 이것은 나무의 개념과 의자 개념 사이의 개념이다. 또한 모든 학생이 의자에 앉았다는 걸 안다. 이처럼 의자와 학생 사이에는 다섯 가지 관계가 존재한다. 계속해서 더 많은 개념을 식별하고 관련시킬 수 있다. 순식간에 수백 가지 개념의 관계를 서술하는 거대하고 복잡한 그래프를 갖게 된다.

 결국 모든 사람이 다른 방식으로 할 수 있다는 결론에 도달한다. 이러한 절차는 특정 문제를 해결하려고 할 때 언제나 발생한다. 문제에 달려들기 전에는 마인드맵을 만들어야 한다. 이 단계는 __이해 단계 understand phase__ 라고 한다.

 문제의 개념 및 개념 사이에서 발견한 관계에 기반한 접근 방식을 사용해서 문제를 해결한다. 이러한 개념의 관점에서 해결책을 설명하며, 누군가 여러분의 해결책을 이해하고자 한다면 그들은 개념과 개념 간의 관계를 먼저 이해해야 한다.

 컴퓨터를 이용해서 문제를 해결하려고 할 때 바로 이런 일이 일어난다고 하면 아마 깜짝 놀랄 것이다. 하지만 정확히 그렇다. 문제를 객체와 그들 간의 관계로 나눈 뒤, 이 객체를 기반을오 궁극적으로 문제를 해결하는 프로그램을 작성하려고 한다.

객체지향 프로그램은 객체의 측면에서 개념을 모방한다. 우리가 마음속으로 문제에 관한 마인드맵을 생성하는 동안, 프로그램은 메모리에 객체 모델을 생성한다. 다시 말해 인간과 객체지향 프로그램을 비교하면 __개념, 마음, 마인드맵__ 과 같은 용어는 __객체, 메모리, 객체 모델__ 에 각각 대응한다. 이것은 이번 절에서 설명하는 가장 중요한 상관관계이며, 우리의 사고방식을 객체지향 프로그램과 연관시킨다.



### 6.1.3 코드에는 없는 객체

실행 중인 객체지향 프로그램의 메모리를 살펴보면 객체로 가득 찼으며, 이 객체는 모두 상호연관됨을 알게 될 것이다. 인간도 마찬가지이다. 인간을 기계로 간주한다면 언제나 가득차 있으며 죽을 때까지 실행 중이라고 할 수있다. 이러한 비유는 중요하다. 개념이 살아있는 마음속에만 존재할 수 있는 것처럼, 객체는 오직 실행 중인 프로그램에만 존재할 수 있다. 즉, 실행 중인 프로그램이 있어야만 객체가 존재한다는 의미이다.

```
객체지향 코드를 작성할 떄는 아직 아무 객체도 존재하지 않는다. 객체는 코드를 빌드해서 실행 가능한 프로그램을 만들고 프로그램을 실행헤야 비로소 만들어진다.
```

OOP는 객체를 실제로 만들지 않는다. OOP는 프로그램이 실행될 떄 완전히 동적인 객체 모델로 이어질 일련의 명령어를 만든다. 그러니 일단 컴파일 및 실행이 되면 객체지향 코드는 객체를 만들고, 수정하고, 연결하고, 심지어 삭제까지 할 수 있어야 한다.

이처럼 객체지향 코드를 작성하기란 꽤 까다롭다. 객체와 그들의 관계가 존재하기도 전에 그것을 상상해야 한다. 이것이 바로 OOP가 복잡한 이유이자, 객체지향을 지원하는 프로그래밍 언어가 필요한 이유이다. 아직 만들어지지 않은 것에 관한 다양한 세부 사항을 설명하고 제작하는 기술을 일반적으로 설계라 한다. 그래서 보통 객체지향 프로그래밍에서 이 과정 __객체지향 설계 object-oriented design(OOD)__ 라 한다,.

객체지향 코드에서는 객체를 생성할 계획만 세울 수 있다. OOP는 객체가 언제 어떻게 실행되어야 하는지에 관한 일련의 명령어로 이어진다. 객체와 관련된 모든 작업은 프로그래밍 언어로 자세히 설명할 수 있다. OOP 언어는 다양한 객체지향 작업을 작성하고 계획할 수 있도록 일련의 명령어를 갖는 언어이다.

모든 객체는 지정된 생명 주기를 갖는다. 마음속 개념도 마찬가지이다. 어느 시점에는 아이디어가 마음속에 떠오르고 마음속 이미지가 개념으로 생성되며, 또 어느 시점에는 사라진다. 객체도 마찬가지이다. 객체는 어느 한 시점에서 생성되고, 다른 시점에서 소멸한다.

마지막으로 어떤 정신적 개념은 매우 확고하고 일관적이다. 이런 개념은 그 어떤 마음과도 무관하며, 이들을 이해할 마음이 없었을 때조차 계속 존재해 온 것처럼 보인다. 대체로 수학적 개념이 이에 해당한다. 숫자 2를 예를 들어보자. 전 우주에 숫자 2가 단 하나만 있다니 정말 놀라운 일이다. 이 말은 우리의 마음 속에 숫자 2라는 같은 개념이 있다는 의미이다. 만약 이걸 바꾸려고 한다면 더 이상 숫자 2가 아니게 된다. 여기가 바로 객체지향을 벗어나 다른 영역으로 나아가는 지점이다. 다른 영역은 불변 객체로 가득한데, 불변 객체는 __함수형 프로그래밍__ 패러다임이라는 제목으로 설명한다.



### 6.1.4 객체 속성

모든 마음속의 각 개념에는 관련된 속성이 있다. 교실에 관한 설명에는 의자가 있었고, 갈색이었다. 모든 의자 객체는 색상이라는 속성을 가지며 갈색이었다. 교실에는 다른 4개의 의자가 있었고, 이들은 서로 다른 값의 객체 속성을 가질 수 있다.

객체는 두 개 이상의 속성 또는 속성의 집합을 가질 수 있다. 이러한 속성에 할당된 값을 총괄해 객체의 상태라고 한다. 상태란 단순히 객체에 연결된 특정 속성에 속하는 값의 목록으로 이해할 수 있다. 상태란 단순히 객체에 연결된 특정 속성에 속하는 값의 목록으로 이해할 수 있다. 이는 단순히 수명동안 상태가 변경될 수 있음을 뜻한다. 객체는 또한 __상태가 없을__ 수도 있다. 이는 객체가 어떠한 상태를 갖지 않음을 뜻한다.

또한 객체는 __불변__ 일 수도 있다. 이는 정확히 변경할 수 없는 숫자 2에 해당하는 개념과 마찬가지이다. 불변한 것이란 생성될 때 상태가 결정되고 이후에는 수정될 수 없음을 의미한다.

 ```
 상태가 없는 객체는 수명 동안 상태를 변경할 수 없으므로 불변 객채로 간주한다. 사실은 변경할 상태가 없다.
 ```

불변 객체는 특히 중요하다. 상태가 변경될 수 없다는 것은 장점이다. 특히 멀티스레드 환경에서 불변 객체가 공유될 떄 그렇다.



### 6.1.5 도메인

