# PART 3 객체지향

# CHAPTER 6 OOP와 캡슐화

객체지향 프로그래밍 또는 OOP를 주제로 한 좋은 책과 글은 많다. 하지만 같은 주제를 C처럼 객체지향적이지 않은 언어로 다루지는 않는 것 같다. 가능하긴 한 일일까? 객체지향을 지원하지 않는 언어로 객체지향 프로그램을 작성할 수 있을까? 정확히 말하자면 C 언어를 사용해서 객체지향 프로그램을 작성할 수 있을까?

그렇다. 하지만 방법 이전에 이유부터 설명해야 한다. 질문을 작게 나누어서 OOP 가 실제로 무엇을 의미하는 지 살펴봐야 한다. 객체지향을 지원하지 않는 언어를 언어를 이용해서 객체지향 프로그램을 작성할 수 있는 까닭은 무엇일까? 역설처럼 들리지만 그렇지 않다. 이번 장에서는 C 에서 객체지향 프로그램을 작성할 수 있는 이유는 무엇인지, 그리고 어떻게 해야 하는지를 설명한다.

주요 프로그래밍 언어로 C 를 사용할 때 OOP에 관한 설명과 이해가 무슨 의미가 있느냐 하는 것이다. 오픈 소스 커널처럼 성숙한 C 코드 베이스, 그리고 HTTPD, Postfix, nfsd, ftpd 와 같은 서비스의 구현, 또 OpenSSL 과 OpenCV 와 같은 여러 C 라이브러리는 모두 객체지향 방식으로 작성되었다. 이것이 C 가 객체지향이라는 의미가 아니다. 그보다는 이러한 프로젝트가 내부 구조를 구성하는 방식이 객체지향적 사고방식에서 비롯한다는 뜻이다.

 C는 문법상 클래스, 상속, 가상 함수와 같은 객체지향 개념을 지원하지 않는다. 하지만 간접적인 방식으로는 객체지향 개념을 지원한다. 사실 역사상 거의 모든 컴퓨터 언어는 기본적으로 OOP를 지원했다. 모든 범용 프로그래밍 언어에서는 자료형을 확장하는 방법이 반드시 존재할 것이고 이것이 OOP 로 향하는 첫걸음이기 때문이다.

C는 문법상 객체지향을 특징으로 삼을 수도 없고 __그래서도 안된다__ 오래된 언어여서가 아니라, 그럴 만한 이유가 있어서다. 간단히 말하자면 C로 객체지향 프로그램을 작성할 수는 있지만, 복잡성을 해결하려면 추가로 약간의 수고가 든다.

절차지향 그리고 함수형 패러다임과 더불어 OOP를 또 다른 프로그래밍 패러다임이라고 한다. 하지만 OOP는 그 이상의 의미가 있다. OOP는 문제를 생각하고 분석하는 방식에 더 가깝다. OOP는 전 우주와 그 안에 있는 대상의 위계질서에 관한 태도이다. OOP는 기본적으로 우리 주변의 물리적 개체와 추상적 개체를 이해하는 , 오래전부터 전해 내려온 고유한 방법이다. 이는 자연을 이해하는 매우 기본적인 방법이다. 우리는 언제나 모든 문제를 객체지향적 관점에서 생각했다. OOP는 인간이 항상 채택했던 것과 같은 관점을 적용하는 것에 불과하다. 다만 이번에는 계산 문제를 해결하기 위해 프로그래밍 언어를 사용할 뿐이다. 이 모든 것은 소프트웨어 작성에 사용되는 가장 일반적인 프로그래밍 패러다임이 OOP인 이유를 설명한다.

이 후 나올 내용에서는 클래스를 선언하거나 상속관계를 만들거나 다른 OOP 개념을 다룰 때 사용하는 특정 라이브러리 또는 매크로를 제안하려는게 아니다. 게다가 어떠한 방법론이나 특정한 명명 규칙을 도입하지도 않을 것이다. 단순히 있는 그대로의 C 언어로 OOP 개념을 구핸해보자.

- OOP 관련 자료에서 사용하는 가장 기본적인 용어의 정의를 설명한다, 클래스, 객체, 속성, 행위, 메서드, 도메인 등을 정의한다. 또한 이 용어는 다른 OOP 관련 자료를 이해할 때도 필수적이다. OOP를 받아들이는 언어의 주요 부분이기 때문이다
- 첫 번째 절에서 용어만 설명하지는 않는다. 용어 뿐만 아니라 객체지향의 뿌리와 철학을 깊게 다루며, 객체지향적 사고방식의 본질을 탐구해보자
- 두 번째 절에서는 C가 왜 객체지향이 아닌지, 왜 객체지향이 될 수 없는지를 다룬다. 질의응답이 필요한 매우 중요한 질문이다.
- 세 번쨰 절에서는 캡슐화를 설명한다. 캡슐화는 OOP에서 가장 기본적인 개념이다. 간단히 말하면 캡슐화는 객체를 생성하고 사용할 수 있도록 한다. 객체 안에 변수와 메서드를 넣을 수 있다는 개념은 직접적으로 캡슐화에서 비롯한다.
- 그 다음 정보 은닉으로 넘어간다. 정보 은닉은 캡슐화의 기능이다. 정보 은닉이 없다면 소프트웨어 모듈의 의존성을 분리할 수 없으며, 사실상 구현에 의존하는 API를 클라이언트에게 제공할 수도 없다.



## 6.1 객체지향적 사고

이번 절의 내용을 소개하면 말한 대로, 객체지향적 사고는 우리 주변의 대상을 작게 나누어 분석하는 방법이다. 이를테면 테이블 위의 물병 하나를 바라볼 떄, 깊게 분석하지 않아도 물병과 테이블은 서로 다른 물체라고 이해한다.

사람은 물병과 테이블 사이에서 둘을 구분하는 경계를 무의식적으로 인식한다. 물병의 색을 바꿀 수 있고, 테이블의 색은 바뀌지 않는다는 것도 알고 있다.

이는 우리가 객체지향적 관점에서 주위환경을 본다는 점을 드러낸다. 즉, 우리는 주변의 객체지향적 현실을 마음에 반영할 뿐이다. 또한 컴퓨터게임, 3D 모델링 소프트웨어, 엔지니어링 소프트웨어에서도 이러한 현상을 많이 찾아볼 수 있는데, 인간과 상호작용하는 대상을 모두 포함한다.

OOP는 객체지향적 사고를 소프트웨어 설계 및 개발에 도입하는 것이다. 객체지향적  사고는 우리의 환경을 처리하는 기본 방식이며, 따라서 OOP는 소프트웨어 작성에 가장 보편적으로 사용된 패러다임이었다.



### 6.1.1 정신적 개념

인간이 프로그램을 작성할 떄는 자연스럽게 객체지향적인 것이 된다. 변수 이름에서부터 분명히 나타날 것이다.

```c
char* student_first_names[10];
char* student_surnames[10];
int student_ages[10];
double student_marks[10];

```

위에서 보이는 선언은 변수 이름을 이용해서 __student__ 라는 동일한 개념으로 변수 여러 개를 그룹으로 묶는 법을 보여준다. 명명은 이렇게 해야 한다. 그렇지 않으면 객체지향적 사고에 전혀 의미가 없는 임시 이름 때문에 혼란스러울 것이다.

변수의 명명은 어제나 중요하다. 마음속 개념이나 데이터 및 이러한 개념의 관계는 이름을 통해 떠올 수 잇기 때문이다. 이런 방식의 임시 이름을 사용하면 코드에서 개념과 개념의 관계를 알 수 없다. 컴퓨터는 문제가 되지 않지만, 개발자가 문제를 분석하고 해결하는 일을 복잡하게 만들며 실수할 가능성이 커진다.

여기에서 개념의 의미하는 바를 더 명확히 하자. 개념이란 사고 또는 생각으로, 마음속에 존재하는 정신적 또는 추상적 이미지이다. 개념은 현실 세계의 개체에 관한 인식으로 형성되거나, 단순하게는 완전히 가상적이며 추상적일 수 있다. 나무를 보거나 자동차를 생각할 떄 이에 해당하는 이미지가 서로 다른 두 가지 개념으로 떠오른다. 다른 맥락에서 개념이라는 용어를 쓸 때, 예를 들면 객체지향적 개념의 경우 개념이라는 용어를 방금 정의한 것과 같은 방식으로는 전혀 사용하지 않는다. 기술 관련 주제에서 사용하는 개념이라는 단어는 쉽게 말해, 주제와 관련해서 이해해야 하는 원리를 일컫는다. 지금부터는 이러한 기술 관련 주제에 해당하는 정의를 사용하겠다.

 객체지향적 사고는 개념과 개념 사이 관계의 관점에서 사고하는 것이다. 따라서 올바른 객체지향 프로그램을 작성하려면 서로 연관된 객체 및 그에 대응하는 개념과 관계를 제대로 이해해야 한다. 

 객체지향 지도는 여러 개념과 그 개념의 상호 관계로 형성된다. 예를 들면 한 팀으로서 업무를 처리해야 할 떄, 이러한 지도로는 다른 사람과 쉽게 소통할 수 없다. 게다가 이러한 정신적 개념은 휘발성이 있고 종잡을 수 없으며 잊히기 십상이다. 그래서 마인드맵을 소통 가능한 아이디어로 변환하려면 표현에 관한 모데링나 다른 도구가 필요하다는 사실을 더욱 강조한다.



### 6.1.2 마인드맵과 객체 모델

예를 들어보자.

우리 교실은 두 개의 창문이 있는 오래된 곳이다. 교실에 들어서면 반대편 벽에 창문 두 개가 보인다. 교실 가운데에는 갈색 나무 의자가 많다. 의자에 앉은 학생이 5명 있고, 그 중 2명은 남자아이다. 나무로 된 초록색 칠판이 오른쪽 벽에 있고, 선생님이 학생들에게 이야기하고 있다. 선생님은 파란 셔츠를 입은 나이 든 남자다.

다섯가지 개념이 떠오른다. 하나는 교실 안의 각 학생이다. 또한 의자에 관한 또 다른 개념이 다섯가지이다. 나무에 관한 개념과 유리에 관한 다른 개념도 있다. 그리고 모든 의자가 나무로 만들어졌다는 걸 안다. 이것은 나무의 개념과 의자 개념 사이의 개념이다. 또한 모든 학생이 의자에 앉았다는 걸 안다. 이처럼 의자와 학생 사이에는 다섯 가지 관계가 존재한다. 계속해서 더 많은 개념을 식별하고 관련시킬 수 있다. 순식간에 수백 가지 개념의 관계를 서술하는 거대하고 복잡한 그래프를 갖게 된다.

 결국 모든 사람이 다른 방식으로 할 수 있다는 결론에 도달한다. 이러한 절차는 특정 문제를 해결하려고 할 때 언제나 발생한다. 문제에 달려들기 전에는 마인드맵을 만들어야 한다. 이 단계는 __이해 단계 understand phase__ 라고 한다.

 문제의 개념 및 개념 사이에서 발견한 관계에 기반한 접근 방식을 사용해서 문제를 해결한다. 이러한 개념의 관점에서 해결책을 설명하며, 누군가 여러분의 해결책을 이해하고자 한다면 그들은 개념과 개념 간의 관계를 먼저 이해해야 한다.

 컴퓨터를 이용해서 문제를 해결하려고 할 때 바로 이런 일이 일어난다고 하면 아마 깜짝 놀랄 것이다. 하지만 정확히 그렇다. 문제를 객체와 그들 간의 관계로 나눈 뒤, 이 객체를 기반을오 궁극적으로 문제를 해결하는 프로그램을 작성하려고 한다.

객체지향 프로그램은 객체의 측면에서 개념을 모방한다. 우리가 마음속으로 문제에 관한 마인드맵을 생성하는 동안, 프로그램은 메모리에 객체 모델을 생성한다. 다시 말해 인간과 객체지향 프로그램을 비교하면 __개념, 마음, 마인드맵__ 과 같은 용어는 __객체, 메모리, 객체 모델__ 에 각각 대응한다. 이것은 이번 절에서 설명하는 가장 중요한 상관관계이며, 우리의 사고방식을 객체지향 프로그램과 연관시킨다.



### 6.1.3 코드에는 없는 객체

실행 중인 객체지향 프로그램의 메모리를 살펴보면 객체로 가득 찼으며, 이 객체는 모두 상호연관됨을 알게 될 것이다. 인간도 마찬가지이다. 인간을 기계로 간주한다면 언제나 가득차 있으며 죽을 때까지 실행 중이라고 할 수있다. 이러한 비유는 중요하다. 개념이 살아있는 마음속에만 존재할 수 있는 것처럼, 객체는 오직 실행 중인 프로그램에만 존재할 수 있다. 즉, 실행 중인 프로그램이 있어야만 객체가 존재한다는 의미이다.

```
객체지향 코드를 작성할 떄는 아직 아무 객체도 존재하지 않는다. 객체는 코드를 빌드해서 실행 가능한 프로그램을 만들고 프로그램을 실행헤야 비로소 만들어진다.
```

OOP는 객체를 실제로 만들지 않는다. OOP는 프로그램이 실행될 떄 완전히 동적인 객체 모델로 이어질 일련의 명령어를 만든다. 그러니 일단 컴파일 및 실행이 되면 객체지향 코드는 객체를 만들고, 수정하고, 연결하고, 심지어 삭제까지 할 수 있어야 한다.

이처럼 객체지향 코드를 작성하기란 꽤 까다롭다. 객체와 그들의 관계가 존재하기도 전에 그것을 상상해야 한다. 이것이 바로 OOP가 복잡한 이유이자, 객체지향을 지원하는 프로그래밍 언어가 필요한 이유이다. 아직 만들어지지 않은 것에 관한 다양한 세부 사항을 설명하고 제작하는 기술을 일반적으로 설계라 한다. 그래서 보통 객체지향 프로그래밍에서 이 과정 __객체지향 설계 object-oriented design(OOD)__ 라 한다,.

객체지향 코드에서는 객체를 생성할 계획만 세울 수 있다. OOP는 객체가 언제 어떻게 실행되어야 하는지에 관한 일련의 명령어로 이어진다. 객체와 관련된 모든 작업은 프로그래밍 언어로 자세히 설명할 수 있다. OOP 언어는 다양한 객체지향 작업을 작성하고 계획할 수 있도록 일련의 명령어를 갖는 언어이다.

모든 객체는 지정된 생명 주기를 갖는다. 마음속 개념도 마찬가지이다. 어느 시점에는 아이디어가 마음속에 떠오르고 마음속 이미지가 개념으로 생성되며, 또 어느 시점에는 사라진다. 객체도 마찬가지이다. 객체는 어느 한 시점에서 생성되고, 다른 시점에서 소멸한다.

마지막으로 어떤 정신적 개념은 매우 확고하고 일관적이다. 이런 개념은 그 어떤 마음과도 무관하며, 이들을 이해할 마음이 없었을 때조차 계속 존재해 온 것처럼 보인다. 대체로 수학적 개념이 이에 해당한다. 숫자 2를 예를 들어보자. 전 우주에 숫자 2가 단 하나만 있다니 정말 놀라운 일이다. 이 말은 우리의 마음 속에 숫자 2라는 같은 개념이 있다는 의미이다. 만약 이걸 바꾸려고 한다면 더 이상 숫자 2가 아니게 된다. 여기가 바로 객체지향을 벗어나 다른 영역으로 나아가는 지점이다. 다른 영역은 불변 객체로 가득한데, 불변 객체는 __함수형 프로그래밍__ 패러다임이라는 제목으로 설명한다.



### 6.1.4 객체 속성

모든 마음속의 각 개념에는 관련된 속성이 있다. 교실에 관한 설명에는 의자가 있었고, 갈색이었다. 모든 의자 객체는 색상이라는 속성을 가지며 갈색이었다. 교실에는 다른 4개의 의자가 있었고, 이들은 서로 다른 값의 객체 속성을 가질 수 있다.

객체는 두 개 이상의 속성 또는 속성의 집합을 가질 수 있다. 이러한 속성에 할당된 값을 총괄해 객체의 상태라고 한다. 상태란 단순히 객체에 연결된 특정 속성에 속하는 값의 목록으로 이해할 수 있다. 상태란 단순히 객체에 연결된 특정 속성에 속하는 값의 목록으로 이해할 수 있다. 이는 단순히 수명동안 상태가 변경될 수 있음을 뜻한다. 객체는 또한 __상태가 없을__ 수도 있다. 이는 객체가 어떠한 상태를 갖지 않음을 뜻한다.

또한 객체는 __불변__ 일 수도 있다. 이는 정확히 변경할 수 없는 숫자 2에 해당하는 개념과 마찬가지이다. 불변한 것이란 생성될 때 상태가 결정되고 이후에는 수정될 수 없음을 의미한다.

 ```
상태가 없는 객체는 수명 동안 상태를 변경할 수 없으므로 불변 객채로 간주한다. 사실은 변경할 상태가 없다.
 ```

불변 객체는 특히 중요하다. 상태가 변경될 수 없다는 것은 장점이다. 특히 멀티스레드 환경에서 불변 객체가 공유될 떄 그렇다.



### 6.1.5 도메인

특정 문제를 해결하기 위해 작성된 모든 프로그램은, 심지어 아주 작은 프로그램이라도 잘 정의된 도메인을 가진다. 도메인은 소프트웨어 엔지니어링과 관련한 문헌에서 널리 사용되는 또 다른 중요한 용어이다. 도메인은 소프트웨어가 기능을 공개할 경계를 정의한다. 또한 도메인은 소프트웨어가 다루어야 하는 요구사항을 정의한다.

도메인은 미리 정의된 구체적인 용어집을 사용해 임무를 수행하고 엔지진어가 도메인의 경계 내에 있도록 한다. 소프트웨어 프로젝트에 참여하는 모든 사람은 프로젝트가 정의된 도메인을 알아야 한다.

예를 들면, 일반적으로 은행 소프트웨어는 아주 잘 정의된 도메인을 위해 만들어진다. 은행 소프트웨어에는 계좌, 신용, 잔고, 이체, 대출, 이자 등을 포함하는 잘 알려진 용어의 집합이 있다. 도메인의 정의는 용어집의 용어 덕분에 명확해진다. 가령 환자, 약, 복용량과 같은 용어는 은행 도메인에서 찾을 수 없을 것이다.

예를 들어 헬스케어 도메인의 환자나 약물의 개념처럼, 주어진 도메인에 특정한 개념을 다루는 기능을 프로그래밍 언어가 제공하지 않는다면 그 도메인에 관한 소프트웨어를 해당 프로그래밍 언어로 작성하기는 어려울 것이다. 불가능하지는 않아도 확실히 복잡할 것이다. 게다가 소프트웨어가 크면 클수록 개발 및 유지는 더 어려워진다.



### 6.1.6 객체 사이의 관계

객체는 상호 연관될 수 있다. 객체는 관계를 나타내고자 서로를 참조할 수 있다. 예를 들어 교실에 관한 설명에서 student4라는 객체는 sitting on 이라고 명명된 관계에 대해 chair3 객체와 연관될 수 있다. 즉, student4 는 chair3에 앉아 있다. 이런 식으로 시스템 내의 모든 객체는 서로를 참조해 객체 모델이라는 객체의 네트워크를 형성한다. 앞서 설명했듯, 객체 모델은 마음속에서 형성한 마인드맵에 대응하는 것이다.

두 객체가 연관될 때 하나의 상태가 변하면 다른 상태에도 영향을 줄 수 있다. 예를 들어 설명해보자. 서로 연관되지 않은 객체 p1, p2가 잇으며, 이 두 객체는 픽셀을 나타낸다고 가정해보자.

객체 p1은 {x: 53, y: 345, red: 120, green: 45, blue: 178} 이라는 속성을 가진다. 또한 객체 p2는 {x: 53, y: 346, red: 79, green: 162, blue:23}이라는 속성을 가진다. 이 객체를 서로 연관시키려면 객체의 관계를 나타내는 추가 속성이 필요하다. p1 의 상태는 {x: 53, y: 345, red: 120, green: 45, blue: 178, adjacent_down_pixel: p2}로 바뀌고 p2의 상태는 {x: 53, y: 346, red: 79, green: 162, blue: 23, adjacent_up_pixel: p1}으로 바뀐다.

이러한 추가 속성을 사용함으로써 객체는 다른 객체와 관계가 있음을 인지한다. 예를 들어 p1은 자신과 인접한 픽셀 객체 adjacent_down_pixel 이 p2라는 것을 알고, p2는 adjacent_up_pixel이 p1이라는 것을 알고 있다.

만약 관계가 두 객체 사이에 형성된다면, 이 객체의 상태는 변경된다. 그러므로 객체에 새로운 속성을 추가함으로써 객체 사이의 관계가 만들어질 수 있으며, 따라서 객체의 관계는 객체 상태의 일부가 된다. 이는 당연히 객체의 가변성 또는 불변성에 영향이 있다.

객체의 상태 및 불변성을 정의하는 속성의 부분집합은 한 도메인에서 다른 도메인에서 변경될 수 있으며, 이러한 속성의 부분집합은 모든 속성을 반드시 포함하지는 않는다. 한 도메인에서는 비참조형 속성(x, y, red, green, blue) 만을 상태로 쓰고, 다른 도메인에서는 이를 모두 참조형 속성(adjacent_down_pixel, adjacent_up_pixel) 으로 결합할 수도 있다.



### 6.1.7 객체지향 작업

OOP 언어는 곧 실행될 프로그램에서 객체의 생성, 객체의 소멸, 객체의 상태 변경을 계획할 수 있도록 한다.

```
생성이라는 용어는 신중하게 사용해야 한다. 생성을 나타내는 용어로 creation 이나 building을 사용할 수도 있지만, 이 단어는 OOP 관련 문헌에서 표준 용어로 받아들이지 않는다. creation은 객체의 메모리 할당을 뜻하고, construction 은 속성의 초기화를 의미한다.
```



- 첫 번쨰 접근법은 빈 객체(상태에 어떠한 속성도 갖지 않는 것)를 생성하거나 또는 더 일반적으로 최소한의 속성의 집합을 갖는 객체를 생성하는 것을 포함한다.
- 코드가 실행되는 동안 더 많은 속성이 결정되고 추가된다. 이 방식을 사용하면 주변 환경에서 발견되는 변경 사항에 따라 같은 프로그램을 다르게 두 번 실행할 때, 같은 객체라도 다른 속성을 가질 수 있다.
- 각각의 객체는 별도의 개체로 취급된다. 그리고 어떤 두 객체가 공통 속성의 목록을 가져서 같은 그룹에 속하는 것처럼 보이더라도, 이들 두 객체는 프로그램이 지속되는 동안 상태에 다른 속성을 갖는다.
- 예를 들면 앞서 언급한 픽셀 객체 p1과 p2는 모두 픽셀이다. 같은 속성을 갖기 때문이다. 관계를 형성하고 나면 두 객체는 새롭고 다른 속성을 가지므로 다른 상태를 가진다.
- 이 접근 방식은 자바스크립트, 루비, 파이썬, 펄 PHP 와 같은 프로그래밍 언어에서 사용한다. 이들 대다수는 __인터프리터 프로그래밍 언어__ 이다. 그리고 속성은 내부의 자료구조에 맵 또는 해시로 저장되며 런타임 동안 쉽게 변경될 수 있다. 이 기술은 일반적으로 프로토타입 기반의 OOP 이라고 한다.
- 두 번째 접근법은 속성이 미리 정해져 있어서 실행 도중에 변경되지 않는 객체를 생성하는 것이다. 이 객체는 런타임 동안 어떠한 속성도 추가되지 못해 객체는 구조를 유지한다. 속성값만 변경할 수 있으며 이는 객체가 가변적 일 때만 가능하다.
- 이 접근법을 적용하려면, 개발자는 런타임 때 객체에 존재해야 하는 모든 속성을 추적하는 , 미리 설계된 객체템플릿 또는 클래스를 만들어야 한다. 그런 다음 이 템플릿을 컴파일해서 런타임 시에 객체지향  언어로 제공해야 한다.
- 많은 프로그래밍 언어에서 이러한 객체 템플릿을 클래스라고 한다. 자바나 C++, 파이썬과 같은 프로그래밍 언어는 객체 템플릿을 나타내는 용어로 클래스를 사용한다. 이 기술은 보통 클래스기반의 OOP 이라고 알려졌다. 파이썬은 프로토타입 기반 및 클래스 기반의 OOP를 모두 지원한다는 점을 참고한다.



객체의 인스턴스는 같은 것이며 서로 바꿔 사용할 수 있다. 하지만 어떤 글에서는 객체와 인스턴스 사이에 약간 차이가 있을지도 모른다. 참조라는 용어도 설명해보겠다. 객체 또는 인스턴스라는 용어는 객체의 값이 메모리에 할당된 실제 위치를 참조하는 데 사용된다. 반면 참조는 객체를 참조하는 포인터와 같다. 그러므로 같은 객체를 참조하는 여러 참조가 있을 수 있다. 일반적으로 객체는 이름이 없지만 참조는 이름이 있다.

클래스 및 프로토타입 기반의 두 접근법을 모두 사용할 수 있지만, c 그리고 특히 c++ 은 공식적으로 클래스 기반의 접근법을 지원하는 방식으로 설계되었다. 그러므로 개발자가  C 또는 C++ 에서 객체를 만들려면 우선 클래스가 있어야 한다. 클래스 및 OOP에서 클래스가 하는 역할은 다른 절에서 더 설명하겠다.

이어질 설명은 약간 무관해 보이질도 모르지만, 사실은 그렇지 않는다. 인간이 일생동안 어떻게 설정하는지에 대한 두 학파가 있으며, 이들은 지금까지 이야기한 객체 생성에 관한 접근법에 매우 정확하게 연결된다, 이러한 철학 중 하나는 인간은 태어날 때 본래 비어 있으며 본질이 없다고 한다.

살면서 인생에서 여러 좋고 나쁜 일을 경험함으로써 인간의 본질이 성장하기 시작해 독립적이고 성숙한 인격을 가진 존재로 발달한다. __실존주의__ 는 이러한 개념을 발전시켜온 철학적 전통이다.

실존주의는 유명한 계율은 '실존이 본질에 선행한다' 이다. 이는 단순히 인간은 우선 존재한 다음 삶의 경험으로부터 본질을 얻는다는 뜻이다. 이 아이디어는 객체 생성에 관한 프로토타입 기반의 접근법에 매우 가깝다. 프로토타입 기반의 접근법에서는 객체는 비어 있는 채로 생성된 다음 런타임 동안 발달한다.

다른 철학은 더 오래되었으며 대부분 종교에 의해 발전했다. 여기서는 인간은 어떤 이미지에 기반해 창조되었고, 이 이미지는 인간이 존재하기 전에 결정된 것이다. 이는 템플릿 또는 클래스를 기반으로 객체를 생성하려는 방식과 가장 비슷하다. 객체 창조자로서 클래스를 준비한 다음, 프로그램은 그 클래스에 따라 객체를 만들기 시작한다.

객체 생성과 마찬가지로 객체의 소멸도 런타임 동안 이루어진다. 그리고 우리는 코드에서 오직 소멸을 계획할 권한만 갖는다. 객체가 살아 있는 동안 할당한 모든 리소스는 객체가 파괴될 때 해제되어야 한다. 객체가 파괴될 때 다른 모든 관련된 객체도 파괴된 객체를 더 이상 참조하지 않도록 변경되어야 한다. 객체는 존재하지 않는 객체를 참조하는 속성을 가질 수 없다. 만약 그럴 경우 객체 모델에서 참조무결성을 잃는다. 이는 메모리 손상이나 세그멘테이션 오류 같은 런타임 오류뿐만 아니라 오산과 같은 논리적 오류도 일으킨다.

객체 수정은 두 가지 다른 방식으로 할 수 있다. 단순히 기존의 값을 변경하거나 또는 속성을 추가 및 삭제해 객체를 수정할 수 있다. 속성의 추가 및 삭제는 객체 생성에 대해 프로토타입 기반의 접근법을 선택했을 때만 가능하다. 불변 객체의 상태를 변경하는 일은 금지되어 있으며 보통 객체지향 언어에서는 허용하지 않는다는 점을 기억하자.



### 6.1.8 행위를 갖는 객체

모든 객체는 속성과 더불어 수행할 수  있는 기능에 관한 특정 목록을 갖는다. 예를 들어 자동차라는 객체는 속도를 높이거나 낮추고, 방향을 바꿀 수 있다. OOP에서 이러한 기능은 언제나 도메인의 요구 사항을 따른다. 예를 들어 은행 객체 모델에서 고객은 새 계좌를 주문할 수 있지만 먹을 수는 없다. 당연히 고객은 사람이 먹을 수 있지만, 먹는다는 기능이 은행 업무 도메인에 연관되지 않는 한 고객이라는 객체에 먹는 기능이 필요하다고 간주하지 않는다.

모든 기능은 객체의 속성값을 변경함으로써 객체의 상태를 바꿀 수 있다. 간단한 에를 들면 자동차 객체는 가속할 수 있다. 가속은 자동차 객체의 기능이며, 가속함으로써 자동차 객체의 속성 중 하나인 자동차의 속도가 변한다. 요약하자면 객체는 단순히 속성과 기능을 모은 그룹이다. 객체에 속성과 기능을 넣는 방법은 이후 절에서 더 설명하겠다.



## 6.2 C가 객체지향이 아닌 이유

C 는 객체지향이 아니지만, 오래되어서 그런 것은 아니다. C 가 오래된 언어여서 그렇다면 C를 객체지향으로 사용하는 법은 지금쯤 찾아냈을 것이다. C 프로그래밍 언어의 최신 표준인 C 18은 C를 객체지향 언어로 만들려고 하지는 않는다.

반면에 C++가 있다. C를 기반으로 하는 C++는 OOP언어를 갖기 위한 모든 노력의 산물이다. C가 객체지향 언어로 대체될 운명이었다면 C++ 떼문에 오늘날 C의 수요는 없었을 것이다. 하지만 C 엔지니어의 현재 수요를 보면 그렇지 않다.

인간은 객체지향적 방식으로 사고하지만 CPU는 절차지향적 기계 명령어를 실행한다. CPU는 명령어를 하나씩 실행할 뿐이고, 때로는 메모리의 다른 주소에서 다른 명령어로 넘어가거나, 다른 명령어를 가져오거나 실행해야 한다. 이는 C와 같은 절차지향적 프로그래밍 언어로 작성한 프로그램의 함수 호출과 꽤 비슷한다.

C는 객체지향 언어가 될 수 없다. 객체지향과 절차지향 프로그래밍 사이를 가르는 장벽에 위치하기 때문이다. 객체지향은 인간이 문제를 이해하는 방식이며 절차지향적 실행은 CPU가 할 수 있는 일이다. 그러므로 객체지향과 절차지향 사이에 놓일 무언가가 필요하다. 그렇지 않으면 객체지향적 방식으로 작성된 고수준의 프로그램은 CPU에 입력될 절차적 명령어로 바로 변환될 수 없다.

예를 들어 자바 플랫폼에서는 __자바가상머신__ 이 이 역할을 한다. 이러한 모든 환경은 반드시 객체지향적이지는 않지만, 고수준 로직을 저수준의 절차지향적 명령어로 변환하는 레이어가 필요하다.



## 6.3 캡슐화

앞 절에서 각각의 객체는 객체에 추가된 속성의 집합 및 기능의 집합이라고 알아봤다. 여기에서는 이 속성과 기능을 객체라는 개체에 넣는 작업을 설명하겠다. 이는 __캡슐화__ 라는 과정을 통해 수행한다.

캡슐화란 객체를 나타내는 __캡슐__ 에 서로 연관된 것을 집어넣는다는 의미이다. 이는 먼저 마음속에서 일어나는 일이고, 그다음 코드로 옮겨진다. 객체에 어떤 속성이나 기능이 필요하다고 느낀 순간, 마음속에서 캡슐화를 하는 것이다. 그리고 이러한 캡슐화는 코드 수준으로 옮겨야 한다.

프로그래밍 언어에서 무언가를 캡슐화할 수 있다는 건 매우 중요하다. 그렇지 않으면 서로 연관된 변수를 함께 두었을 때 해결하기 어려운 문제가 된다. (이를 해결하기 위해 명명 규칙을 언급한 바 있다).

객체는 속성의 집합 그리고 기능의 집합으로 만들어진다. 속성과 기능은 둘 다 객체 캡슐로 캡슐화되어야 한다. __속성 캡슐화__ 를 먼저 이야기해보자.



### 6.3.1 속성 캡슐화

앞서 살펴봤듯 캡슐화하려면 항상 변수명을 사용해야 하고, 서로 다른 변수를 묶어서 같은 객체 내에 그룹으로 두어야 한다. 

```c
// 두 픽셀을 나타내는 여러 변수를 이름으로 그루핑하기
int pixel_p1_x 		= 56;
int pixel_p1_y 		= 34;
int pixel_p1_red 	= 123;
int pixel_p1_green 	= 37;
int pixel_p1_blue 	= 127;
int pixel_p2_x 		= 212;
int pixel_p2_y 		= 994;
int pixel_p2_red 	= 127;
int pixel_p2_green 	= 127;
int pixel_p2_blue 	= 0;
```

이 예제는 __암묵적__ 객체인 p1과 p2 아래에서 변수를 그루핑할 떄 변수명을 어떻게 사용하는 지 명확히 보여준다. 암묵적이란, 개발자가 이 객체의 존재를 아는 유일한 사람이라는 뜻이다. 프로그래밍 언어는 이 객체에 대해 아무것도 모른다.

프로그래밍 언어는 서로 독립적인 것처럼 보이는 10개의  변수만을 이해한다. 이는 변수의 이름을 지정할 수 있으므로 공식적인 캡슐화로 여겨지지 않을 정도로 저수준의 캡슐화일 것이다. 변수 이름에 의한 캡슐화는 모든 프로그래밍 언어에 존재하며 심지어 어셈블리어에서도 가능하다.



필요한 것은 __명시적__ 캡슐화를 제공하는 접근법이다. 명시적이란, 개발자와 프로그래밍 언어 둘다 캡슐화, 캡슐의 존재를 안다는 의미이다. 명시적 __속성 캡슐화__ 를 제공하지 않는 프로그래밍 언어는 사용하기 매우 어렵다.

다행히 C는 명시적 캡슐화를 제공한다. 그러므로 c 언어를 이용해 본질적으로 객체지향적인 프로그램을 캡슐화로 쉽게 작성할 수 있다. 반면 다음 절에서 간단히 살펴보겠지만 C는 명시적 행위 캡슐화를 제공하지는 않으니 이를 지원하려면 암묵적인 방식을 생각해내야 한다.

참고로 프로그래밍 언어에서 캡슐화와 같이 명시적인 기능을 항상 사용하는 편이 좋다. 여기서는 캡슐화만 설명하지만, 명시적 기능은 상속이나 다형성같은 다른 객체지향적 기능으로 확장될 수 있다. 이러한 명시적 기능은 프로그래밍 언어가 런타임이 아닌 컴파일을 할 떄 관련 오류를 잡을 수 있도록 한다.

런타임 시 오류를 해결하는 일은 악몽과도 같다. 그래서 언제나 컴파일할 때 오류를 잡으려고 노력해야 한다. 런타임이 아니라 컴파일할 때 오류를 잡아낼 수 있다는 것은, 인간의 객체지향적 사고방식을 제대로 인지하는 객체지향적 언어의 주요 이점이다. 객체지향 언어는 컴파일하는 동안 설계상 오류나 위반 사항을 찾아내서 보고할 수 있다. 그러면 런타임 시 심각한 버그를 해결해야 하는 상황을 예방한다. 사실 이러한 이유로 프로그래밍 언어에 모든 것을 명시하려다 보니 요즘의 프로그래밍 언어는 더 복잡해졌다.

유감스럽게도 C에서 모든 객체지향적 기능이 명시적이지는 않는다. 근본적으로 이런 이유로 C 에서 객체지향적인 프로그램을 작성하기가 어렵다. 하지만 C++ 에는 명시적 기능이 더 많으므로 C++을 객체지향적 프로그래밍 언어라고 한다.

C에서는 구조체가 캡슐화를 제공한다.

```c
typedef struct {
    int x, y;
    int red, green, blue;
} pixel_t;
pixel_t p1, p2;

p1.x 		= 56;
p1.y 		= 34;
p1.red 		= 123;
p1.green 	= 37;
p1.blue 	= 127;

p2.x 		= 212;
p2.y 		= 994;
p2.red 		= 127;
p2.green 	= 127;
p2.blue 	= 0;

```



- 속성 캡슐화는 x, y, red, green, blue 속성을 새 자료형인 pixel_t 로 넣을 때 발생한다.
- 캡슐화는 언제나 새로운 자료형을 만든다. 특히 C에서 속성 캡슐화로 새로운 자료형을 만든다는 것은 꼭 알아두어야 한다. 실제로 이런 방식으로 명시적인 캡슐화를 수행한다. `_t` 접미어가 pixel_t 의 끝에 붙으니 주의하자. C에서 `_t` 접미어를 새 자료형 뒤에 붙이는 일은 아주 흔하지만, 문법상 의무는 아니다.
- p1과 p2 는 코드가 실행될 때 명시적 객체가 된다. 둘 다 pixel_t 자료형이고, 구조체가 명시하는 유일한 속성이다. C 그리고 특히 C++ 에서 자료형은 객체의 속성을 명시한다.
- 새 자료형인 pixel_t 는 클래스의 유일한 속성이다. 클래스라는 단어는 속성과 기능을 둘 다 포함하는 객체의 템플릿을 나타낸다는 점을 기억하자. C의 구조체는 속성만 가지므로 구조체는 클래스의 대응물이 아니다. 유감스럽게도 C에는 클래스에 대응하는 개념이 없다. 속성과 기능이 따로따로 존재하고, 우리는 이 둘을 암묵적으로 코드에 연관시킨다. 모든 클래스는 C에서 암묵적이며, 모든 클래스는 C 의 함수 목록을 갖는 하나의 구조체에 해당한다.
- 템플릿에 기반한 객체를 생성했으며 이 템플릿은 객체가 생성될 때 미리 결정된 속성을 갖는다.
- 객체 생성은 새 변수의 선언과 매우 유사하다. 자료형이 앞에 오고, 그다음 변수이름이 나온다. 객체를 선언하는 동안 동시에 두 가지 일이 발생한다. 먼저 객체에 메모리가 할당된다. (creation) 그러고 나서 속성은 기본값을 사용해 초기화된다. (construction)



### 6.3.2 행위 캡슐화

객체란 간단히 말해 속성과 메서드의 캡슐이다. 메서드는 객체 내에 저장되는 로직 또는 기능을 나타내고자 사용하는 표준 용어이다. 메서드는 C의 함수로 간주할 수 있으며, 이름, 인자의 목록, 반환형을 갖는다. 속성은 값을 전달하며 메서드는 행위를 전달한다. 그러므로 객체는 값의 목록을 갖고 시스템에서 어떤 행위를 수행할 수 있다.

C++ 같은 클래스 기반의 객체지향언어에서는 속성과 메서드를 아주 쉽게 클래스에 함께 묶을 수 있다. 자바스크립트 같은 프로토타입 기반 언어에서는 보통 빈 객체 를 사용하거나 빈 객체를 복제해서 시작한다. 객체가 행위를 가지려면 메서드를 추가해야한다. 

```javascript
// 빈 객체 생성
var clientObj = {};

// 속성 설정
clientObj.name = "john";
clientObj.surname = "Doe";

// 은행 계좌를 주문하는 메서드 추가
clientObj.orderBankAccount = function () {
    ...
}
...

// 메서드 호출
clientObj,orderBankAccount();
```

예제에서는 두 번째 행에서 빈 객체를 만들었다. 다음 두 행에서는 name 과 surname 이라는 새로운 속성 두 가지를 객체에 추가했다. 그 다음 행에는 orderBankAccount 메서드를 새로 추가했고 이는 함수의 정의를 가리킨다. 이 행은 실제로 할당에 해당한다. 오른쪽에는 익명함수가 있는데, 익명함수는 이름을 갖지 않으며 왼쪽에 있는 객체에 orderBankAccount 속성을 할당한다. 즉, 함수에 orderBankAccount 속성을 저장한다. 마지막 행에는 객체는 메서드인 orderBankAcocunt 가 호출된다. 이는 처음에 빈 객체만 있으면 되고, 더 이상은 필요치 않은 프로토타입 기반 프로그래밍 언어를 시연하는 좋은 예제이다.

클래스 기반의 프로그래밍 언어에서는 앞의 예제 내용이 달라진다. 클래스 기반의 언어에서는 먼저 클래스를 작성해야 하는데, 클래스가 없다면 어떤 객체도 가질 수 없기 때문이다.



```c++
class Client {
    public:
    	void orderBankAccount() {
            ...
        }
    	std::string name;
    	std::string surname;
};
...
Client clientObj;
client.name = "john"
client.surname = "doe"
...
ClientObj.orderBankAccount ();
        
```

어떤 항목을 캡슐화하기 위해 오픈 소스나 유명 C 프로젝트가 사용하는 기법을 살펴보면 공통주제를 발견할 수 있다. 이번 절의 나머지 부분에는 이러한 프로젝트에서 볼 수 있는 것과 유사한 기법을 기반으로 행위 캡슐화 기법을 소개한다.

이 기법을 자주 언급할 것이므로 __암묵적 캡슐화__ 이라고 부르겠다. C가 알고 있는 명시적인 행위 캡슐화를 제공하지 않으므로 암묵적이라고 한다. ANSI C 표준에서 지금까지 이해한 내용을 토대로 하면, C는 클래스를 알 수없다. 그러므로 C에서 객체지향을 다루려는 모든 기법은 암묵적이어야 한다.

- 객체의 속성을 저장하기 위해 C의 구조체를 이용한다. (명시적 속성 캡슐화). 이 구조체는 __속성 구조체__  라고 한다.
- 행위 캡슐화를 위해 C 의 함수가 사용된다. 이 함수는 __행위 함수__ 라고 한다. 알다시피 C의 구조체는 함수를 가질 수 없다. 그러므로 이 함수는 속성 구조체 바깥에 존재해야 한다.(암묵적 행위 캡슐화)
- 행위 함수는 인자 중 하나로 반드시 구조체 포인터를 받아야 한다. (주로 첫번 째 인자 또는 마지막 인자) 이 포인터는 객체의 속성 구조체를 가리킨다. 행위 함수는 일반적으로 객체의 속성을 얽거나 수정해야 하기 때문이다.
- 행위 함수가 객체의 동일한 클래스에 서로 연관되었음을 나타내려면 적절한 이름이 있어야 한다. 그러므로 암묵적 캡슐화 기법을 사용할 때 꼭 명명 규칙을 일관적으로 지켜야 한다. 행위 함수에 이름이 있어야 한다는 것은 정확한 캡슐화를 위해 이번 장에서 따라야 하는 두 가지 명명 규칙 중 하나이다. 다른 규칙은 속성 구조체의 이름의 끝에 _t 접미사를 사용하는 것이다.
- 일반적으로 속성 구조체의 선언이 있는 헤더 파일에서 행위 함수에 대해 선언한다. 이 헤더파일은 __선언 헤더__ 이라고 한다.
- 일반적으로 선언 헤더를 포함하는 하나 또는 여러 별도의 소스 파일에서 행위 함수를 정의한다.



암묵적 캡슐화에는 클래스가 존재하지만 암묵적이며 개발자만 클래스를 알고 있다는 점을 명심하자. C 프로그램에서 암묵적 캡슐화 기법을 사용하는 방법을 이용한 예제를 보자.

예제에서 헤더파일은 새로운 자료형 car_t 선언을 포함한다. 이 자료형은 Car 클래스의 속성 구조체이다. 헤더는 또한 Car 클래스의 행위 함수에 필요한 선언도 포함하다. C 코드에는 없는 암묵적 클래스를 나타내고자 Car 클래스라는 표현을 사용하며, Car 클래스는 속성 구조체와 행위 함수를 모두 포함한다.



```c
// car_header.h
# ifndef CAR_HEADER_H
# define CAR_HEADER_H

// 이 구조체는 자동차 객체에 연관된 모든 속성을 갖는다.
typedef struct {
    char name[32];
    double speed;
    double fuel;
} car_t;

// 이 함수 선언은 자동차 객체의 행위에 해당한다.
void car_construct(car_t*, const char*);
void car_destruct(car_t*);
void car_accelerate(car_t*);
void car_brake(car_t*);
void car_refuel(car_t*, double);

# endif
```

속성 구조체 car_t 는 name, speed, fuel 이라는 3개의 필드를 갖는다. 이 필드는 car 객체의 속성이다. car_t 는 C에서 새로운 자료형이며, 이제 이 잘료형의 변수를 선언할 수 있으니 참고하자. 앞의 코드 박스에서 행위 함수는 또한 같은 헤더 파일에서 선언해야 한다. 행위 함수는 car_t 접두어로 시작하는데, 모든 함수가 같은 클래스에 속함을 강조하기 위해서이다.

암묵적 캡슐화 기법에 관한 아주 중요한 사항이 있다. 각각의 객체는 자신만의 고유한 속성 구조체 변수를 갖는다. 하지만 모든 객체는 같은 행위 함수를 공유한다. 즉 각각의 객체의 속성 구조체 자료형에서는 지정된 변수를 만들어야 하지만, 행위 함수는 단 한번 작성해 서로 다른 객체에서 호출한다.

다음 소스 파일은 위 예제의 행위 함수에 관한 정의를 포함한다.

```c
// car.c
# include <string.h>

# include "car_header.h"

void car_construct(car_t* car, const char* name) {
    strcpy(car->name, name);
    car->speed = 0.0;
    car->fuel = 0.0;
}

void car_destruct(car_t* car) {
    // ...
}

void car_accelerate(car_t* car) {
    car->speed += 0.05;
    car->fuel -= 1.0;
    if (car->fuel < 0.0) {
        car->fuel = 0.0;
    }
}

void car_brake(car_t* car) {
    car->speed -= 0.07;
    if (car->speed < 0.0) {
        car->speed = 0.0;
    }
    car->fuel -= 2.0;
    if (car->fuel < 0.0) {
        car->fuel = 0.0;
    }
}

void car_refuel(car_t* car, double amount) {
    car->fuel = amount;
}
```

Car 의 행위 함수는 car.c 에 정의되어 있다. 모든 함수는 car_t 포인터를 첫 번째 인자로 받는다. 이로써 함수가 객체의 속성을 읽고 수정하도록 한다. 만약 함수가 속성 구조체에 대한 포인터를 받지 못한다면, 객체의 행위를 나타내지 못하는 평범한 C 함수로 간주해야 한다.

일반적으로 행위 함수의 선언은 함수에 대응하는 속성 구조체의 선언에 이어서 시행한다는 점을 기억하자. 속성 구조체와 행위 함수의 연관성을 관리하는 유일한 담당자가 개발자이고, 유지보수가 매우 쉬워야 하기 때문이다. 이런 이유로 속성 구조체와 행위 함수의 집합을 서로 가까이 대개는 같은 헤더 파일에 두면, 클래스의 전반적인 구조를 유지하는 데 도움이 되고 나중에 들여야 할 수고를 덜어준다.



```c
// main.c
# include <stdio.h>

# include "car_header.h"

int main(int argc, char** argv) {
    car_t car;
    car_construct(&car, "Renault");
    
    car_refuel(&car, 100.0);
    printf("Car is refueled, the correct fuel level is %f\n", car.fuel);
    while(car.fuel > 0) {
        printf("Car fuel level: %f\n", car.fuel);
        if (car.speed < 80) {
            car_accelerate(&car);
            printf("Car has been accelerated to the speed: %f\n", car.speed);
        } else {
            car_brake(&car);
            printf("Car has been slowed down to the speed: %f\n", car.speed);
        }
    }
    
    printf("Car ran out of the fuel! Slowing down ...\n");
    while (car.speed > 0) {
        car_brage(&car);
        printf("Car has been slowed down to the speed: %f\n", car.speed);
    }
    
    // 객체 소멸
    car_destruct(&car);
    
    
    return 0;
}
```













