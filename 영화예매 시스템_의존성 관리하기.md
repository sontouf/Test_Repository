# 의존성 관리하기

## 변경과 의존성

어떤 객체가 협력하기 위해 다른 객체를 필요로 할 때 두 객체 사이에 의존성이 존재하게 된다. 의존성은 실행 시점과 구현 시점에 서로 다른 의미를 가진다.

- 실행 시점 : 의존하는 객체가 정상적으로 동작하기 위해서는 실행 시에 의존 대상 객체가 반드시 존재해야 한다.
- 구현 시점 : 의존 대상 객체가 변경될 경우 의존하는 객체도 함께 변경된다.



PeriodCondition 클래스의 isSatisfiedBy 메서드는 Screening 인스턴스에게 getStartTime 메시지를 전송한다.

```java
public class PeriodConditon implements DiscountCondition {
    private DayOfWeek dayOfWeek;
    private LocalTime startTime;
    private LocalTime endTime;
    
    ...
        
    public boolean isSatisfiedBy(Screening screening) {
        return screening.getStartTime().getDayOfWeek().equals(dayOfWeek) && 
            startTime.compareTo(screening.getStartTime().toLocalTime()) <= 0 &&
            endTime.compareTo(screening.getStartTime().toLocalTime()) >= 0;
    }
}
```

실행 시점에 PeriodCondition 의 인스턴스가 정상적으로 동작하기 위해서는 Screening 의 인스턴스가 존재해야 한다. 만약 Screening 의 인스턴스가 존재하지 않거나 getStartTime 메시지를 이해할 수 없다면 PeriodCondition 의 isSatisfiedBy 메서드는 예상했던 대로 동작하지 않을 것이다.

 이처럼 어떤 객체가 예정된 작업을 정상적으로 수행하기 위해 다른 객체를 필요로 하는 경우 두 객체 사이에 의존성이 존재한다고 말한다. 의존성은 방향성을 가지며 항상 단방향이다. Screening 이 변경될 때 PeriodCondition 이 영향을 받게 되지만 그 역은 성립하지 않는다. 이 경우 PeriodCondition 은 Screening 에 의존한다.



## 런타임 의존성과 컴파일타임 의존성

런타임은 애플리케이션이 실행되는 시점을 가리킨다. 컴파일타임은 약간 미묘하다. 일반적으로 컴파일타임이란 작성된 코드를 컴파일하는 시점을 가리키지만 문맥에 따라서는 코드 그 자체를 가리키기도 한다. 컴파일타임 의존성이 바로 이런 경우에 해당한다. 컴파일타임 의존성이라는 용어가 중요하게 생각하는 것은 시간이 아니라 우리가 작성한 코드의 구조이기 떄문이다. 또한 동적 타입 언어의 경우에는 컴파일타임이 존재하지 않기 때문에 컴파일타임 의존성이라는 용어를 실제로 컴파일이 수행되는 시점으로 이해하면 의미가 모호해질 수 있다. 따라서 어딘가에서 컴파일타임이라는 용어를 보게 된다면 그것이 정말 컴파일이 진행되는 시점을 가리키는 것인지 아니면 코드를 작성하는 시점을 가리키는 것인지를 파악하는 것이 중요하다.

 객체지향 애플리케이션에서 런타임의 주인공은 객체다. 따라서 런타임 의존성이 다루는 주제는 객체 사이의 의존성이다. 반면 코드 관점에서 주인공은 클래스다. 따라서 컴파일타임 의존성이 다루는 주제는 클래스 사이의 의존성이다.

여기서 중요한 것은 런타임 의존성과 컴파일타임 의존성이 다를 수 있다는 것이다. 사실 유연하고 재사용 가능한 코드를 설계하기 위해서는 두 종류의 의존성을 서로 다르게 만들어야 한다.



영화 예매 시스템을 예로 들어 살펴보자. Movie 는 가격을 계산하기 위해 비율 할인 정책과 금액 할인 정책 모두를 적용할 수 있게 설계해야 한다. 다시 말해서 Movei는 AmountDiscountPolicy 와 PercentDiscountPolicy 모두와 협력할 수 있어야 한다. 이를 위해 AmountDiscountPolicy 와 PercentDiscountPolicy 가 추상 클래스인 DiscountPolicy 를 상속받게 한 후 Movie 가 이 추상 클래스에 의존하도록 클래스 관계를 설계했다.



여기서 중요한 것은 Movie 클래스에서 AmountDiscountPolicy 클래스와 PercentDisocuntPolicy 클래스로 향하는 어떤 의존성도 존재하지 않는다는 것이다.  Movie 클래스는 오직 추상 클래스인 DiscountPolicy 클래스에만 의존한다. Movie 클래스의 코드를 살펴보면 AmountDiscountPolicy  나 PercentDiscountPolicy 에 대해서는 언급조차 하지 않는다는 것을 알 수 있다.

```java
public class Movie {
    ...
    private DiscountPolicy discountPolicy;
    
    public Movie(String title, Duration runningTime, Money fee, DiscountPolicy discountPolicy) {
        ...
        this.discountPolicy = discountPolicy;
    }
    
    public Money calculateMovieFee(Screening screening) {
        return fee.minus(discountPolicy.calculateDiscountAmount(Screening));
    }
}
```



어떤 클래스의 인스턴스가 다양한 클래스의 인스턴스와 협력하기 위해서는 협력할 인스턴스의 구체적인 클래스를 알아서는 안된다. 실제로 협력할 객체가 어떤 것인지는 런타임에 해결해야 한다. 클래스가 협력할 객체의 클래스를 명시적으로 드러내고 있다면 다른 클래스의 인스턴스와 협력할 가능성 자체가 없어진다. 따라서 컴파일타임 구조와 런타임 구조 사이의 거리가 멀면 멀수록 설계가 유연해지고 재사용 가능해진다.



## 의존성 해결하기

컴파일 의존성은 구체적인 런타임 의존성으로 대체돼야 한다. Movie 클래스는 DiscountPolicy 클래스에 의존한다. 이것은 컴파일타임 의존성이다. Movie 인스턴스는 PercentDiscountPolicy 인스턴스나 AmountDiscountPolicy 인스턴스 중 하나에 의존한다. 이것은 Movie 클래스와 DiscountPolicy  클래스 사이에 존재하는 컴파일타임 의존성이 movie 인스턴스와 PercentDiscountPolicy 인스턴스 사이의 런타임 의존성이나 Movie 인스턴스와 AmountDiscountPolicy 인스턴스 사이의 런타임 의존성으로 교체돼야 한다는 것을 의미한다.

이처럼 컴파일타임 의존성을 실행 컨텍스트에 맞는 적절한 런타임 의존성으로 교체하는 것을 __의존성 해결__ 이라고 부른다. 의존성을 해결하기 위해서는 일반적으로 다음과 같은 세 가지 방법을 사용한다.

- 객체를 생성하는 시점에 생성자를 통해 의존성 해결
- 객체 생성 후 setter 메서드를 통해 의존성 해결
- 메서드 실행 시 인자를 이용해 의존성 해결



예를 들어, 어떤 영화의 요금 계산에 금액 할인 정책을 사용하고 싶다고 가정하자. 다음과 같이 Movie 객체를 생성할 때 AmountDiscountPolicy 의 인스턴스를 Movie의 생성자에 인자로 전달하면 된다.

```java
Movie avatar = new Movei("아바타", Duration.ofMinutes(120),Money.wons(10000),new AmountDiscountPolicy(...));
```

Movie 생성자에 PercentDiscountPolicy 의 인스턴스를 전달하면 비율 할인 정책에 따라 요금을 계산하게 될 것이다.

이를 위해 Movie 클래스는 PercentDiscountPolicy 인스턴스와 AmountDiscountPolicy 인스턴스 모두를 선택적으로 전달받을 수 있도록 이 두 클래스의 부모 클래스인 DiscountPolicy 타입의 인자를 받는 생성자를 정의한다.

```java
public class Movie {
    public Moive (String title, Duration runningTime, Money fee, DiscountPolicy discountPolicy) {
        ...
        this.discountPolicy = discountPolicy;
    }
}
```





Moive 의 인스턴스를 생성한 후에 메서드를 이용해 의존성을 해결하는 방법도 있다.

```java
Movie avatar = new Movie(...);
avatar.setDiscountPolicy(new AmountDiscountPolicy(...));
```

이 경우 Movie 인스턴스가 생성된 후에도 DiscountPolicy 를 설정할 수 있는 setter 메서드를 제공해야 한다.

```java
public class Movie {
    public void setDiscountPolicy (DiscountPolicy discountPolicy) {
        this.discountPolicy = discountPolicy;
    }
}
```

setter 메서드를 이용하는 방식은 객체를 생성한 이후에도 의존하고 있는 대상을 변경할 수 이쓴ㄴ 가능성을 열어 놓고 싶은 경우에 유용하다. 예를 들어, 다음과 같이 setter 메서드를 이용하면 금액 할인 정책으로 설정된 Movie 의 인스턴스를 중간에 비율 할인 정책으로 변경할 수 있다.

```java
Movie avatar = new Movie(...);
avatar.setDiscountPolicy(new AmountDiscountPolicy(...));
...
avatar.setDiscountPolicy(new PercentDiscountPolicy(...));
```

setter 메서드를 이용하는 방법은 실행 시점에 의존 대상을 변경할 수 있기 떄문에 설계를 좀 더 유연하게 만들 수 있다. 단점은 객체가 생성된 후에 협력에 필요한 의존 대상을 설정하기 때문에 개겣를 생성하고 의존 대상을 설정하기 전까지는 객체의 상태가 불완전할 수 있다.

```java
Movie avatar = new Movie(...);
avatar.calculateFee(...); // NullPointerException 예외 발생
avatar.setDiscountPolicy(new AmountDiscountPolicy(...));
```



더 좋은 방법은 생성자 방식과 setter 방식을 혼합하는 것이다. 항상 객체를 생성할 때 의존성을 해결해서 완전한 상태의 객체를 생성한 후, 필요에 따라 setter 메서드를 이용해 의존 대상을 변경할 수 있게 할 수 있다.

```java
Movie avatar = new Movie(..., new PercentDiscountPolicy(...));
...
avatar.setDiscountPolicy(new AmountDiscountPolicy(...));
```

Movie 가 항상 할인 정책을 알 필요까지는 없고 가격을 계산할 때만 일시적으로 알아도 무방하다면 메서드의 인자를 이용해 의존성을 해결할 수도 있다.

```java
public class Movie {
    public Money calculateMovieFee(Screening screening, DiscountPolicy discountPolicy) {
        return fee.minus(discountPolicy.calculateDiscountAmount(screening));
    }
}
```



메서드 인자를 사용하는 방식은 협력 대상에 대해 지속적으로 의존 관계를 맺을 필요 없이 메서드가 실행되는 동안만 일시적으로 의존 관계가 존재해도 무방하거나, 메서드가 실행될 때마다 의존 대상이 매번 달라져야 하는 경우에 유용하다. 하지만 클래스의 메서드를 호출하는 대부분의 경우에 매번 동일한 객체를 인자로 전달하고 있다면 생성자를 이용하는 방식이나 setter 메서드를 이용해 의존성을 지속적으로 유지하는 방식으로 변경하는 것이 좋다.



p264









