# Chapter 1 필수요소

## 1.1 전처리기 지시자

전처리`preprocessing` 는 C의 강력한 구성요소이다.

일단은 컴파일러로 보내기 전에 소스코드를 만들고 수정할 수 있도록 하는 과정을 `전처리`라고 하자.

다른 프로그래밍 언어는 컴파일러로 소스코드가 바로 전달되지만 c와 C++ 같은 언어는 먼저 전처리를 해야 한다.

	전처리라는 추가 단계는 컴파일러로 소스코드를 보내기 전 C 개발자가 효과적으로 소스코드를 바꿀 수 있다는 점에서 C를 독특한 프로그래밍 언어로 만들었다. 전처리요소는 대부분의 고급 프로그래밍 언어에서는 존재하지 않는다.

```
전처리의 목적은 전처리 지시자를 제거하고 이 지시자를 C 코드에 의해 생성된 동일한 내용으로 바꾸는 것이다.또한 컴파일러로 보낼 준비가 된 최종 소스 파일을 준비하려는 목적도 있다.
```

 전처리 수행은 일련의 `지시자`를 사용해서 관리되는데 헤더와 소스 파일 모두에서 # 문자로 시작하는 코드이다. 이코드는 C 전처리기에만 의미가 있을 뿐  C 컴파일러에는 의미가 없다.



### 1.1.1매크로

매크로는 다음과 같이 다양하게 활용할 수 있다.

```
- 상수 정의하기
- C 함수를 작성하지 않고 함수로 사용하기
- 루프 풀기 loop unrolling
- 헤더 가드 header guard
- 코드 생성
- 조건부 컴파일
```

#### 매크로 정의하기

매크로는 `#define` 지시자를 이용해 정의한다. 각 매크로는 이름과 사용 가능한 매개변수 리스트를 갖는다. 또한 값을 가지며, 이 값은 `매크로 확장`이라는 단계를 통해 전처리 단계에서 매크로의 이름으로 대체될 수 있다. 매크로는 `#undef` 지시자로 매크로의 정의를 제거할 수 있다. 

```c
// 매크로 정의하기
#define ABC 5

int main(int argc, char** argv)
{
    int x = 2;
    int y = ABC; 
    int z = x + y;
    return 0;
}
```

ABC는 정숫값이나 정수 상수를 담는 변수가 아니다. 이는 ABC라는 매크로이며 해당하는 값은 5이다. 매크로 확장 단계 이후 C 컴파일러로 보낸 코드의 결과물은 다음과 같다.

```C
int main(int argc, char **argv)
{
    int x = 2;
    int y = 5;
    int z = x + y;
    return 0;
}
```

앞의 예제에서 전처리기는 매크로 확장을 수행해서 매크로의 이름을 값으로 간단히 바꾸었다. 또한 시작하는 줄의 #define 부분도 삭제됐다.

	또 다른 예제를 보자

```c
#define ADD(a, b) a + b

int main(int argc, char **argv)
{
    int x = 2;
    int y = 3;
    int z = ADD(x, y);
    return 0;
}
```

이 코드에서 ADD 는 함수가 아니다. 이는 인수를 받는 `유사 함수 매크로 function-like macro`이다. 전처리 이후의 코드는 다음과 같다.

```c
int main(int argc, char **argv)
{
    int x = 2;
    int y = 3;
    int z = x + y;
    return 0;
}
```

위에서 볼 수 있듯이 매크로 확장이 이루어지는 방식은 다음과 같다. 매개변수 a로 사용된 인수 x 는 매크로 값에 있는 a 의 인스턴스로 모두 바뀌었다. 매개변수 b도 마찬가지이며 b에 해당하는 y 인수에서도 그렇다. 모두 변환된 이후 전처리된 코드에서는 ADD(a, b) 대신 x + y를 얻는다.

	유사함수매크로는 입력 인수를 받을 수 있기 때문에 C 함수를 모방할 수 있다. 즉, 자주 사용되는 로직을 C 함수에 넣는 것  대신, 이 로직을 유사함수매크로로 명명해 사용할 수 있다.



`매크로는 컴파일 단계 이전에만 존재한다. 즉, 컴파일러가 이론적으로는 매크로에 관해 아무것도 모른다는 의미이다.` 컴파일러는 함수의 모든 것을 알고 있다. 함수는 C 문법의 일부이며 파스 트리`parse tree`내에서 함수가 분석되기 때문이다. 그러나 매크로는 전처리기 자체에 관해서만 알고 있는, C의 전처리기 지시자에 불과하다.

 	사실 현대의 컴파일러는 C 전처리기 지시자를 인지하고 있다.  참고로 대부분의 현대 컴파일러는 컴파일 직전에 전처리 결과를 볼 수 있다. 예를 들어 gcc 나 clang 을 사용할 경우 전처리 이후 코드를 덤프`dump` 하기 위해 `-E`옵션을 사용할 수 있다. 
 	
 	`변환단위 translation unit (혹은 컴파일 단위 compilation unit)`는 컴파일러로 전달될 준비가 된, 전처리된 C 코드이다. 변환 단위에서는 모든 지시자가 포함되거나 매크로 확장으로 대체되며 단 한 줄의 긴 C코드가 만들어진다.

```c
#include <stdio.h>

#define PRINT(a) printf("%d\n", a);
#define LOOP(v, s, e) for(int v = s; v <= e; v++) {
#define ENDLOOP }

int main(int argc, char **argv) {
    LOOP(counter, 1, 10)
        PRINT(counter)
    ENDLOOP
    return 0;
}
```

```c
...
... content of stdio.h ...
...
int main(int argc, char **argv)
{
    for(int counter = 1; counter <= 10; counter++) {
        printf("%d\n", counter);
    }
	return 0;
}
```

 전처리 이후 위 코드는 잘 작동되는 올바른 프로그램이다. 이는 `도메인 특화 언어 domain specific language (DSL)`를 정의하고 DSL을 이용해 코드를 작성하는 매크로의 중요한 활용법이다.

최종 전처리된 코드에는 C 지시자가 전혀 없다는 사실을 눈여겨봐야 한다. 이는 #include 지시자가 자신이 가리키는 파일의 내용으로 대체되엇다는 뜻이다.



	다음은 매크로 매개변수에 관한 새로운 두 가지 연산를 소개한다. # 과 ## 연산자이다.

```c
#include <stdio.h>
#include <string.h>

#define CMD(NAME) \
	char NAME ## _cmd[256] = ""; \
	strcpy(NAME ## _cmd, #NAME);

int main(int argc, char **argv) {
    
    CMD(copy)
    CMD(paste)
    CMD(cut)
        
    char cmd[256];
    scanf("%s", cmd);
    
    if (strcmp(cmd, copy_cmd) == 0) {
        // ...
    }
    if (strcmp(cmd, paste_cmd) == 0) {
        // ...
    }
    if (strcmp(cmd, cut_cmd) == 0) {
        // ...
    }
    return 0;
}
```

매크로를 확장할 때 `#` 연산자는 매개변수를 한 쌍의 따옴표로 둘러싼 문자 형태로 변환한다. 예를 들어 앞의 코드에서 NAME 매개변수 앞에 쓰인 # 연산자는 전처리된 코드에서 NAME 을 "copy"로 변환한다.

`##` 연산자는 다른 의미가 있다. 이 연산자는 매크로 정의에서 매개변수와 다른 요소를 문자열로 결합해 변수이름을 만든다.

```c
#define CMD(NAME) \
	char NAME ## _cmd[256] = ""; \
	strcpy(NAME ## _cmd, #NAME);

int main(int argc, char **argv) {
    
    char copy_cmd[256] = ""; strcpy(copy_cmd, "copy");
    char paste_cmd[256] = ""; strcpy(paste_cmd, "paste");
    char cut_cmd[256] = ""; strcpy(cut_cmd, "cut");        
    char cmd[256];
    scanf("%s", cmd);
    if (strcmp(cmd, copy_cmd) == 0) {
        // ...
    }
    if (strcmp(cmd, paste_cmd) == 0) {
        // ...
    }
    if (strcmp(cmd, cut_cmd) == 0) {
        // ...
    }
    return 0;
}
```

전처리된 최종 코드에서 같은 매크로 정의로부터 확장된 모든 행은 같은 행에 위치한다.

다음 절은 `가변 인자 매크로 variable macro`에 관한 것으로 가변 인자 매크로는 가변 인수를 받을 수 있다.

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define VERSION "2.3.4"

#define LOG_ERROR(format, ...) \
	fprintf(stderr, format, __VA_ARGS__)

int main(int argc, char **argv)
{
    if (argc < 3)
    	LOG_ERROR("Invalid number of arguments for version %s\n.", VERSION);
    	exit(1);
	}
    if (strcmp(argv[1], "-n") != 0) {
        LOG_ERROR("%s is a wrong param at index %d for version %s.", \
                  argv[1], 1, VERSION);
        exit(1);
    }
    // ...
    return 0;
}
```

 이 코드 박스에 새로운 식별자인 `__VA_ARGS__`가 보인다. 이 식별자는 아직 매개변수에 할당되지 않은 나머지 입력 인수로 모두 교체하도록 전처리기로 지시한다.

추가로 `fprinf` 함수는 __파일서술자__ 를 작성한다. 위 상황에서 파일 서술자는 `stderr`이며, 이는 프로세스의 오류 스트림이다.

```c
...
... content of stdio.h ...
...
...
... content of stdlib.h ...
...
...
... content of string.h ...
...
int main(int argc, char **argv)
{
    if (argc < 3)
        fprintf(stderr, "Invalid number of arguments for version %s\n.", "2.3.4")
    	exit(1);
	}
    if (strcmp(argv[1], "-n") != 0) {
        fprintf(stderr, "%s is a wrong param at index %d for version %s.",\
                argv[1], 1, "2.3.4");
        exit(1);
    }
    // ...
    return 0;
}
```

 루프를 모방한 가변 인자 매크로 예제를 보자

```c
#include <stdio.h>

#define LOOP_3(X, ...) printf("%s\n", #X);
#define LOOP_2(X, ...) printf("%s\n", #X); LOOP_3(__VA_ARGS__)
#define LOOP_1(X, ...) printf("%s\n", #X); LOOP_2(__VA_ARGS__)
#define LOOP(X, ...) printf("%s\n", #X); LOOP_1(__VA_ARGS__)

int main(int argc, char** argv)
{
    LOOP(copy paste cut)
    LOOP(copy, paste, cut)
    LOOP(copy, paste, cut, select)
        
    return 0;
}
```

```c
...
... content of stdio.h ...
...
int main(int argc, char** argv)
{
    printf("%s\n", copy paste cut); printf("%s\n", ""); printf("%s\n", "");
    printf("%s\n", "copy"); printf("%s\n", "paste"); printf("%s\n", "cut");
    printf("%s\n", "copy"); printf("%s\n", "paste"); printf("%s\n", "cut");
        
    return 0;
}
```

 전처리된 코드를 주의 깊게 살펴보면, LOOP 매크로가 for나 while 같은 루프 명령어 대신 여러 개의 printf 지시어로 확장되엇다는 것을 알 수 있다. 이는 확실히 전처리기가 c 코드를 똑똑하게 작성하지 않았기 때문이다. 최종 코드에는 어떠한 c 루프도 존재하지 않게 된다. 이러한 방식은 이진 파일 크기가 커지므로 단점이라고 볼 수 있지만, 명령어를 루프에 넣지 않고 하나하나 두는 것은 `루프풀기`라고도 알려져 있다. 루프 풀기는 제한된 환경에서 고성능을 요하는 경우에 나름의 용도가 있다.

#### 매크로의 장점과 단점

매크로를 남발하더라도 우리에게는 큰 문제가 되지 않지만 동료에게는 문제가 될 수 있다. 매크로에는 중요한 특성이 있다. 매크로에 무언가를 작성할 경우, 매크로에 쓰인 것은 컴파일 단계 이전에 다른 코드로 교체 된다. 그리고 컴파일을 거치고 나면 모듈성을 전혀 갖지 않는, 단 한 줄로 긴 코드를 얻게 된다. 모듈성을 고려해서 매크로에 썼겠지만, 최종 이진 파일에는 존재하지 않게 된다. 이 부분이 바로 매크로 사용 시 설계 문제가 생기는 지점이다.

 하지만 매크로는 모든 것을 한 줄로 만들어버린다. 그러니 소프트웨어 설계 시 로직의 구성 요소로 매크로를 사용하게 되면, 최종 변환 단위의 일환인 전처리 단계 이후에 매크로와 관련된 정보를 잃어버릴 수 있다. 따라서 소프트웨어 아키텍트와 디자이너가 매크로에 관해서는 경험에 기반한 결정을 해야한다.

```
만약 매크로가 c 함수로 사용될 수 있다면, 매크로 대신에 c 함수로 반드시 작성해야 한다.
```

디버깅 관점에서도 매크로는 사악하다고 평가된다. 문법 오류가 발생한 곳을 찾기 위해 일상적으로 컴파일 오류를 이용하지만 이전의 c 컴파일러의 경우에서는 매크로를 알지 못해 개발자는 컴파일러가 보고하는 내용을 쉽게 이해할 수 없었다.

 다행히 오늘날의 c 컴파일러 덕분에 이 문제는 더 이상 심각한 이슈가 아니다.

### 1.1.2 조건부 컴파일

`조건부 컴파일 conditional copilation`은 c의 또 다른 고유한 특성이다. 조건부 컴파일을 거치면 서로 다른 조건에 기반해 서로 다른 전처리된 소스 코드를 갖게 된다. 비록 조건부라는 이름이 붙기는 하지만, 컴ㅂ파일러는 조건적으로 무언가를 하지 않는다.

`#ifdef #ifndef #else #elif #endif`

```C
// 조건부 컴파일 예
#define CONDITION

int main(int argc, char** argv)
{
#ifdef CONDITION
    int i = 0;
    i++;
#endif
    int j = 0;
    return 0;
}
```

CONDITION 매크로가 이미 정의되었으므로 #ifdef와 #endif 사이의 모든 줄은 최종 소스 코드에 복제된다.

```c
// 위 소스코드의 전처리 단계 이후
int main(int argc, char** argv)
{
    int i = 0;
    i++;
    
    int j = 0;
    return 0;
}
```

만약 매크로가 정의되지 않았다면 #ifdef와 #endif  지시자는 교체되지 않는다는 것을 알 수 있다. 

```c
// 위 소스코드의 전처리 단계 이후 (매크로가 정의되지 않았다면)
int main(int argc, char** argv)
{

    
    int j = 0;
    return 0;
}
```

 빈 줄이 남아있음을 유의하자

``` 
매크로는 컴파일 명령어에 전달되는 -D 옵션을 사용해 정의될 수 있다. 이는 소스 코드 바깥에서 매크로를 정의할 수 있기 때문에 훌륭한 기능이다.
```

`gcc -DCONDITION -E main.c`

`#ifndef (정의가 안 되었다면)`는 헤더가드 구문으로도 흔히 사용한다. 이 구문은 전처리 단계에서 헤더파일이 두 번 포함되는 것을 방지한다. 거의 모든 프로젝트에서 C와 C++헤더파일은 첫 명령어로 #ifndef 문을 갖는다.

```c
#ifndef MAIN_H
#define MAIN_H

void say();
int read_age();

#endif
```

첫번째로 헤더 파일이 포함될 때, MAIN_H 매크로는 아직 정의되지 않았으므로 전처리기는 계속해 #ifndef ~ #endif 블록으로 진입한다. 그 후에 헤더를 두번째로 포함하게 되면, MAIN_H 매크로가 이미 정의되었기 때문에 전처리기는 해당 부분을 건너뛰게 된다.

## 1.2 포인터 변수

### 1.2.1 문법

어떤 종류의 포인터라도 개념은 단순하다. `메모리주소`를 저장하는 단순한 변수일 뿐이다. 

```c
int main(int argc, char **argv)
{
    int var = 100;
    int * ptr;
    ptr = &var;
    *ptr = 200;
    
    return 0;
}
```

위 예제는 포인터 문법에 관해 알아야 할 모든 것을 담고 있다. main 함수의 첫 번째 줄에서는 `stack segment`의 맨 위에 놓은 var 변수를 선언한다. 두번째 줄은 초깃값이 0인 포인터 ptr을 선언한다. 0의 값을 갖는 포인터는 `NULL pointer`라고 한다. ptr 포인터의 값이 0인 한, 널 포인터로 간주한다. 선언 시 유효한 주소를 저장하지 않는 경우 포인터를 널로 만드는 것이 중요하다.

세번째 줄의 &은 참조연산자, 네번째 줄의 *은 역참조 연산자이다.

### 1.2.2 포인터 변수의 산술연산

메모리를 가장 단순한 그림으로 나타낸다면 아주 긴 1차원 바이트 배열이다. 그래서 포인터에 대한 연산은 바이트 배열에서의 움직임과 유사하다. 포인터를 1만큼 증가시키면, 메모리에서 1바이트 이상 앞으로 나아가게 되기 때문에 새로운 개념이 필요하다. 이러한 산술연산 간격은 포인터의 c `자료형 data type`에 의해 결정된다.

```c
#include <stdio.h>

#define SIZE 5

int main(int argc, char **argv)
{
    int arr[SIZE];
    arr[0] = 9;
    arr[1] = 22;
    arr[2] = 30;
    arr[3] = 23;
    arr[4] = 18;
    
    for (int i = 0; i< SIZE; i++) {
        printf("%d\n", arr[i]);
    }
    return 0;
}
```

 위 예제는 `인덱서 문법([와 ] 사이에 있는 정수)`를 이용해 원소에 접근하는 대신 포인터를 사용하려면 다른 방식으로 접근해야 한다.

```c
#include <stdio.h>

int main(int argc, char** argv)
{
    int arr[SIZE];
    arr[0] = 9;
    arr[1] = 22;
    arr[2] = 30;
    arr[3] = 23;
    arr[4] = 18;
    
    int * ptr = &arr[0];
    for(;;){
        printf("%d\n", ptr);
        if (ptr == &arr[SIZE - 1]) {
            break;
        }
        ptr++;
    }
    return 0;
}
```

 앞에서 명확히 알 수 있듯이 ptr 포인터는 `int*`자료형을 갖는다. 배열의 각 원소가 int 자료형이므로 정수를 가리킬 수 있어야 한다. 따라서 ptr 포인터를 증가시키면 포인터는 배열 내부의 다음 원소를 가리키게 된다. 그리고 c 배열이란 실제로는 자신의 첫 번째 원소를 가리키는 포인터이다. 따라선 예제에서 arr의 실제 자료형은 `int*`이다. 그러므로 코드는 `int* ptr = &arr[0]; `대신 `int* ptr = arr;`로 작성해야 한다.



### 1.2.3 제네릭 포인터

 void* 자료형의 포인터는 `제네릭 포인터`라고 한다. 다른 모든 포인터와 마찬가지로 제네릭 포인터도 주소를 가리킬 수 있지만, 실제 자료형은 알 수 없다. 그러므로 산술연산 간격도 알 수 없다. 제네릭 포인터는 다른 포인터의 내용을 담기 위해 주로 사용된다. 하지만 다른 포인터의 실제 자료형은 담지 않는다. 따라서 제네릭 포인터는 역참조될 수 없으며, 산술연산도 할 수 없다.

```c
// 해당 예제를 컴파일하게 되면 오류 메세지가 발생한다.
#include <stdio.h>

int main(int argc, char** argv)
{
    int var = 0;
    int* ptr = &var;
    void * gptr = ptr;
    printf("%d\n", *gptr);
    return 0;
}
```

역참조도 할 수 없는 제네릭 포인터는 어디에 좋다는 걸까? 제네릭 포인터를 이용하면 여러가지 포인터를 입력 인수로 받을 수 있는 `제네릭 함수`를 매우 편리하게 정의할 수 있다.

```c
#include <stdio.h>

void print_bytes(void* data, size_t length){
    char delim = ' ';
    unsigned char *ptr = data;
    
    for (size_t i = 0; i < length; i++) {
        printf("%c 0x%x", delim, *ptr);
        delim = ',';
        ptr++;
    }
    printf("\n");
}

int main(int argc, char **argv)
{
    int a = 9;
    double b = 18.9;
    print_bytes(&a, sizeof(int));
    print_bytes(&b, sizeof(double));
    
    return 0;
}
```

void 포인터를 할당할 때 명시적 형 변환이 __꼭 필요하지는 않다__ 는 점을 명심하자. print_bytes 함수 안에서는 메모리 내부에서 움직일 수 있도록 unsigned char 포인터를 사용해야 한다. 사용하지 않을 경우, void 포인터의 매개변수인 data를 직접 연산할 수 없다. 마지막으로 size_t 는 C 에서 크기를 저장하지 위해 주로 사용되는 표준 자료형이자 부호가 없는 자료형이다.

### 1.2.4 포인터 크기

포인터의 크기는 C 의 특정한 개념이어서가 아니라, 아키텍처에 따라 다르다. C는 하드웨어와 관련된 세부 사항을 크게 신경 쓰지 않으므로 포인터나 다른 프로그래밍 개념에 관해서는 포괄적인 방식을 제공하려고 한다. 이러한 이유로 C는 표준으로 여겨진다.

```
아키텍처는 컴퓨터 시스템에 사용된 하드웨어를 가리키는 말이다.
```

포인터의 크기를 알려면 항상 sizeof 함수를 사용해야 한다. 대상 아키텍처에서 sizeof(char*)의 결괏값을 확인하면 포인터의 크기를 알 수 있다. 하지만 다른 아키텍처에서는 포인터의 크기가 다르다. 작성한 코드가 포인터의 크기에 대한 특정값에 의존하면 안되며 그에 관해 어떠한 어림짐작도 하지 말아야한다.



### 1.2.5 허상 포인터

포인터는 대개 변수가 할당된 지점의 주소를 가리킨다. 변수가 저장되지 않은 곳의 주소를 읽거나 수정하는 일은 큰 실수이며, 충돌 또는 __세그멘테이션 오류__ 를 발생시킨다. 예제를 보자

```c
#include <stdio.h>

int* create_an_integer(int default_value) {
    int var = default_value;
    return &var;
}

int main(int argc, char** argv)
{
    int * ptr = NULL;
    ptr = create_an_integer(10);
    printf("%d\n", *ptr);
    return 0;
}
```

main 함수에서는 생성된 정수의 주소를 var에 받고 ptr 포인터에 자장한다. 그다음 ptr 포인터는 역참조 되어 var 변수에 저장되었던 값이 출력된다. 이때 컴파일은 성공적으로 종료되지만 지역변수 주소 반환에 대한 오류가 발생된다. ptr 포인터는 이미 메모리에서 할당이 해제된 부분을 가리키고 있다. 할당이 해제된 곳은 변수 var의 메모리 영역이었던 곳이다. 주소값은 함수로 반환될 수 있지만 ptr은 메모리의 유효하지 않은 값을 가리키는 허상 포인터가 된다. 이때 포인터를 역참조하면 심각한 문제와 프로그램 충돌을 야기하게 된다.

 예제를 다시 작성하려면 어던 방법이 더 적절할까? 바로 `힙 메모리`를 사용하는 것이다.

```c
#include <stdio.h>
#include <stdlib.h>

int* create_an_integer(int default_value) {
    int *var_ptr = (int*)malloc(sizeof(int));
    *var_ptr = default_value;
    return var_ptr;
}

int main(int argc, char **argv)
{
    int* ptr = NULL;
    ptr = create_an_integer(10);
    printf("%d\n", *ptr);
    free(ptr);
    return 0;
}
```

stdlib 헤더파일을 포함하므로 malloc과 free 라는 두 함수를 사용한다. create_an_integer 함수 내부에서 생성된 정수형 변수는 더 이상 지역변수가 아니다. 이 변수는 힙 메모리로부터 할당되었으며 변수의 수명이 함수의 선언에 제한되지 않는다. 이 번수를 가리키는 포인터는 더이상 허상 포인터가 아니며, 변수가 존재하는 한 그리고 비워지지 않는 한 역참조될 수 있다.



## 1.3 함수

C는 `절차적 procedural` 프로그래밍 언어이다. C 에서 함수는 절차로 작용하며, C 프로그램의 구성 요소에 해당한다. 그러므로 함수가 무엇이고 어떻게 행동하는지, 함수에 들어가고 나갈 때 어떤 일이 발생하는지 알아야 한다. 일반적으로 함수는 값 대신 알고리즘을 저장하는 변수와 유사하다. 새로운 자료형에 변수와 함수를 함께 넣음으로써, 서로 관련 있는 변수와 알고리즘을 같은 개념안에 저장할 수 있다. 이것이 바로 `객체지향 프로그래밍 OOD`에서 하는 일이다.

### 1.3.1 함수의 구조

함수는 이름과 입력 매개변수의 목록, 출력결과의 목록을 가진 논리 상자이다. C와 C의 영향을 받은 다른 많은 프로그래밍 언어에서 함수는 단 하나의 값만을 반환한다. C++이나 자바같은 객체지향 언어의 함수는 예외적으로 값을 두개 이상 반환하는 경우도 있지만, C는 그렇지 않다. C에서 함수는 언제나 `블로킹 함수`여야 한다. 호출자함수는 호출된 함수가 종료되기를 기다려야만 호출된 함수가 반환하는 값을 받을 수 있다.

블로킹 함수와 반대로 `논블로킹 함수`가 있다. 논블로킹 함수를 호출하면, 호출하는 쪽의 함수는 호출 대상이 되는 함수가 종료할 때까지 기다리지 않고 실행을 계속할 수 있다. 논블로킹 도식 가운데에는 `콜백 메커니즘`이 존재한다. 콜백 메커니즘은 호출된 함수가 종료될 때 트리거된다. 논블로킹 함수는 __비동기 함수__ 라고도 한다. C에는 비동기 함수가 없기 때문에, 멀티스레딩 솔루션을 이용해서 이를 실행해야 한다. 요즘은 블로킹 함수보다 논블로킹 함수에 관한 관심이 늘어나고 있다는 점이 흥미롭다. 논블로킹 함수는 __사건 기반 프로그래밍event-oriented programming(EDP)__ 접근법의 중심이며, 사건기반프로그래밍에서 작성된 함수 대다수는 논블로킹이다.



### 1.3.2 설계의 중요성

함수는 절차적 프로그래밍에서 핵심 요소이다. 함수는 코드를 작성하는 방식에 지대한 영향을 미쳤다. 함수를 사용함으로써 준 변수 개체 semi-variable entity에 로직을 저장할 수 있으며 필요할 때마다 언제 어디서든 불러올 수 있다. 또한 함수로 구체적인 로직을 한 번만 작성한 뒤 다양한 곳에서 여러 번 사용할 수도 있다.

게다가 함수는 기존의 다른 로직으로부터 일부를 숨길 수도 있다. 즉, 함수는 다양한 논리 구성 요소 사이에서 추상화를 도입한다. avg 함수를 호출하는 main 함수가 있다고 해보자. 이때 avg 내부 로직을 변경하면 main 내부 로직을 변경할 필요가 없다. main 함수는 오직 avg 함수의 이름과 가용성에만 의존하기 때문이다.



### 1.3.3 스택관리

유닉스 계열 운영체제에서 실행되는 프로세스의 메모리 레이아웃을 살펴본다면, 모든 프로세스가 비슷한 레이아웃을 공유한다. 그중 스택 세그먼트는 모든 지역변수, 배열, 구조체가 할당되는 기본 메모리의 위치이다. 함수에서 지역 변수를 선언할 때마다 지역 변수는 스택 세그먼트에 할당된다. 그리고 할당은 언제나 스택의 제일 윗부분에서 일어난다. 스택이라는 용어답게 쌓이는 것처럼 행동하게 되며 변수와 배열은 언제나 스택의 가장 위에 할당된다. 스택 세그먼트는 함수 호출에도 사용된다. 함수를 호출하면 반환 주소와 모든 전달 인수를 포함한 __스택 프레임__ 이 스택 세그먼트의 가장 위에 놓이고 나서야 함수 로직이 실행된다. 함수 호출이 끝난뒤 스택 프레임은 제거되며, 반환 주소가 지정된 명령어가 실행되고, 직전 호출 함수로 계속 이어진다.

함수 몸체에서 선언되는 모든 지역  변수는 스택 세그먼트의 가장 위에 놓인다. 그러므로 함수에서 떠날때 모든 스택 변수는 비워진다. 이를 __지역변수__ 라고 부르며, 다른 함수에서 접근하지 못한다. 또한 함수에 진입하기 전이나 함수를 떠난 뒤 지역변수가 정의될 수 없는 이유도 이 메커니즘으로 설명된다.

스택은 메모리에서 한정된 일부분이며, 이를 다 채우게 되면 `스택 오버플로우`오류가 발생한다.



### 1.3.4 값에 의한 전달 vs 참조에 의한 전달

C에는 참조가 없다. 그러므로 참조에 의한 전달도 존재하지 않는다. 모든 것은 함수의 지역 변수에 복사되며 함수를 떠나면 지역 변수를 읽거나 수정할 수 없다.

```c
#include <stdio.h>

void func(int a){
    a = 5;
}

int main(int argc, char** argv)
{
    int x = 3;
    printf("Before function call : %d\n", x);
    func(x);
    printf("After function call : %d\n", x);
    return 0;
}
```

```
Before function call : 3
After function call : 3
```

예상한대로 값에 의한 참조이기 때문에 값이 변경되지 않았다. 하지만 포인터를 이용해 역참조하면 호출하는 쪽의 함수의 변수를 수정할 수 있도록 한다.

```c
#include <stdio.h>

void func(int *a){
    int b = 9;
    *a = 5;
    a = &b;
}

int main(int argc, char** argv)
{
    int x = 3;
    int *xptr = &x;
    printf("Value before call: %d\n", x);
    printf("Pointer before function call : %p\n", (void*)xptr);
    func(xptr);
    printf("Value after call: %d\n", x);
    printf("Pointer after function call : %p\n", (void*)xptr);
    return 0;
}
```

```
Value before call : 3
Pointer before function call : 0x7ffee99a88ec
Value after call : 5
Pointer after function call : 0x7ffee99a88ec
```

함수 내부의 포인터 매개변숫값을 변경해도 호출하는 함수에서 해당하는 인수는 바뀌지 않는다. C에서 함수를 호출하는 동안 모든 인수는 값에 의해 전달되며, 포인터를 역참조하면 호출하는 쪽의 함수의 변수를 수정할 수 있도록 한다.  포인터를 변수로 전달하는 것이 포인터에 의한 전달이다. 함수에 큰 객체를 전달하는 것 대신 인수로 포인터를 사용하는 편을 주로 권장한다. `8바이트짜리 포인트 인수를 복사하는 것이 수백 바이트의 큰 객체를 복사하는 것보다 훨씬 더 효율적이다.`



## 1.4 함수 포인터

 함수포인터를 갖는다는 것은 c 프로그래밍 언어의 아주 멋진 또 다른 특성이다. 함수 포인터의 활용법은 많지만 큰 이진 파일을 작은 이진 파일로 나누고 이를 다른 작은 실행파일에 다시 넣는 것이 가장 중요하다. 이로 인해 __모듈화__ 와 소프트웨어 설계가 가능해졌다. 함수 포인터는 C++에서 다형성의 실행을 위한 구성 요소이며 함수 포인터 덕분에 기존의 로직을 확장할 수 있다. 변수의 주소를 저장하는 포인터 변수처럼 함수 포인터도 함수의 주소를 저장하며 함수를 간접적으로 호출할 수 있도록 구현한다.

```c
#include <stdio.h>

int sum(int a, int b) {
    return a + b;
}

int subtract(int a, int b) {
    return a - b;
}

int main(){
    int (*func_ptr)(int, int);
    func_ptr = NULL;
    
    func_ptr = &sum;
    int result = func_ptr(5,4);
    printf("Sum : %d\n", result);
    
    func_ptr = &subtract;
    result = func_ptr(5, 4);
    printf("subtract: %d\n", result);
    
    return 0;
}
```

func_ptr은 함수 포인터이며 자신의 시그니처와 맞는 특정 함수만을 가리킨다. 이 시그니처는 포인터가 2개의 저수 인수를 받고 정수 결괏값을 반환하는 함수만을 가리키도록 제한한다.

하나의 함수 포인터를 이용해 같은 인수 목록으로 다른 함수를 호출할 수 있다. 이는 중요한 특징이다. 객체지향 프로그래밍에 익숙하다면 __다형성__ 과 __가상함수__ 가 가장 먼저 떠오를 것이다. 이 방식은 C에서 다형성을 지원하거나 C++의 가성 함수를 모방하는  유일한 방법이다.

일반적으로 함수 포인터에 대해 __타입 별칭__ 을 정의하도록 권장한다.

```c
#include <stdio.h>

typedef int bool_t;
typedef bool_t (*less_than_func_t)(int, int);

bool_t less_than(int a, int b) {
    return a < b ? 1 : 0;
}

bool_t less_than_modular(int a, int b) {
    return (a % 5) < (b % 5) ? 1 : 0;
}

int main(int argc, char ** argv){
    less_than_func_t func_ptr = NULL;
    
    func_ptr = &less_than;
    bool_t result = func_ptr(3, 7);
    printf("%d\n", result);
    
    func_ptr = &less_than_modular;
    result = func_ptr(3, 7);
    printf("%d\n", result);
    return 0;
}
```

typedef 키워드는 이미 정의된 타입을 위해 별칭을 정의한다. 이러한 별칭은 코드에 가독성을 부여하고 길고 복잡한 자료형에서 더 짧은 이름을 고를 수 있도록 한다. C에서 새 타입은 주로 _t 로 끝난다는 규칙이 있는데, size_t 나 time_t와 같은 다른 표준  타입 별칭에서도 이를 찾아볼 수 있다.



## 1.5 구조체

구조체를 도입한 덕분에 프로그래밍 언어가 __캡슐화__ 라는 위대한 단계로 나아갈 수 있었다. 프로그래밍 언어는 인간의 사고방식을 이해할 수 있었으며, 사고의 구성 요소를 저장하고 처리할 수 있었다. 그리고 구조체가 등장하자 우리의 생각을 닮은 언어를 갖게 되었다. 구조체는 훌륭한 도구를 만들 플랫폼을 구축하기에는 충분했다.



### 1.5.1 왜 구조체인가?

모든 프로그래밍 언어는 `원시자료형 primitive data type(PDT)`을 갖는다. 원시자료형을 사용하면 자료구조를 설계할 수 있고 이 구조를 중심으로 알고리즘을 작성할 수 있다. 자신이 직접 정의한 자료형이 필요할 때 그리고 프로그래밍 언어의 자료형만으로는 충분하지 않을 때, 구조체를 도입한다. `사용자 정의 자료형 user-defined type (UDT)`은 사용자가 만든 자료형이며 프로그래밍 언어에 속하지는 않는다.

사용자 정의 자료형은 typedef를 사용해서 정의할 수 잇는 자료형과는 다르다는 점을 기억하자. typedef 키워드는 실제로 새 자료형을 만들지는 않는다. 오히려 기존에 정의된 타입의 별칭이나 동의어를 정의한다. 하지만 구조체는 완전히 새로운 사용자 정의 자료형을 프로그램에 넣을 수 있도록 한다.



### 1.5.2 왜 사용자 정의 자료형인가?

우리는 일상적인 분석에서 두뇌를 이용해 매일매일 이 원칙과 방법으로 새로운 자료형을 만든다. 우리는 주변을 정수나 실수, 또는 문자열로 간주하지 않는다. 우리는 같은 대상에 서로 연관된 속성을 그룹으로 묶는 법을 익혀왔다. 그렇기에 더 고수준의 로직, 인간 수준의 로직과 충분히 비슷하게 문제를 분석하려면 새로운 자료형이 필요하다.

소프트웨어를 일상적으로 분석하려면 새 자료형이 필요하지만, CPU는 새 자료형을 이해하지 못한다. CPU는 원시 자료형과 빠른 계산을 고수한다. 왜냐하면 그렇게 설계되었기 때문이다. 이러한 점에서 다행히 C는 CPU 수준의 로직과 그리 멀지 않으며 쉽게 번역될 수 있는 타입시스템을 가진다. C는 저급 또는 하드웨어 수준의 프로그래밍 언어라는 점을 들어본 적이 있을 것이다. 이것이 몇몇 회사나 조직에서 핵심 프레임워크를 아직도 C로 작성하고 유지하려는 이유이다.



### 1.5.3 구조체의 역할

구조체는 하나의 통합된 타입 아래 관련된 값을 캡슐화한다. 

```c
struct color_t {
    int red;
    int green;
    int blue;
}
```

구조체는 캡슐화를 수행한다. 캡슐화는 소프트웨어 설계에서 가장 핵심적인 개념이다. 이는 새로운 자료형 아래에 서로 관련이 있는 필드를 그룹으로 묶고 캡슐화한다. 그러고 나서 필요한 변수를 정의할 때 이 새로운 자료형을 사용한다.



### 1.5.4 메모리 레이아웃

C 개발자는 구조체 변수의 메모리 레이아웃을 정확히 알아야한다. 메모리에 나븐 레이아웃이 잇을 경우 특정 아키텍처에서는 성능이 저하된다. CPU를 위한 명령어를 만들기 위해 코드를 작성한다는 점을 잊지 말자. 값은 메모리에 저장되고, CPU는 이 값을 충분히 빠르게 읽고 쓸 수 있어야 한다.  메모리 레이아웃을 이해하면 CPU가 작동하는 방식을 이해할 수 있고, 코드를 수정해 더 나은 결과를 얻을 수 있다.

```c
#include <stdio.h>

struct sample_t {
    char first;
    char second;
    char third;
    short fourth;
};

void print_size(struct sample_t * var) {
    printf("size: %lu bytes\n", sizeof(*var));
}

void print_bytes(struct sample_t* var) {
    unsigned char* ptr = (unsigned char*)var;
    for (int i = 0; i < sizeof(*var); i++, ptr++) {
        printf("%d", (unsigned int)*ptr);
    }
    printf("\n");
}

int main(int argc, char** argv)
{
    struct sample_t var;
    var.first = 'A';
    var.second = 'A';
    var.third = 'A';
    var.fourth = 'A';
    print_size(&var);
    print_bytes(&var);
    return 0;
}
```

모든 것에 관한 정확한 메모리 레이아웃을 알고 싶다는 갈증은 C와 C++에 한정된 것이며, 고급 프로그래밍 언어로 가면 이 갈증이 사라진다. 예를 들어 자바나 파이썬 개발자는 매우 저수준의 메모리 관리와 관련된 세부 사항은 잘 모르는 편이다. 자바나 파이썬은 메모리에 관한 세부사항을 제공하지 않는다.

```
// 결과
Size: 6bytes
65 66 67 0 253 2
```

sizeof (sample_t)는 6바이트를 반환한다. 구조체 변수의 메모리 레이아웃은 배열과 매우 유사하다. 배열의 모든 원소는 메모리에서 서로 인접한다.  배열에서는 모든 원소가 같은 자료형을 가지며 크기도 같지만, 구조체 변수에는 해당하지 않는다는 차이가 있다. 위 예제에서 구조체를 보면 4개의 필드를 가지는데 3개는 char 필드이고 하나는 short 필드이다. 그러면 sample_t 타입의 각 변수는 메모리 레이아웃에서 5(1*3 + 2)바이트일텐데 왜 6바이트로 출력이 될까?

왜 구조체 변수의 크기가 5바이트가 아닌지 더 명확하게 설명하려면 __메모리 정렬__ 이라는 개념을 소개해야 한다. CPU는 언제나 모든 계산을 한다. 게다가 계산하기 전에 메모리로부터 값을 로드해야 하며 계산한 이후에는 그 값을 메모리에 다시 저장해야 한다. CPU 내부의 계산은 매우 빠르지만, 메모리 접근은 비교적 느리다. CPU가 메모리와 상호작용하는 방식은 프로그램을 향상시키거나 이슈를 디버깅하는 데에 활용할 수 있으므로 꼭 알아두자

CPU가 각 메모리에 접근할 때 특정 바이트의 숫자를 주로 읽는다. 이 바이트 수는 주로 __워드__ 라고 한다. 메모리는 워드로 나뉘며, 메모리로부터 읽고 쓰기 위해 CPU가 사용하는 작은 기본 단위를 워드라 한다. 워드에 있는 바이트의 실제 숫자는 아키텍처에 따라 다르다. 메모리 정렬을 고려하면 시작하는 바이트가 워드의 시작점에 있을 때, 이 변수는 메모리에 정렬되었다고 한다. 이러한 방식으로  CPU는 메모리 접근에 최적화된 숫자에서 그 값을 로드한다.

위 예제를 고려하면, 첫번째 3개 필드는 1바이트이다. 이들은 구조체 레이아웃의 첫번째 워드에 탑재된다. 그리고 한 번의 메모리 접근으로 모두 읽을 수 있다. 네번째 필드는 2바이트를 차지한다. 메모리 정렬을 고려하지 않는다면, 첫 번째 바이트는 첫 번째 워드의 마지막 바이트가 되어 정렬되지 않은 상태가 된다.  이 경우 CPU는 필드의 값을 회수하기 위해 몇 비트를 오가며 2개의 메모리의 접근해야 한다. 이런 이유로 67 뒤에 추가로 0이 보이게 된다. 0 바이트는 현재 워드를 완성하기 위해 추가되며, 네 번째 필드가 다음 워드에서 시작할 수 있도록 한다. 여기서 첫번째 워드는 0바이트 하나가 패딩되어 있다고 할 수 있다. 컴파일러는 __패딩__ 을 사용해서 메모리의 값을 정렬한다. 패딩은 정렬을 맞추기 위해 바이트를 추가하는 기술이다.

정렬을 사용하지 않을 수도 있다. C는 정렬된 구조체에 대해 더 구체적인 용어를 사용한다. 이러한 정렬된 구조체는 패킹되지 않은 것이다. 반면, __패킹된 구조체__ 는 정렬되지 않은 것이며, 패킹된 구조체를 사용하면 이진 파일 비호환성을 야기하고 성능이 저하된다.

```c
// 패킹된 구조체 선언하기
#include <stdio.h>

struct __attribute__((__packed__))sample_t {
    char first;
    char second;
    char third;
    short fourth;
};
//...
```

```
// 결과
Size: 5bytes
65 66 67 253 2
```

예측한 바와 정확히 결과가 나온다. 패킹된 구조체는 메모리가 제한적인 환경에서 주로 사용된다. 하지만 대부분의 아키텍처에서 성능에 매우 부정적인 영향을 줄 수 있다. 새  CPU만이 추가 비용없이 다수의 워드로부터 정렬되지 않은 값을 읽을 수 있다. 참고로 메모리 정렬은 기본적으로 활성화되어 있다.



### 1.5.5 중첩 구조체

앞서 설명했듯이 일반적으로 C에는 두 종류의 자료형이 있다. 프로그래밍 언어가 제공하는 자료형과 struct 키워드를 사용해서 개발자가 정의한 자료형이다. 전자는 원시자료형(PDT), 후자는 사용자 정의 자료형(UDT)이다.

이번에는 다른 사용자 정의 자료형으로 만들어진 __복합 자료형 complex data type__ 을 살펴보ㄷ자. 복합 자료형은 몇 개의 구조체를 중첩한 결과이다.

```c
typedef struct {
    int x;
    int y;
} point_t;

typedef struct {
    point_t center;
    int radius;
} circle_t;

typedef struct {
    point_t start;
    point_t end;
} line_t;
```

복합구조체의 크기는 단순 구조체와 정확히 동일한 방식으로 모든 필드의 크기를 더해 계산한다. 다만 복합 구조체의 크기에 영향을 줄 수 있기 때문에 정렬에 주의해야 한다. 만약 sizeof(int)가 4바이트라면 sizeof(point_t)는 8바이트가 된다. 그러면 sizeof(circle_t)는 12바이트, sizeof(line_t)는 16바이트가 된다.



### 1.5.6 구조체 포인터

구조체 변수 포인터가 구조체 변수의 첫 번째 필드의 주소를 가리킨다는 것을 꼭 알아야 한다. 

```c
#include <stdio.h>

typedef struct {
    int x;
    int y;
} point_t;

typedef struct {
    point_t center;
    int radius
} circle_t;

int main(int argc, char **argv)
{
    circle_t c;
    
    circle_t* p1 = &c;
    point_t* p2 = (point_t*)&c;
    int* p3 = (int*)&c;
    
    printf("p1: %p\n", (void*)p1);
    printf("p2: %p\n", (void*)p2);
    printf("p3: %p\n", (void*)p3);
    return 0;
}
```

```
// 결과
p1: 0x7ffee846c8e0
p1: 0x7ffee846c8e0
p1: 0x7ffee846c8e0
```

모든 포인터는 같은 바이트를 가리키지만 자료형은 서로 다르다. 다른 라이브러리로부터 가져오는 구조체를 확장하려면 필드를 더 추가하는 방식을 주로 사용한다. 이는 C에서 __상속하는 방식__ 이기도 하다.



## 1.6 마무리

이번 1장에서 C의 중요한 구성 요소를 살펴봤다. 여기에서 더 나아가 이러한 요소의 설계 측면과 그 이면에 있는 개념도 설명했다. 이런 요소를 알맞게 사용하려면 당연히 구성 요소의 다른 측면도 더 깊이 이해해야 한다.

- C의 전처리 단계에 관해 다뤘고, 다양한 지시자가 전처리기에 어떤 영향을 주어서 다르게 작동하거나 특정 C 코드를 생성하게 만드는지 설명했다.
- 매크로와 매크로 확장 메커니즘을 이용하면 변환 단위를 컴파일 단계로 전ㄴ달하기 전에 C코드를 생성할 수 있다.
- 조건부 지시자는 특정 조건에서 전처리된 코드를 변경하며 상황에 따라 다른 코드를 생성한다.
- 포인터 변수 개념과 C에서 포인터 변ㄴ수가 어떻게 이용되는지를 알아봤다.
- 제네릭 포인터를 소개했으며 포인터의 종류와 상관없이 포인터를 받는 함수를 어떻게 만드는지도 알아봤다.
- 포인터를 잘못 사용하면 발생할 수 있는 위험한 상황인 세그멘테이션 오류와 허상 포인터를 다뤘다.
- 이어서 함수를 설명했고, 문법을 복습햇다.
- 함수의 설계 측면을 살펴봤고, 잘 만들어진 절차적 C 프로그램에서 설계가 미치는 영향을 알아봤다.
- 함수 호출 메커니즘을 설명했고 스택 프레임을 이용해 함수에 인수가 전달되는 방법을 알아봤다.
- 함수 포인터에 관해서도 알아봤다. 함수 포인터의 강력한 문법은 유사함수개체에 로직을 저장해 나중에 이를 사용할 수 있도록 한다. 함수 포인터는 오늘날 탑재되고 실행되는 모든 프로그램이 사용하는 기초 메커니즘이다.
- 함수 포인터와 더불어 구조체는 C의 캡슐화를 탄생시켰다. 이에 관해서 3부에서 더 살펴보자
- 구저체의 설계 측면과 C로 프로그램을 설계하는 방식에 구조체가 미친 영향을 설명했다.
- 구조체 변수의 메모리 레이아웃과 CPU 사용을 최대화하기 위해 메모리 내부에 구조체 변수가 배치되는 방식도 알아봤다.
- 중첩 구조체도 다뤗다. 또한 복잡한 구조체 변수의 내부를 살펴봤으며 모ㅔ모리 레이아웃이 어떻게 보여야 하는지도 알아봤다.
- 구조체 포인터에 관해 설명했다.



